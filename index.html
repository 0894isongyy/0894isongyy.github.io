<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è±¬ç¥é»ƒæ˜ Pignarok Arena (Ver 23.1)</title>
    <!-- å¼•å…¥ PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- åŸºç¤è¨­å®š --- */
        :root {
            --ui-max-width: 500px;
            --primary-gold: #ff99cc;
            --bg-overlay: rgba(0, 0, 0, 0.4);
            --accent-blue: #55ccff;
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: 'Cinzel', serif, "Microsoft JhengHei", "Helvetica Neue", sans-serif;
            background: #000; color: white;
            touch-action: none; width: 100vw; height: 100vh;
            -webkit-user-select: none; user-select: none;
        }
        
        #viewport {
            position: relative; width: 100%; height: 100%;
            background: #87CEEB; overflow: hidden;
        }

        #viewport canvas { display: block; width: 100% !important; height: 100% !important; outline: none; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle, rgba(40, 20, 80, 0.95) 0%, rgba(10, 5, 20, 1) 100%);
            z-index: 2000; transition: opacity 0.5s ease; padding: 20px; box-sizing: border-box;
            opacity: 0; pointer-events: none;
        }

        /* Mobile Scroll Fix */
        .overlay-screen.scrollable {
            justify-content: flex-start;
            overflow-y: auto;
            padding-top: 60px;
            padding-bottom: 40px;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        
        .overlay-screen.active {
            opacity: 1; pointer-events: auto;
        }

        /* ä¸»ç•«é¢èƒŒæ™¯è±¬ */
        .menu-bg-pig {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            width: 80%;
            max-width: 500px;
            height: auto;
            max-height: 60vh; 
            opacity: 0.25; 
            z-index: 0; 
            pointer-events: none;
            object-fit: contain;
        }

        h1 { 
            font-size: clamp(2.5rem, 8vw, 4.5rem); margin-bottom: 5px; color: var(--primary-gold); 
            text-shadow: 0 0 20px rgba(255, 153, 204, 0.6); letter-spacing: 5px; text-align: center; 
            z-index: 2;
            position: relative; 
        }
        .sub-title { 
            font-size: 1.2rem; color: #fff; margin-bottom: 5px; letter-spacing: 2px; opacity: 0.8; 
            z-index: 2; 
            position: relative;
        }
        
        .version-text {
            font-size: 0.8rem;
            color: #d4af37; 
            margin-bottom: 30px;
            letter-spacing: 1px;
            opacity: 0.9;
            font-family: monospace;
            z-index: 2;
            position: relative;
        }

        .studio-footer {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            font-size: 0.75rem;
            color: #666;
            font-family: 'Cinzel', serif;
            letter-spacing: 3px;
            opacity: 0.7;
        }

        h2 { font-size: 1.4rem; color: #fff; margin-bottom: 15px; border-bottom: 2px solid var(--primary-gold); padding-bottom: 5px; margin-top: 0; }

        input.input-box, select.input-box {
            background: rgba(255, 255, 255, 0.1); border: 2px solid var(--primary-gold);
            color: white; padding: 10px; font-size: 1.1rem; margin: 5px 0;
            border-radius: 8px; text-align: center; width: 80%; max-width: 300px;
            font-family: inherit; outline: none;
        }
        select.input-box option { background: #333; color: white; }
        input.input-box::placeholder { color: #aaa; }

        /* Preset Names Styling */
        .preset-container {
            display: flex; justify-content: center;
            width: 100%; margin-bottom: 10px;
        }

        .room-code-display {
            font-size: 3rem; color: var(--accent-blue); letter-spacing: 10px;
            margin: 20px 0; padding: 15px 40px; border: 3px dashed rgba(255, 255, 255, 0.3);
            background: rgba(0,0,0,0.3); border-radius: 10px;
        }

        .player-list {
            list-style: none; padding: 0; width: 100%; max-width: 400px; margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden;
        }
        .player-list li {
            background: rgba(255,255,255,0.05); padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
        }
        .tag-host { color: #f1c40f; font-size: 0.8rem; border: 1px solid #f1c40f; padding: 2px 6px; border-radius: 4px; }
        .tag-me { color: #2ecc71; font-size: 0.8rem; }

        @keyframes breathe {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }
        .breathing-text {
            animation: breathe 2.5s infinite ease-in-out;
            color: #88ccff;
            font-size: 0.9rem;
            margin-top: 10px;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 1px;
        }

        .mini-char-select {
            display: flex; gap: 10px; margin: 10px 0; width: 80%; max-width: 300px;
        }
        .mini-card {
            flex: 1; padding: 10px; border: 1px solid #888; border-radius: 8px;
            cursor: pointer; transition: 0.2s; background: rgba(0,0,0,0.3);
            display: flex; flex-direction: column; align-items: center; opacity: 0.6;
        }
        .mini-card.active {
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2);
            opacity: 1; transform: scale(1.05);
        }
        .mini-icon { font-size: 1.5rem; margin-bottom: 5px; }

        #turn-hint {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 1rem; font-weight: bold; text-shadow: 0 0 10px #000;
            background: var(--bg-overlay); padding: 5px 15px; border-radius: 20px;
            display: none; z-index: 50; pointer-events: none;
            white-space: nowrap; border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @keyframes hint-flash { 0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); } 50% { opacity: 0.3; transform: translateX(-50%) scale(0.95); } }
        .flashing { animation: hint-flash 1s infinite ease-in-out; }

        .btn-gold {
            padding: 12px 30px; font-size: 1.1rem; background: rgba(255, 153, 204, 0.2);
            border: 2px solid var(--primary-gold); color: var(--primary-gold); cursor: pointer; border-radius: 50px;
            transition: all 0.3s; font-family: 'Cinzel', serif; text-transform: uppercase;
            max-width: 300px; width: 100%; margin-bottom: 10px;
            z-index: 5;
        }
        .btn-gold:hover { background: var(--primary-gold); color: #1a0d0d; transform: scale(1.05); }
        .btn-gold:disabled { border-color: #555; color: #888; background: transparent; cursor: not-allowed; transform: none; }

        .btn-back { border-color: #aaa; color: #ccc; font-size: 0.9rem; padding: 8px 20px; margin-top: 5px; width: auto; }

        .lang-container {
            display: flex; gap: 15px; margin-bottom: 30px;
            z-index: 5;
        }
        .btn-lang {
            padding: 8px 20px; font-size: 0.9rem; background: transparent;
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            transition: all 0.3s;
        }
        .btn-lang.active { background: var(--primary-gold); color: #000; border-color: var(--primary-gold); }
        .btn-lang:hover { transform: scale(1.1); }

        .selection-container { 
            display: flex; gap: 15px; margin-bottom: 30px; width: 100%; max-width: 600px;
            flex-direction: row; 
        }
        @media (max-width: 350px) { .selection-container { flex-direction: column; } }

        .char-card {
            flex: 1; background: rgba(255,255,255,0.05); border: 2px solid transparent;
            border-radius: 12px; padding: 15px; cursor: pointer; transition: 0.3s;
            display: flex; flex-direction: column; align-items: center; text-align: center;
        }
        .char-card.active { border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2); transform: translateY(-5px); }
        .char-portrait-icon { font-size: 3rem; margin-bottom: 5px; }

        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        
        #top-announcer {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            width: 100%; max-width: var(--ui-max-width);
            text-align: center; pointer-events: none; z-index: 100;
        }
        #timer { color: #fff; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1); }
        #move-display {
            color: var(--primary-gold); font-size: clamp(1rem, 3.5vw, 1.3rem); font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1);
            margin-top: 5px; opacity: 0; transition: opacity 0.3s;
            background: rgba(0,0,0,0.8); padding: 12px 30px; border-radius: 50px;
            display: inline-block; border: 3px solid var(--primary-gold);
            white-space: normal; width: auto;
        }

        #status-log {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: var(--ui-max-width); height: 42px; background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 153, 204, 0.4); border-radius: 8px; padding: 5px; font-size: 0.8rem; overflow-y: auto;
            pointer-events: auto; color: #eee; backdrop-filter: blur(3px); z-index: 30; text-align: left;
        }
        
        #card-description {
            position: absolute; bottom: 160px; 
            left: 0; width: 100%;
            text-align: center; color: #ffeb3b; font-size: 0.85rem; font-weight: bold;
            text-shadow: 0 0 5px #000; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            background: linear-gradient(to right, transparent, rgba(0,0,0,0.7), transparent);
            padding: 5px 0; z-index: 25;
        }

        #bottom-ui-container {
            position: absolute; bottom: 30px; 
            left: 0; width: 100%;
            display: flex; justify-content: center;
            padding: 10px 0 20px 0; 
            background: linear-gradient(to top, rgba(0,0,0,1) 30%, rgba(0,0,0,0.6) 80%, transparent);
            pointer-events: auto; z-index: 20;
        }

        #card-area { 
            display: flex; flex-direction: row; gap: 3px; 
            width: 98%; max-width: var(--ui-max-width); 
            justify-content: space-evenly; align-items: flex-end; 
        }

        #player-hp-card {
            flex: 1.2; height: 95px; min-width: 50px;
            background: rgba(80, 0, 40, 0.7); border: 1.5px solid var(--primary-gold); border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 4px 2px; color: #fff; backdrop-filter: blur(10px);
            font-size: 0.58rem; font-weight: bold; line-height: 1.3; text-align: center; box-sizing: border-box;
        }

        .name-text { font-size: 0.62rem; color: var(--primary-gold); margin-bottom: 2px; width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .hp-text { font-size: 0.58rem; color: #ffccdd; }
        .fatigue-text { color: #ffaa00; font-size: 0.52rem; }
        .rage-text { font-size: 0.52rem; color: #ff8888; }

        .card {
            flex: 1; height: 95px; min-width: 40px; 
            background: rgba(255, 255, 255, 0.1); border: 1.2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; cursor: pointer; transition: 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; color: #fff; font-weight: bold; backdrop-filter: blur(5px); 
            font-size: 0.55rem; 
            padding: 2px; box-sizing: border-box; user-select: none;
        }
        .card:active { transform: scale(0.92); }
        .card.selected { 
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.3); 
            transform: scale(1.15) translateY(-10px); box-shadow: 0 0 20px rgba(255, 153, 204, 0.6); z-index: 100;
        }
        .card.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .card.disabled-tut { opacity: 0.3; pointer-events: none; filter: grayscale(1); border-color: #555; }
        .card.demoing { border-color: #55ccff; background: rgba(0, 100, 200, 0.4); transform: scale(1.05); }

        .card:hover { background: rgba(255, 255, 255, 0.2); }

        @keyframes card-breathing-red { 0%, 100% { box-shadow: 0 0 5px #ff5555; } 50% { box-shadow: 0 0 20px #ff0000; } }
        @keyframes card-breathing-blue { 0%, 100% { box-shadow: 0 0 5px #55ccff; } 50% { box-shadow: 0 0 20px #0088ff; } }
        
        .card.super { color: #000; border-color: #fff; font-weight: 800; }
        .card.super-red { animation: card-breathing-red 1.5s infinite; background: linear-gradient(135deg, #ff9999, #fff); }
        .card.super-blue { animation: card-breathing-blue 1.5s infinite; background: linear-gradient(135deg, #99ccff, #fff); }

        .circle-btn {
            position: absolute; width: 45px; height: 45px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid var(--primary-gold);
            color: #fff; font-size: 0.8rem; font-weight: bold;
            cursor: pointer; z-index: 200; display: flex; justify-content: center; align-items: center;
            pointer-events: auto; transition: all 0.2s;
            top: 20px; top: max(20px, env(safe-area-inset-top));
        }
        .circle-btn:hover { transform: scale(1.1); background: var(--primary-gold); color: #000; }

        .home-btn { left: 20px; left: max(20px, env(safe-area-inset-left)); font-size: 1.5rem; padding-bottom: 3px; }

        #game-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1rem; 
            color: #fff; display: none; background: rgba(0,0,0,0.95);
            padding: 15px 25px; 
            border-radius: 15px; 
            border: 2px solid var(--primary-gold); 
            z-index: 3000;
            text-align: center; width: 80%; 
            max-width: 280px; 
            backdrop-filter: blur(10px);
            flex-direction: column; align-items: center; 
            gap: 10px; 
        }
        
        /* Larger font for final victory message */
        .final-victory-text {
            font-size: 2rem !important;
            color: #ffd700;
            text-shadow: 0 0 10px #ff0000;
            margin-bottom: 20px;
        }

        .back-btn-container { position: absolute; top: 20px; right: 20px; z-index: 200; }
        .btn-small {
            padding: 8px 15px; font-size: 0.9rem; background: rgba(0,0,0,0.6);
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            font-family: 'Cinzel', serif;
        }

        /* Ragnarok Online Style Damage Numbers */
        .damage-popup {
            position: absolute;
            color: #ff0000; 
            font-family: "Arial Black", "Arial", sans-serif;
            font-weight: 900;
            font-size: 2.2rem;
            letter-spacing: -2px;
            text-shadow: 
                2px 2px 0 #000, 
               -1px -1px 0 #000,  
                1px -1px 0 #000,
               -1px 1px 0 #000,
                1px 1px 0 #000,
                3px 3px 5px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 4000;
            user-select: none;
            opacity: 0;
            transform: scale(0.5);
        }
        
        @keyframes damage-pop {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-30px) scale(1.3); opacity: 1; }
            40% { transform: translateY(-40px) scale(1.0); opacity: 1; }
            80% { transform: translateY(-60px) scale(1.0); opacity: 1; }
            100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
        }

        @media (min-width: 1024px) {
            #status-log { bottom: 150px; width: 100%; font-size: 1rem; height: 50px; }
            .card { font-size: 0.8rem; }
            .name-text, .hp-text, .fatigue-text, .rage-text { font-size: 0.75rem; }
        }

        /* Cleanup Overlay */
        #cleanup-msg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.85); z-index: 5000; pointer-events: auto;
        }
        #cleanup-msg.active { display: flex; }
        #cleanup-msg h1 { color: #ff99cc; text-shadow: 0 0 20px #ff00cc; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<div id="viewport">
    <div id="cleanup-msg" class="overlay-screen">
        <h1 class="breathing-text">ç­‰å¾…æˆ°å ´æ¸…ç†ä¸­...</h1>
    </div>

    <div id="main-menu" class="overlay-screen active">
        <img src="pignarok_bg.jpg" class="menu-bg-pig" alt="Pig Background">
        <h1 id="menu-title">è±¬ç¥é»ƒæ˜</h1>
        <div class="sub-title">PIGNAROK ARENA</div>
        <div class="version-text">ç‰ˆæœ¬ 23.1</div>
        <div class="lang-container">
            <button id="lang-zh" class="btn-lang active" onclick="window.setLang('zh-TW')">ä¸­æ–‡</button>
            <button id="lang-en" class="btn-lang" onclick="window.setLang('en-US')">ENG</button>
        </div>
        <button id="btn-create" class="btn-gold" onclick="window.UI.showCreate()">å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)</button>
        <button id="btn-join" class="btn-gold" onclick="window.UI.showJoin()">åŠ å…¥ç¶²çµ¡å°æˆ°</button>
        <!-- Removed Tutorial Button -->
        <div class="studio-footer">JASDEV STUDIO 2025</div>
    </div>

    <!-- Scrollable container logic added here -->
    <div id="screen-create" class="overlay-screen scrollable">
        <h2 id="create-title">å‰µå»ºéŠæˆ²æˆ¿é–“</h2>
        <p id="create-name-label">è«‹è¼¸å…¥ä½ çš„æš±ç¨±</p>
        <input type="text" id="host-name" class="input-box" placeholder="åç¨± (16å­—å…§)" maxlength="16">
        <div id="host-presets" class="preset-container"></div> <!-- Added Preset Container -->
        
        <p style="margin-top:5px; font-size:0.9rem; color:#aaa;">è³½åˆ¶ (Match Format)</p>
        <select id="match-format" class="input-box" style="width:80%; max-width:300px;">
            <option value="2">3 å±€ 2 å‹ (Best of 3)</option>
            <option value="3">5 å±€ 3 å‹ (Best of 5)</option>
            <option value="5">7 å±€ 5 å‹ (Best of 7)</option>
        </select>
        <p id="create-char-label" style="margin-top:10px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-host-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div>Odin</div>
            </div>
            <div id="mini-host-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div>Loki</div>
            </div>
        </div>
        <button id="btn-do-create" class="btn-gold" onclick="window.Network.createGame()">ç”Ÿæˆæˆ¿é–“</button>
        <button id="btn-create-back" class="btn-gold btn-back" onclick="window.UI.showMenu()">è¿”å›</button>
    </div>

    <div id="screen-join" class="overlay-screen scrollable">
        <h2 id="join-title">åŠ å…¥ç¶²çµ¡å°æˆ°</h2>
        <input type="text" id="join-name" class="input-box" placeholder="ä½ çš„æš±ç¨± (16å­—å…§)" maxlength="16">
        <div id="join-presets" class="preset-container"></div> <!-- Added Preset Container -->

        <input type="number" id="join-code" class="input-box" placeholder="4ä½æ•¸æˆ¿è™Ÿ" maxlength="4">
        <p id="join-char-label" style="margin-top:10px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-join-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div>Odin</div>
            </div>
            <div id="mini-join-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div>Loki</div>
            </div>
        </div>
        <p id="join-status" style="color:#55ccff; font-size:0.9rem; min-height:20px;"></p>
        <button class="btn-gold" id="btn-connect" onclick="window.Network.joinGame()">é–‹å§‹é€£ç·š</button>
        <button id="btn-join-back" class="btn-gold btn-back" onclick="window.UI.showMenu()">è¿”å›</button>
    </div>

    <div id="screen-lobby" class="overlay-screen scrollable">
        <h2 id="lobby-title">æº–å‚™å¤§å»³</h2>
        <div class="room-code-display" id="lobby-code">----</div>
        <p id="lobby-share-hint">è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)</p>
        <div id="lobby-hint" class="breathing-text">(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)</div>
        <ul class="player-list" id="lobby-list"></ul>
        <div id="host-controls" style="display:none; width:100%; text-align:center;">
            <button class="btn-gold" id="btn-start-net" onclick="window.Network.hostStartGame()" disabled>é–‹å§‹éŠæˆ²</button>
        </div>
        <div id="client-msg" style="display:none; color:#aaa; margin-top:20px;">ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...</div>
        <button id="btn-leave-room" class="btn-gold btn-back" onclick="window.resetGame()">é›¢é–‹æˆ¿é–“</button>
    </div>

    <div id="turn-hint" class="flashing">è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹</div>

    <!-- Removed Char Select Screen as logic handles it -->

    <div id="game-msg"></div>
    <div id="dmg-container" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:4000; overflow:hidden;"></div>

    <div id="game-ui">
        <button class="circle-btn home-btn" onclick="window.resetGame()" title="å›ä¸»é¸å–®">ğŸ </button>
        <div id="scoreboard" style="display:none;"></div>
        <div id="top-announcer">
            <div id="timer">10</div>
            <div id="move-display">æº–å‚™ä¸­...</div>
        </div>
        <div id="card-description"></div> 
        <div id="bottom-ui-container">
            <div id="card-area">
                <div id="player-hp-card">
                    <div id="player-name-display" class="name-text">å¥§ä¸è±¬</div>
                    <div id="hp-line" class="hp-text">HP: 500/500</div>
                    <div id="fatigue-line" class="fatigue-text">ç–²å‹: 0%</div>
                    <div id="rage-line" class="rage-text">æ€’æ°£: 0%</div>
                </div>
                <div id="card-0" class="card" onclick="window.selectCard(0)">ç‰©æ”»âš”ï¸</div>
                <div id="card-1" class="card" onclick="window.selectCard(1)">é­”æ³•ğŸª„</div>
                <div id="slot-2-btn" class="card" onclick="window.selectCard(2)">åæ“ŠğŸ›¡ï¸</div>
                <div id="card-3" class="card" onclick="window.selectCard(3)">åå°„ğŸ’</div>
                <div id="defend-card" class="card" onclick="window.selectCard(4)">é˜²ç¦¦ğŸ§±</div>
                <div id="super-card" class="card super" style="display:none;" onclick="window.selectCard(5)">å¥§ç¾©ğŸ”¥</div>
                <div id="oracle-btn-card" onclick="window.askOracle()">âœ¨</div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    // --- 1. GLOBAL VARIABLES & CONSTANTS ---
    const APP_ID_PREFIX = "pig-ragnarok-v1-"; 
    const apiKey = ""; 
    const MAX_HP_ODIN = 500; 
    const MAX_HP_LOKI = 400;
    const TURN_TIME = 15; 
    let BASE_CAM_Y = 280; let BASE_CAM_Z = 600;
    let DEFAULT_CAM_POS = new THREE.Vector3(0, BASE_CAM_Y, BASE_CAM_Z);
    const DEFAULT_LOOK_AT = new THREE.Vector3(0, 40, -20);
    let targetWins = 2; 

    let scene, camera, renderer, clock, raycaster;
    let players = [], gameState = 'IDLE', timeLeft = TURN_TIME, selectedSlot = -1, selectedTargetId = -1;
    let timerInterval, cpuThinkTimer, playerRage = { red: 0, blue: 0 };
    let selectedPlayerType = 'Odin';
    let currentDemoId = 0; 
    const mouse = new THREE.Vector2();
    let animationId = null; 
    let myPlayerIndex = 0; 
    let isMultiplayer = false;
    let matchScores = {}; 
    let CARD_NAMES = []; 
    // Fix: Re-add isTutorialMode
    let isTutorialMode = false;

    let activeLightnings = [], activeParticles = [], activeProjectiles = [];
    const SHARED_BOX_GEO = new THREE.BoxGeometry(1.2, 1.2, 1.2);

    const PRESET_NAMES = ['å¥§ä¸ä¸‹ç­æ²’', 'æ´›åŸºæ–‘æ–‘', 'è‹±éˆæ®¿æ¸…æ½”å·¥', 'å¥³æ­¦ç¥å¤–é€ä¸­', 'å½©è™¹æ©‹æ”¶è²»å“¡', 'è…°é…¸èƒŒç´¢çˆ¾', 'èŠ¬é‡Œçˆ¾ä¸æ‹†å®¶', 'èŠçˆ¾AIæ ¡é•·', 'è€æŸ¯', 'éŸ“åœ‹é­šä¸¸é•·', 'ä¾¯å‹å®œçµé‡‘è˜­', 'èŠ±åª½', 'é„§ä¸éº—å›', 'å…¬é“ä¼¯'];

    // --- 2. TRANSLATION SYSTEM & UTILS (Must be first) ---
    let currentLang = 'zh-TW';
    const TRANSLATIONS = {
        'zh-TW': {
            title: "è±¬ç¥é»ƒæ˜", singlePlayer: "å–®äººéŠæˆ²", tutorial: "è§’è‰²æ•™å­¸",
            createGameBtn: "å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)", joinGameBtn: "åŠ å…¥ç¶²çµ¡å°æˆ°",
            lobbyHint: "(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)",
            createTitle: "å‰µå»ºéŠæˆ²æˆ¿é–“", enterName: "è«‹è¼¸å…¥ä½ çš„æš±ç¨±", namePlaceholder: "åç¨± (16å­—å…§)",
            chooseChar: "é¸æ“‡ä½ çš„è§’è‰²", doCreateBtn: "ç”Ÿæˆæˆ¿é–“", backBtn: "è¿”å›",
            joinTitle: "åŠ å…¥ç¶²çµ¡å°æˆ°", codePlaceholder: "4ä½æ•¸æˆ¿è™Ÿ", doConnectBtn: "é–‹å§‹é€£ç·š",
            lobbyTitle: "æº–å‚™å¤§å»³", lobbyShare: "è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)", leaveRoom: "é›¢é–‹æˆ¿é–“",
            waitingHost: "ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...", startGame: "é–‹å§‹éŠæˆ²",
            selectCharTitle: "é¸æ“‡ä½ çš„è±¬è±¬æˆ°å£«",
            startBattle: "é–‹å§‹æ±ºé¬¥", 
            back: "è¿”å›", backMenu: "å›ä¸»é¸å–®",
            odinName: "å¥§ä¸è±¬", odinDesc: "é›·éœ†èˆ‡æ¦®è€€",
            lokiName: "æ´›åŸºè±¬", lokiDesc: "è©­è¨ˆèˆ‡é®®è‚‰",
            charOdin: "å¥§æ±€", charLoki: "æ´›åŸº",
            turnHint: "è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹", ready: "æº–å‚™ä¸­...",
            moveNames: ["ç‰©ç†æ”»æ“Š", "é­”æ³•æ”»æ“Š", "åæ“Š", "é­”æ³•åå°„", "é˜²ç¦¦", "çµ‚æ¥µå¥§ç¾©"],
            cardNames: { 0: "ç‰©æ”»âš”ï¸", 1: "é­”æ³•ğŸª„", 2: "åæ“ŠğŸ›¡ï¸", 3: "åå°„ğŸ’", 4: "é˜²ç¦¦ğŸ§±", 5: "å¥§ç¾©ğŸ”¥", swap: "ç£éµğŸ§²" },
            tutCardNames: { 5: "ç‰©å¥§ğŸ”¥", 6: "é­”å¥§âš¡" },
            victory: "å‹åˆ©ï¼", gameOver: "å›åˆçµæŸ", restart: "é‡æ–°é–‹å§‹",
            finalVictory: "æ­å–œ {name} æˆç‚ºè±¬æ—åŒ¹æ–¯çš„ç‹è€…ï¼", finalMenu: "å›åˆ°ä¸»é¸å–®",
            swapSkill: "ç£éµäº¤æ›", counterSkill: "é˜²ç¦¦åæ“Š",
            targetLocked: "(ç›®æ¨™é–å®šä¸­)", dead: "èŠ­æ¯”Qå•¦", fatigue: "ç–²å‹", rage: "æ€’æ°£",
            defendFatigue: "é˜²ç¦¦ç–²å‹ä¸­", defend: "é˜²ç¦¦", tired: "åŠ›ç›¡ğŸ§±",
            cleanup: "ç­‰å¾…æˆ°å ´æ¸…ç†ä¸­...",
            cardDescs: {
                0: "é€ æˆç‰©ç†å‚·å®³ï¼Œå¢åŠ ç´…è‰²æ€’æ°£",
                1: "é€ æˆé­”æ³•å‚·å®³ï¼Œå¢åŠ è—è‰²æ€’æ°£",
                2: { "Odin": "å—åˆ°ç‰©ç†æ”»æ“Šæ™‚è‡ªå‹•åæ“Š", "Loki": "å—åˆ°ç‰©ç†æ”»æ“Šæ™‚èˆ‡æ•µäººäº¤æ›ä½ç½®" },
                3: "åå½ˆå—åˆ°çš„é­”æ³•å‚·å®³",
                4: "å¤§å¹…æ¸›å‚·ï¼Œä½†å¢åŠ ç–²å‹å€¼",
                5: { "Odin": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£ï¼Œé€ æˆæ¯€æ»…æ€§é€£æ“Š", "Loki": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£ï¼Œå°å–®ä¸€ç›®æ¨™é€£çºŒè¡æ’" }
            },
            logBlock: "æ ¼æª”ï¼", logCounter: "çš„åæ“Šåœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼",
            logReflect: "çš„åå°„åœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼", logHit: "çš„æ”»æ“Šï¼",
            playerSuffix: " (æˆ‘)", cpuPrefix: "(CPU) ",
            lockingTargets: "é–å®šç›®æ¨™ï¼",
            waitingOthers: "ç­‰å¾…å…¶ä»–ç©å®¶...",
            roundWinner: "å›åˆå‹åˆ©è€…ï¼š", nextRoundIn: "ç­‰å¾…ç©å®¶é€£ç·šåŒæ­¥ä¸­...",
            currentRound: "ç•¶å‰å±€åˆ†",
            dmgLog: "é€ æˆ {dmg} å‚·å®³ï¼", winSuffix: "å‹"
        },
        'en-US': {
            title: "PIGNAROK", singlePlayer: "Single Player", tutorial: "Tutorial",
            createGameBtn: "Host Game (Online supported)", joinGameBtn: "Join Arena",
            lobbyHint: "(CPU will fill empty slots if < 4 players)",
            createTitle: "Create Game Room", enterName: "Enter your nickname", namePlaceholder: "Name (Max 16 chars)",
            chooseChar: "Choose Your Character", doCreateBtn: "Create Room", backBtn: "Back",
            joinTitle: "Join Network Arena", codePlaceholder: "4-Digit Room Code", doConnectBtn: "Connect",
            lobbyTitle: "Lobby", lobbyShare: "Share Room Code (Max 4 Players)", leaveRoom: "Leave Room",
            waitingHost: "Waiting for host to start...", startGame: "Start Game",
            selectCharTitle: "Select Your Warrior",
            startBattle: "Start Battle",
            back: "Back", backMenu: "Main Menu",
            odinName: "Odin", odinDesc: "Thunder & Glory",
            lokiName: "Loki", lokiDesc: "Tricks & Meat",
            charOdin: "Odin", charLoki: "Loki",
            turnHint: "Select a card below and tap an enemy", ready: "Ready...",
            moveNames: ["Melee", "Magic", "Counter", "Reflect", "Defend", "Ultimate"],
            cardNames: { 0: "Meleeâš”ï¸", 1: "MagicğŸª„", 2: "CountğŸ›¡ï¸", 3: "ReflğŸ’", 4: "DefğŸ§±", 5: "UltğŸ”¥", swap: "MagnetğŸ§²" },
            tutCardNames: { 5: "Phys UltğŸ”¥", 6: "Mag Ultâš¡" },
            victory: "VICTORY!", gameOver: "GAME OVER", restart: "Play Again", finalVictory: "Congratulations {name}, the New King of Piglympus!", finalMenu: "Main Menu",
            swapSkill: "Magnet Swap", counterSkill: "Counter",
            targetLocked: "(Target Locked)", dead: "Barbecued", fatigue: "Fatigue", rage: "Rage",
            defendFatigue: "Can't Block!", defend: "Defend", tired: "TiredğŸ§±",
            cleanup: "Waiting for battlefield cleanup...",
            cardDescs: {
                0: "Deals Physical DMG, builds Red Rage",
                1: "Deals Magic DMG, builds Blue Rage",
                2: { "Odin": "Counters Physical attacks automatically", "Loki": "Swaps position when hit by Physical attack" },
                3: "Reflects Magic damage back",
                4: "Reduces damage significantly, adds Fatigue",
                5: { "Odin": "Consumes Max Rage for devastating combo", "Loki": "Consumes Max Rage to rush target repeatedly" }
            },
            logBlock: "Blocked", logCounter: "'s counter failed against Ultimate!",
            logReflect: "'s reflect failed against Ultimate!", logHit: "'s attack!",
            playerSuffix: " (Me)", cpuPrefix: "(CPU) ",
            lockingTargets: "Locking Targets!",
            waitingOthers: "Waiting for others...",
            roundWinner: "Round Winner: ", nextRoundIn: "Waiting for player sync...",
            currentRound: "Current Scores",
            dmgLog: "hit for {dmg} damage!", winSuffix: " Wins"
        }
    };

    // --- 3. BASIC HELPERS (Must be first) ---
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function move(obj, target, ms) { return new Promise(res => { const start = obj.position.clone(), t = performance.now(); function up() { let p = Math.min(1, (performance.now() - t) / ms); obj.position.lerpVectors(start, target, p); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    function log(m) { /* Disabled */ }
    
    // Explicitly define safeSetText to avoid null errors
    function safeSetText(id, text) {
        const el = document.getElementById(id);
        if (el) el.innerText = text;
    }

    // Helper to render name presets - SINGLE BUTTON
    function renderNamePresets(containerId, inputId) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';
        
        const btn = document.createElement('button');
        btn.className = 'btn-small';
        btn.style.marginBottom = '15px';
        btn.innerHTML = 'ğŸ² éš¨æ©Ÿç”Ÿæˆåå­—';
        btn.onclick = () => {
            const input = document.getElementById(inputId);
            const randName = PRESET_NAMES[Math.floor(Math.random() * PRESET_NAMES.length)];
            if (input) {
                input.value = randName;
            }
            SoundEngine.init(); 
            SoundEngine.play('click');
        };
        container.appendChild(btn);
    }

    // Explicitly define updateText on window to guarantee access
    window.updateText = function() {
        const t = TRANSLATIONS[currentLang];
        safeSetText('menu-title', t.title);
        safeSetText('btn-create', t.createGameBtn);
        safeSetText('btn-join', t.joinGameBtn);
        safeSetText('lobby-hint', t.lobbyHint);
        
        safeSetText('create-title', t.createTitle);
        safeSetText('create-name-label', t.enterName);
        const hostName = document.getElementById('host-name'); if(hostName) hostName.placeholder = t.namePlaceholder;
        safeSetText('create-char-label', t.chooseChar);
        safeSetText('btn-do-create', t.doCreateBtn);
        safeSetText('btn-create-back', t.backBtn);

        safeSetText('join-title', t.joinTitle);
        const joinName = document.getElementById('join-name'); if(joinName) joinName.placeholder = t.namePlaceholder;
        const joinCode = document.getElementById('join-code'); if(joinCode) joinCode.placeholder = t.codePlaceholder;
        safeSetText('join-char-label', t.chooseChar);
        safeSetText('btn-connect', t.doConnectBtn);
        safeSetText('btn-join-back', t.backBtn);

        safeSetText('lobby-title', t.lobbyTitle);
        safeSetText('lobby-share-hint', t.lobbyShare);
        safeSetText('btn-leave-room', t.leaveRoom);
        safeSetText('client-msg', t.waitingHost);
        
        // Removed char-select-title etc updates since elements are removed

        safeSetText('turn-hint', t.turnHint);
        safeSetText('card-0', t.cardNames[0]);
        safeSetText('card-1', t.cardNames[1]);
        safeSetText('card-3', t.cardNames[3]);
        safeSetText('defend-card', t.cardNames[4]);
        safeSetText('super-card', t.cardNames[5]);
        
        // Set cleanup message
        const cleanupMsg = document.querySelector('#cleanup-msg h1');
        if(cleanupMsg) cleanupMsg.innerText = t.cleanup;
        
        CARD_NAMES = [...t.moveNames]; 

        if (players.length > 0) {
            const p = players[myPlayerIndex]; 
            if(p) {
                const slot2 = document.getElementById('slot-2-btn');
                if (slot2) {
                    if (p.type === 'Loki') {
                        slot2.innerText = t.cardNames.swap; 
                        CARD_NAMES[2] = t.swapSkill;
                    } else {
                        slot2.innerText = t.cardNames[2];
                        CARD_NAMES[2] = t.counterSkill;
                    }
                }
                const defBtn = document.getElementById('defend-card');
                if (defBtn) {
                    if (p.fatigue >= 100) defBtn.innerText = t.tired; else defBtn.innerText = t.cardNames[4];
                }
                players.forEach(pl => pl.refreshLabel());
                safeSetText('player-name-display', p.getDisplayName());
            }
        }
        if (selectedSlot !== -1 && players.length > 0) showCardDescription(selectedSlot);
    };

    window.setLang = function(lang) {
        currentLang = lang;
        document.getElementById('lang-zh').classList.toggle('active', lang === 'zh-TW');
        document.getElementById('lang-en').classList.toggle('active', lang === 'en-US');
        window.updateText();
    };

    const SoundEngine = { ctx: null, init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); }, 
        bgmOscillators: [], isPlayingBGM: false, melodyA: [{n:74,t:0,d:0.25},{n:74,t:0.5,d:0.25},{n:74,t:1,d:0.25},{n:76,t:1.5,d:0.25},{n:77,t:2,d:0.25},{n:76,t:2.5,d:0.25},{n:74,t:3,d:0.25},{n:69,t:3.5,d:0.25},{n:62,t:4,d:0.25},{n:69,t:4.5,d:0.25},{n:74,t:5,d:0.25},{n:77,t:5.5,d:0.25},{n:81,t:6,d:0.25},{n:82,t:6.25,d:0.25},{n:81,t:6.5,d:0.25},{n:77,t:7,d:0.25},{n:74,t:8,d:0.25},{n:74,t:8.5,d:0.25},{n:74,t:9,d:0.25},{n:76,t:9.5,d:0.25},{n:77,t:10,d:0.25},{n:76,t:10.5,d:0.25},{n:74,t:11,d:0.25},{n:69,t:11.5,d:0.25},{n:86,t:12,d:0.25},{n:81,t:13,d:0.25},{n:77,t:14,d:0.25},{n:74,t:15,d:0.5},
        {n:82,t:32,d:1.5},{n:81,t:33.5,d:0.5},{n:77,t:34,d:2},
        {n:84,t:36,d:1.5},{n:82,t:37.5,d:0.5},{n:81,t:38,d:1},{n:86,t:39,d:1}],
        playBGM() { if (this.isPlayingBGM) return; this.init(); this.isPlayingBGM = true; this.scheduleNote(0); },
        stopBGM() { this.isPlayingBGM = false; this.bgmOscillators.forEach(o => { try{o.osc.stop();o.gain.disconnect();}catch(e){} }); this.bgmOscillators=[]; if(this.bgmTimer) clearTimeout(this.bgmTimer); },
        midiToFreq(m){return 440*Math.pow(2,(m-69)/12);},
        scheduleNote(beatIndex){
            if(!this.isPlayingBGM)return;
            const loopLen=64; const curBeat=beatIndex%loopLen; const beatDur=60/155;
            const notes=this.melodyA.filter(n=>Math.abs(n.t-curBeat)<0.01);
            notes.forEach(note=>{
                const osc=this.ctx.createOscillator();const gain=this.ctx.createGain();
                osc.connect(gain);gain.connect(this.ctx.destination);
                osc.type='sawtooth'; osc.frequency.value=this.midiToFreq(note.n);
                const now=this.ctx.currentTime;
                gain.gain.setValueAtTime(0.08,now); gain.gain.exponentialRampToValueAtTime(0.001,now+(note.d*beatDur));
                osc.start(now); osc.stop(now+(note.d*beatDur));
                this.bgmOscillators.push({osc,gain});
            });
            if(beatIndex%1===0) this.play('bonk');
            this.bgmTimer=setTimeout(()=>{this.scheduleNote(beatIndex+0.25);},(beatDur*0.25)*1000);
        },
        play(type) { this.init(); const now = this.ctx.currentTime; const masterGain = this.ctx.createGain(); masterGain.connect(this.ctx.destination); masterGain.gain.setValueAtTime(0.4, now); const osc = this.ctx.createOscillator(); const env = this.ctx.createGain(); osc.connect(env); env.connect(masterGain); let dur = 0.3; switch(type) { case 'click': osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); env.gain.setValueAtTime(0.2, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.1); dur=0.1; break; case 'slash': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(450, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.2); env.gain.setValueAtTime(0.2, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'magic': osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.4); env.gain.setValueAtTime(0.12, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.4); dur=0.4; break; case 'hit': osc.type = 'sine'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now+0.15); env.gain.setValueAtTime(0.4, now); env.gain.linearRampToValueAtTime(0, now+0.15); dur=0.15; break; case 'counter': osc.type = 'square'; osc.frequency.setValueAtTime(1100, now); env.gain.setValueAtTime(0.1, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'super': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(90, now); env.gain.setValueAtTime(0.3, now); env.gain.exponentialRampToValueAtTime(0.001, now+1.2); dur=1.2; break; case 'bonk': osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); env.gain.setValueAtTime(0.8, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.2); dur=0.2; break; case 'ding': osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(2400, now + 0.05); env.gain.setValueAtTime(0.5, now); env.gain.exponentialRampToValueAtTime(0.001, now + 0.3); dur = 0.3; break; } osc.start(now); osc.stop(now+dur); setTimeout(() => { if(osc) osc.disconnect(); if(env) env.disconnect(); if(masterGain) masterGain.disconnect(); }, 2000); } 
    };

    function showMove(text) { const md = document.getElementById('move-display'); if(md) { md.innerText = text; md.style.opacity = "1"; md.classList.add('announce-anim'); } }
    function hideMove() { const md = document.getElementById('move-display'); if(md) { md.style.opacity = "0"; md.classList.remove('announce-anim'); } }

    function spawnDamageNumber(target, amount, colorOverride = null) { 
        if (!target) return; 
        const div = document.createElement('div'); 
        div.className = 'damage-popup'; 
        
        if (typeof amount === 'number') { 
            div.innerText = "-" + amount; 
            div.style.color = colorOverride || "#ff0000"; 
        } else if (typeof amount === 'string' && amount.startsWith("+")) {
             div.innerText = amount;
             div.style.color = colorOverride || "#55ccff";
        } else { 
            div.innerText = amount; 
            div.style.color = colorOverride || "#ffff00"; 
        } 
        
        const pos = target.group.position.clone().add(new THREE.Vector3(0, 40, 0)); 
        const vector = pos.project(camera); 
        const x = (vector.x * .5 + .5) * window.innerWidth; 
        const y = (-(vector.y * .5) + .5) * window.innerHeight; 
        div.style.left = `${x}px`; 
        div.style.top = `${y}px`; 
        div.style.animation = 'damage-pop 0.8s ease-out forwards'; 
        const container = document.getElementById('dmg-container'); 
        if(container) container.appendChild(div); 
        setTimeout(() => { if (div.parentNode) div.parentNode.removeChild(div); }, 800); 
    }

    function resetCamera() { if (camera) { adjustCameraForResponsive(); camera.position.copy(DEFAULT_CAM_POS); camera.lookAt(DEFAULT_LOOK_AT); } }
    
    function adjustCameraForResponsive(snap = false) { 
        if (!camera || !renderer) return; 
        const aspect = window.innerWidth / window.innerHeight; 
        let targetY = BASE_CAM_Y; let targetZ = BASE_CAM_Z; 
        if (aspect > 1.2) { targetY = 240; targetZ = 550; } else if (aspect < 0.6) { targetZ = 850; targetY = 320; } 
        let rotY = 0; if (myPlayerIndex === 1) rotY = Math.PI; else if (myPlayerIndex === 2) rotY = Math.PI/2; else if (myPlayerIndex === 3) rotY = -Math.PI/2;
        const basePos = new THREE.Vector3(0, targetY, targetZ); basePos.applyAxisAngle(new THREE.Vector3(0,1,0), rotY); DEFAULT_CAM_POS.copy(basePos);
        if (snap) { camera.position.copy(DEFAULT_CAM_POS); camera.lookAt(DEFAULT_LOOK_AT); } 
        else if (gameState === 'WAITING' || gameState === 'IDLE') { camera.position.lerp(DEFAULT_CAM_POS, 0.1); camera.lookAt(DEFAULT_LOOK_AT); } 
    }

    function showCardDescription(index) {
        const descEl = document.getElementById('card-description');
        const t = TRANSLATIONS[currentLang];
        const p = players[myPlayerIndex]; 
        let desc = "";
        if (!p) return;
        if (index === 2 || index === 5) desc = t.cardDescs[index][p.type];
        else desc = t.cardDescs[index];
        if (descEl) { descEl.innerText = desc; descEl.style.opacity = 1; }
    }

    function hideCardDescription() { const el = document.getElementById('card-description'); if(el) el.style.opacity = 0; }

    // --- GAME STATE HELPERS ---
    function updateHPUI() {
        const t = TRANSLATIONS[currentLang];
        const p = players[myPlayerIndex]; if (!p) return; 

        if (!isTutorialMode) {
            const hpLine = document.getElementById('hp-line'), fatLine = document.getElementById('fatigue-line');
            const rageLine = document.getElementById('rage-line'), defBtn = document.getElementById('defend-card'), superBtn = document.getElementById('super-card');
            if(hpLine) hpLine.innerText = `HP: ${p.hp}/${p.maxHP}`;
            if(fatLine) { fatLine.innerText = `${t.fatigue}: ${p.fatigue}%`; fatLine.style.color = p.fatigue >= 100 ? "#ff0000" : "#ffaa00"; }
            const curRage = Math.floor(Math.max(p.rage.red, p.rage.blue));
            if(rageLine) { rageLine.innerText = `${t.rage}: ${curRage}%`; rageLine.style.color = p.rage.red > p.rage.blue ? "#ff5555" : (p.rage.blue > p.rage.red ? "#55ccff" : "#ffaa00"); }
            if (defBtn) { if (p.fatigue >= 100) { defBtn.classList.add('disabled'); defBtn.innerText = t.tired; } else { defBtn.classList.remove('disabled'); defBtn.innerText = t.cardNames[4]; } }
            if (superBtn) {
                superBtn.className = "card super"; 
                if (curRage >= 99) {
                    superBtn.style.display = 'flex';
                    if (p.rage.blue > p.rage.red) { superBtn.classList.add('super-blue'); superBtn.innerText = t.cardNames[5]; }
                    else { superBtn.classList.add('super-red'); superBtn.innerText = t.cardNames[5]; }
                } else { superBtn.style.display = 'none'; }
            }
        }
        
        players.forEach(pl => { 
            if (pl.selectionRing) pl.selectionRing.visible = (selectedTargetId === pl.id); 
            if (pl.updateLabel) pl.updateLabel(); 
            if (pl.brokenShieldIcon) { pl.brokenShieldIcon.visible = pl.showBrokenShield; }
        });
        if (window.UI) window.UI.updateScoreboard(); 
    }

    function gainRage(p, isRed, amt) { 
        if (isRed) { p.rage.blue = 0; p.rage.red = Math.min(100, p.rage.red + amt); } 
        else { p.rage.red = 0; p.rage.blue = Math.min(100, p.rage.blue + amt); } 
        if (p.id === 0) { playerRage.red = p.rage.red; playerRage.blue = p.rage.blue; }
        updateHPUI(); if(p.updateLabel) p.updateLabel(); 
    }
    
    function loseRage(p, isRed) { 
        const currentRage = isRed ? p.rage.red : p.rage.blue;
        if (currentRage >= 100) return; 
        if (isRed) p.rage.red = Math.max(0, p.rage.red - 30); 
        else p.rage.blue = Math.max(0, p.rage.blue - 30); 
        if (p.id === 0) { playerRage.red = p.rage.red; playerRage.blue = p.rage.blue; }
    }

    // --- 4. CORE OBJECTS (UI, Network, Online) ---
    window.Online = {
        isHost: false,
        myName: "Player",
        roomCode: "",
        peer: null,
        myPeerId: "",
        connections: [], 
        hostConn: null, 
        playerMap: [], 
        hasActed: false, 
        matchConfig: { targetWins: 2 }
    };

    window.UI = {
        screens: ['main-menu', 'screen-create', 'screen-join', 'screen-lobby', 'game-ui'],
        show(id) {
            this.screens.forEach(s => {
                const el = document.getElementById(s);
                if(el) { el.classList.remove('active'); el.style.display = 'none'; }
            });
            const t = document.getElementById(id);
            if(t) { 
                t.style.display = 'flex'; 
                setTimeout(()=>t.classList.add('active'), 10); 
                if(id === 'game-ui') t.style.display = 'block'; 
            }
        },
        showMenu() { this.show('main-menu'); },
        showCreate() { 
            selectedPlayerType = 'Odin';
            document.getElementById('mini-host-odin').className = "mini-card active";
            document.getElementById('mini-host-loki').className = "mini-card";
            renderNamePresets('host-presets', 'host-name'); // Render Presets
            this.show('screen-create'); 
        },
        showJoin() { 
            selectedPlayerType = 'Odin';
            document.getElementById('mini-join-odin').className = "mini-card active";
            document.getElementById('mini-join-loki').className = "mini-card";
            document.getElementById('join-status').innerText = "";
            document.getElementById('btn-connect').disabled = false;
            renderNamePresets('join-presets', 'join-name'); // Render Presets
            this.show('screen-join'); 
        },
        updateLobby(roomCode, playersList) {
            this.show('screen-lobby');
            document.getElementById('lobby-code').innerText = roomCode;
            const list = document.getElementById('lobby-list');
            list.innerHTML = "";
            playersList.forEach(p => {
                const li = document.createElement('li');
                let html = `<span>${p.name} <small style="color:#aaa">(${p.type})</small></span> <div>`;
                if (p.isHost) html += `<span class="tag-host">HOST</span> `;
                if (p.peerId === window.Online.myPeerId) html += `<span class="tag-me">YOU</span>`;
                html += `</div>`;
                li.innerHTML = html;
                list.appendChild(li);
            });
            if (window.Online.isHost) {
                document.getElementById('host-controls').style.display = 'block';
                document.getElementById('client-msg').style.display = 'none';
                document.getElementById('btn-start-net').disabled = false; 
            } else {
                document.getElementById('host-controls').style.display = 'none';
                document.getElementById('client-msg').style.display = 'block';
            }
        },
        updateScoreboard() {
            const sb = document.getElementById('scoreboard');
            sb.innerHTML = `<h3 style="margin:0 0 10px 0; color:#ff99cc; border-bottom:1px solid #555;">${TRANSLATIONS[currentLang].currentRound}</h3>`;
            players.forEach(p => {
                const wins = matchScores[p.id] || 0;
                const crowns = "ğŸ‘‘".repeat(wins);
                const row = document.createElement('div');
                row.className = 'score-row';
                row.innerHTML = `${p.getDisplayName()} <span class="score-num">${crowns}</span>`;
                sb.appendChild(row);
            });
        }
    };

    window.selectMiniChar = function(type) {
        selectedPlayerType = type;
        SoundEngine.init(); 
        SoundEngine.play('click');
        const setUI = (prefix) => {
            const el1 = document.getElementById(prefix + '-odin');
            const el2 = document.getElementById(prefix + '-loki');
            if (el1) el1.className = type === 'Odin' ? "mini-card active" : "mini-card";
            if (el2) el2.className = type === 'Loki' ? "mini-card active" : "mini-card";
        };
        setUI('mini-host');
        setUI('mini-join');
    };

    window.Network = {
        createGame() {
            const name = document.getElementById('host-name').value.trim();
            const format = document.getElementById('match-format').value;
            if(!name) return alert(TRANSLATIONS[currentLang].incomplete);
            window.Online.isHost = true;
            window.Online.myName = name;
            window.Online.roomCode = Math.floor(1000 + Math.random() * 9000).toString();
            window.Online.matchConfig.targetWins = parseInt(format) || 2;
            targetWins = window.Online.matchConfig.targetWins;
            
            window.Online.peer = new Peer(APP_ID_PREFIX + window.Online.roomCode);
            window.Online.peer.on('open', (id) => {
                window.Online.myPeerId = id;
                window.Online.playerMap = [{ name: window.Online.myName, isHost: true, peerId: id, isCpu: false, type: selectedPlayerType }];
                window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap);
            });
            window.Online.peer.on('error', (err) => { alert(TRANSLATIONS[currentLang].connError); location.reload(); });
            window.Online.peer.on('connection', (conn) => {
                if(window.Online.playerMap.length >= 4) {
                    conn.on('open', () => { conn.send({type:'ERROR', msg:'Full'}); setTimeout(()=>conn.close(), 500); });
                    return;
                }
                window.Online.connections.push(conn);
                conn.on('data', (data) => window.Network.handleHostData(conn, data));
                
                conn.on('close', () => {
                    const pIdx = window.Online.playerMap.findIndex(x => x.peerId === conn.peer);
                    if (pIdx !== -1) {
                        const p = window.Online.playerMap[pIdx];
                        if (gameState === 'IDLE') {
                            window.Online.playerMap.splice(pIdx, 1);
                            window.Online.connections = window.Online.connections.filter(c => c !== conn);
                            window.Network.broadcast({type: 'LOBBY_UPDATE', players: window.Online.playerMap});
                            window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap);
                        } else {
                            p.isCpu = true;
                            p.name += " (CPU)";
                            window.Network.broadcast({type: 'LOBBY_UPDATE', players: window.Online.playerMap});
                            log(`${p.name} disconnected, AI takeover`);
                        }
                    }
                });
            });
        },
        joinGame() {
            const name = document.getElementById('join-name').value.trim();
            const code = document.getElementById('join-code').value.trim();
            if(!name || code.length!==4) return alert(TRANSLATIONS[currentLang].incomplete);
            
            window.Online.isHost = false;
            window.Online.myName = name;
            window.Online.roomCode = code;
            const btn = document.getElementById('btn-connect');
            btn.disabled = true; btn.innerText = "...";
            SoundEngine.playBGM(); // Client plays BGM on connect
            
            window.Online.peer = new Peer();
            
            window.Online.peer.on('open', (id) => {
                window.Online.myPeerId = id;
                const conn = window.Online.peer.connect(APP_ID_PREFIX + code);
                conn.on('open', () => {
                    window.Online.hostConn = conn;
                    conn.send({type: 'JOIN_REQUEST', name: name, characterType: selectedPlayerType});
                });
                conn.on('data', (data) => window.Network.handleClientData(data));
                conn.on('close', () => { alert(TRANSLATIONS[currentLang].hostLeft); location.reload(); });
                conn.on('error', (err) => console.log(err));
            });
            window.Online.peer.on('error', (err) => { alert(TRANSLATIONS[currentLang].connError); location.reload(); });
        },
        handleHostData(conn, data) {
            if(data.type === 'JOIN_REQUEST') {
                const pType = data.characterType || 'Odin';
                const newP = { name: data.name, isHost: false, peerId: conn.peer, isCpu: false, type: pType };
                window.Online.playerMap.push(newP);
                window.Network.broadcast({type: 'LOBBY_UPDATE', players: window.Online.playerMap});
            } else if (data.type === 'ACTION_SUBMIT') {
                const senderIdx = window.Online.playerMap.findIndex(p => p.peerId === conn.peer);
                if(senderIdx !== -1 && players[senderIdx]) {
                    players[senderIdx].action = data.action;
                }
            }
        },
        handleClientData(data) {
            if(data.type === 'LOBBY_UPDATE') {
                window.Online.playerMap = data.players;
                window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap);
            } else if (data.type === 'GAME_START') {
                myPlayerIndex = data.myIndex;
                isMultiplayer = true;
                if (data.scores) matchScores = data.scores;
                if (data.targetWins) targetWins = data.targetWins;
                window.startBattle(data.configs); 
            } else if (data.type === 'TURN_START') {
                startTurn(); 
            } else if (data.type === 'TURN_RESOLVE') {
                data.actions.forEach((act, idx) => {
                    if(players[idx]) players[idx].action = act;
                });
                resolveActions();
            } else if (data.type === 'GAME_OVER') {
                if (data.isFinal) {
                    showMsg(data.msg, true);
                } else if (data.autoRestart) {
                    if (data.scores) {
                        matchScores = data.scores;
                        players.forEach(p => p.refreshLabel());
                    }
                    startRoundTransition(data.winnerName);
                } else {
                    showMsg(data.msg, false);
                }
            }
        },
        broadcast(msg) {
            window.Online.connections.forEach(c => { if(c.open) c.send(msg); });
            if(msg.type === 'LOBBY_UPDATE') window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap);
        },
        sendHost(msg) {
            if(window.Online.hostConn && window.Online.hostConn.open) window.Online.hostConn.send(msg);
        },
        hostStartGame() {
            while(window.Online.playerMap.length < 4) {
                const isLoki = Math.random() > 0.5;
                window.Online.playerMap.push({ 
                    name: `BOT-${window.Online.playerMap.length}`, 
                    isHost: false, 
                    peerId: 'cpu-'+Math.random(), 
                    isCpu: true,
                    type: isLoki ? 'Loki' : 'Odin' 
                });
            }
            
            const configs = [
                { id: 0, x: 0, y: 50, z: 140, name: window.Online.playerMap[0].name, type: window.Online.playerMap[0].type }, 
                { id: 1, x: 0, y: 50, z: -140, name: window.Online.playerMap[1].name, type: window.Online.playerMap[1].type },
                { id: 2, x: 140, y: 50, z: 0, name: window.Online.playerMap[2].name, type: window.Online.playerMap[2].type },
                { id: 3, x: -140, y: 50, z: 0, name: window.Online.playerMap[3].name, type: window.Online.playerMap[3].type }
            ];

            if (Object.keys(matchScores).length === 0 || gameState === 'IDLE') {
                matchScores = {};
                configs.forEach(p => matchScores[p.id] = 0);
            }

            window.Online.playerMap.forEach((p, idx) => {
                if(p.isHost) {
                    myPlayerIndex = 0;
                    isMultiplayer = true;
                    window.startBattle(configs);
                } else if (!p.isCpu) {
                    const conn = window.Online.connections.find(c => c.peer === p.peerId);
                    if(conn) conn.send({ type: 'GAME_START', configs: configs, myIndex: idx, scores: matchScores, targetWins: targetWins });
                }
            });
        }
    };

    // --- 6. CLASS DEFINITIONS ---
    class HitParticle { constructor(pos, color) { const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true }); this.mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), mat); this.mesh.position.copy(pos); const a = Math.random() * Math.PI * 2, s = 5 + Math.random() * 5; this.velocity = new THREE.Vector3(Math.cos(a) * s, 4 + Math.random() * 6, Math.sin(a) * s); this.life = 1.0; scene.add(this.mesh); } update(dt) { this.mesh.position.add(this.velocity.clone().multiplyScalar(dt)); this.velocity.y -= 15 * dt; this.life -= dt * 1.5; this.mesh.material.opacity = this.life; if (this.life <= 0) { if(this.mesh.parent) scene.remove(this.mesh); if(this.mesh.material) this.mesh.material.dispose(); return false; } return true; } }
    class OptimizedLightningBolt { constructor(s, e, c=0x00ffff) { this.s=s.clone(); this.e=e.clone(); this.c=c; this.l=6; this.g=new THREE.Group(); scene.add(this.g); this.m=new THREE.MeshBasicMaterial({color:c,transparent:true}); this.gen(); } gen() { while(this.g.children.length>0){this.g.remove(this.g.children[0]);} const pts=[]; for(let i=0;i<=8;i++){ let p=new THREE.Vector3().lerpVectors(this.s,this.e,i/8); if(i>0&&i<8){ p.addScalar((Math.random()-0.5)*20); } pts.push(p); } for(let i=0;i<pts.length-1;i++){ const d=pts[i].distanceTo(pts[i+1]); const m=new THREE.Mesh(new THREE.BoxGeometry(3.6,3.6,d),this.m); m.position.lerpVectors(pts[i],pts[i+1],0.5); m.lookAt(pts[i+1]); this.g.add(m); } this.m.color.setHex(Math.random()>0.4?0xffffff:this.c); } update() { this.l--; if(this.l>0){this.gen();return true;} else{scene.remove(this.g); return false;} } }
    class SuperAura { constructor(p) { this.active=false; this.g=new THREE.Group(); this.g.position.y=2.5; p.add(this.g); this.core=new THREE.Mesh(new THREE.IcosahedronGeometry(3,1),new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.3,blending:2})); this.g.add(this.core); this.spikes=new THREE.Mesh(new THREE.IcosahedronGeometry(3.5,0),new THREE.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.4,blending:2})); this.g.add(this.spikes); this.g.visible=false; this.t=0; } activate(r) { this.active=true; this.g.visible=true; const c=r?0xff3300:0x0088ff; this.spikes.material.color.setHex(c); this.core.material.color.setHex(r?0xffffaa:0xaaffff); } deactivate() { this.active=false; this.g.visible=false; } update(dt) { if(!this.active)return; this.t+=dt*15; const s=1+Math.sin(this.t)*0.05; this.spikes.scale.set(s,s,s); this.spikes.rotation.y+=dt*3; } }
    class MeatDrop { constructor(t,s=1, isSuper=false){this.m=createMeatModelShared(s);this.m.position.set(t.x,t.y+400,t.z);this.ty=t.y;this.v=0;this.e=false;this.isSuper=isSuper;scene.add(this.m);} update(dt){if(this.e)return false;this.v+=900*dt;this.m.position.y-=this.v*dt;this.m.rotation.y+=dt*5;if(this.m.position.y<=this.ty){this.m.position.y=this.ty;this.expl();return false;}return true;} expl(){if(this.e)return;this.e=true;const scale=this.isSuper?3.0:1.0;createExplosion(this.m.position,scale);if(this.m.parent)scene.remove(this.m);} }
    class ParabolicMeatProjectile { constructor(s,e){this.s=s.clone();this.e=e.clone();this.m=createMeatModelShared(7.0);scene.add(this.m);this.p=0;} update(dt){if(this.p>=1){if(this.m.parent)scene.remove(this.m);createExplosion(this.m.position, 3.0); return false;}this.p+=dt/0.8;const c=new THREE.Vector3().lerpVectors(this.s,this.e,this.p);c.y+=Math.sin(this.p*Math.PI)*150;this.m.position.copy(c);this.m.rotation.x+=dt*10;return true;} }
    
    // --- 7. FIREWORKS SYSTEM (REMOVED) ---
    // Removed Fireworks object and logic as requested

    // --- 8. HELPER FUNCTIONS FOR 3D (MOVED DOWN) ---
    function createUnitUISprite() { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 256; const texture = new THREE.CanvasTexture(canvas); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false })); sprite.scale.set(12, 6, 1); sprite.renderOrder = 999; return { sprite, canvas, ctx, texture }; }
    function createBrokenShieldTexture() { 
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; 
        const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.moveTo(30, 30); ctx.lineTo(226, 30); ctx.quadraticCurveTo(226, 150, 128, 240); ctx.quadraticCurveTo(30, 150, 30, 30); ctx.closePath(); ctx.fill(); 
        
        ctx.font = 'bold 36px "Microsoft JhengHei", sans-serif'; ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
        
        // Dynamic Text based on language
        if (currentLang === 'zh-TW') {
            ctx.fillText('é˜²ç¦¦', 128, 110); ctx.fillText('ç–²å‹ä¸­', 128, 150); 
        } else {
            ctx.font = 'bold 30px Arial';
            ctx.fillText('Can\'t', 128, 110); ctx.fillText('Block!', 128, 150); 
        }
        return new THREE.CanvasTexture(canvas); 
    }
    function createTextSprite(text) { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 128; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(20, 20, 472, 88); ctx.font = 'bold 50px "Microsoft JhengHei", Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#ff99cc'; ctx.fillText(text, 256, 85); const texture = new THREE.CanvasTexture(canvas); const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false }); return new THREE.Sprite(mat); }
    function createShockwave(pos, color) { const m = new THREE.Mesh(new THREE.RingGeometry(1, 2, 64), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1, side: THREE.DoubleSide })); m.position.copy(pos); m.rotation.x = Math.PI / 2; const expand = () => { m.scale.x += 4; m.scale.y += 4; m.material.opacity -= 0.05; if(m.material.opacity > 0) requestAnimationFrame(expand); else if(m.parent) scene.remove(m); }; expand(); return m; }
    function createExplosion(pos, scale=1.0) { const g = new THREE.Group(); const shock = createShockwave(pos, 0xffaa00); g.add(shock); g.position.copy(pos); shock.position.set(0,0,0); const count = Math.floor(40 * scale); for(let i=0; i<count; i++) { activeParticles.push(new HitParticle(pos.clone(), i % 2 === 0 ? 0xff4400 : 0xffff00)); } g.scale.set(scale, scale, scale); SoundEngine.play('super'); scene.add(g); return g; }
    function applyKnockback(char, sourcePos) { if(!sourcePos) return; const dir = char.group.position.clone().sub(sourcePos).normalize(); dir.y = 0; const originalPos = char.group.position.clone(); const backPos = originalPos.clone().add(dir.multiplyScalar(25)); move(char.group, backPos, 100).then(() => { sleep(50).then(() => move(char.group, originalPos, 200)); }); }
    function createMagnetModel() { const group = new THREE.Group(); const redMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }), blueMat = new THREE.MeshPhongMaterial({ color: 0x0000ff }), silverMat = new THREE.MeshPhongMaterial({ color: 0xcccccc }); const bar1 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), redMat); bar1.position.set(-3, 3, 0); group.add(bar1); const bar2 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), blueMat); bar2.position.set(3, 3, 0); group.add(bar2); const connector = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 2), silverMat); connector.position.set(0, 0, 0); group.add(connector); group.scale.set(2,2,2); return group; }
    function createMeatModelShared(scale = 1) { const g = new THREE.Group(); const meat = new THREE.Mesh(new THREE.BoxGeometry(3.5 * scale, 2.5 * scale, 2.5 * scale), new THREE.MeshPhongMaterial({ color: 0xaa2222 })); meat.position.y = 1 * scale; meat.castShadow = true; g.add(meat); const bone = new THREE.Mesh(new THREE.BoxGeometry(6 * scale, 0.6 * scale, 0.6 * scale), new THREE.MeshPhongMaterial({ color: 0xeeeeee })); bone.position.y = 1 * scale; bone.castShadow = true; g.add(bone); const cutMat = new THREE.MeshBasicMaterial({ color: 0xffaaaa }); const cL = new THREE.Mesh(new THREE.PlaneGeometry(2.3 * scale, 2.3 * scale), cutMat), cR = cL.clone(); cL.position.set(-1.76 * scale, 1 * scale, 0); cL.rotation.y = Math.PI/2; cR.position.set(1.76 * scale, 1 * scale, 0); cR.rotation.y = Math.PI/2; g.add(cL, cR); return g; }
    function getRandomTarget(sid) { const os = players.filter(p => p.id !== sid && p.alive); return os.length ? os[Math.floor(Math.random()*os.length)].id : -1; }
    
    // MISSING FUNCTIONS FROM CLASS ODIN -- ADDED HERE
    function createStarGeometry() { const s = new THREE.Shape(); const o=5.5, n=2.8; for(let i=0; i<12; i++){ const a=(i/12)*Math.PI*2, r=(i%2===0)?o:n; if(i===0) s.moveTo(Math.cos(a)*r, Math.sin(a)*r); else s.lineTo(Math.cos(a)*r, Math.sin(a)*r); } s.closePath(); return new THREE.ShapeGeometry(s); }
    function createRuneLine() { const pts = [new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0.5, 0, 0), new THREE.Vector3(0, 0.5, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffffff })); }
    function createAlgizRune() { const pts = [new THREE.Vector3(0, -0.8, 0), new THREE.Vector3(0, 0.8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-0.6, 0.6, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0.6, 0.6, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })); }
    function createReticleTexture() { const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d'); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 8; ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000'; ctx.beginPath(); ctx.setLineDash([30, 15]); ctx.arc(128, 128, 110, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(128, 40); ctx.lineTo(128, 10); ctx.moveTo(128, 216); ctx.lineTo(128, 246); ctx.moveTo(40, 128); ctx.lineTo(10, 128); ctx.moveTo(216, 128); ctx.lineTo(246, 128); ctx.stroke(); ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(128, 128, 8, 0, Math.PI * 2); ctx.fill(); return new THREE.CanvasTexture(canvas); }

    class Odin {
        constructor(cfg) {
            this.id = cfg.id; this.name = cfg.name; this.type = cfg.type || 'Odin';
            this.maxHP = (this.type === 'Loki' ? MAX_HP_LOKI : MAX_HP_ODIN);
            this.hp = this.maxHP; this.alive = true; this.rage = { red: 0, blue: 0 }; 
            this.fatigue = 0; this.defendHitCount = 0; this.showBrokenShield = false; 
            this.action = { card: -1, target: -1, selectionTime: 0 }; this.targetQuaternion = null;
            this.group = new THREE.Group(); this.group.position.set(cfg.x, cfg.y, cfg.z);
            this.group.userData = { isCharacter: true, playerId: cfg.id }; this.group.scale.set(8, 8, 8);
            this.aura = new SuperAura(this.group); this.ballRotationMultiplier = 1.0; 

            // FIX: depthWrite: false, colorWrite: false
            const hitGeo = new THREE.BoxGeometry(4, 7, 4); // SHRUNK HITBOX 
            const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false, colorWrite: false }); 
            this.hitBox = new THREE.Mesh(hitGeo, hitMat); this.hitBox.position.y = 3.5; this.group.add(this.hitBox);
            
            const uiData = createUnitUISprite(); this.uiSprite = uiData.sprite; this.uiCtx = uiData.ctx; this.uiTexture = uiData.texture;
            this.uiSprite.position.y = 8.5; 
            this.group.add(this.uiSprite); // Always add, visibility controlled in updateLabel
            
            // --- NEW: UI SPECIFIC HITBOX ---
            const uiHitGeo = new THREE.BoxGeometry(18, 30, 18); // Size matches UI sprite area
            const uiHitBox = new THREE.Mesh(uiHitGeo, hitMat);
            uiHitBox.position.set(0, 8, 0); 
            // Only add UI hitbox for others
            if (this.id !== myPlayerIndex) {
                 this.group.add(uiHitBox);
            }
            
            const shieldTex = createBrokenShieldTexture(); const shieldMat = new THREE.SpriteMaterial({ map: shieldTex, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false });
            this.brokenShieldIcon = new THREE.Sprite(shieldMat); this.brokenShieldIcon.scale.set(8, 8, 1); this.brokenShieldIcon.position.set(0, 14, 0); 
            this.brokenShieldIcon.renderOrder = 998; this.brokenShieldIcon.visible = false; 
            this.group.add(this.brokenShieldIcon); 
            
            this.labelSprite = createTextSprite(this.getDisplayName()); this.labelSprite.position.y = -3.5; this.labelSprite.scale.set(10, 2.5, 1);
            this.labelSprite.renderOrder = 999;
            // FIX: Only add label sprite for other players
            if (this.id !== myPlayerIndex) {
                this.group.add(this.labelSprite);
            }
            
            this.modelContainer = new THREE.Group(); this.group.add(this.modelContainer);
            
            const bodyColor = (this.type === 'Loki' ? 0x0a4a0a : 0xffcc00);
            this.body = new THREE.Mesh(new THREE.BoxGeometry(2.1, 2, 2.5), new THREE.MeshPhongMaterial({ color: bodyColor }));
            this.body.position.y = 1; this.body.castShadow = true; this.modelContainer.add(this.body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.8, 1.6), new THREE.MeshPhongMaterial({ color: 0xffdbac }));
            head.position.set(0, 2.5, 0.5); head.castShadow = true; this.modelContainer.add(head);
            this.snout = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.6), new THREE.MeshPhongMaterial({ color: 0xffaaaa }));
            this.snout.position.set(0, 2.3, 1.35); this.snout.castShadow = true; this.modelContainer.add(this.snout);
            const nL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), new THREE.MeshBasicMaterial({color:0x000000})), nR = nL.clone();
            nL.position.set(-0.25, 0.1, 0.35); nR.position.set(0.25, 0.1, 0.35); this.snout.add(nL, nR);
            const earL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.2), new THREE.MeshPhongMaterial({color: 0xffaaaa})), earR = earL.clone();
            earL.position.set(-1.0, 3.2, 0.5); earL.rotation.z = 0.6; earR.position.set(1.0, 3.2, 0.5); earR.rotation.z = -0.6;
            earL.castShadow = true; earR.castShadow = true; this.modelContainer.add(earL, earR);

            if (this.type === 'Loki') {
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d'); const cols = ['#ff3333', '#33ff33', '#ffffff', '#3333ff']; 
                for(let i=0; i<4; i++) for(let j=0; j<4; j++) { ctx.fillStyle = cols[(i + j) % 4]; ctx.fillRect(i * 64, j * 64, 64, 64); ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(i * 64, j * 64, 64, 64); }
                const ballTex = new THREE.CanvasTexture(canvas); ballTex.wrapS = ballTex.wrapT = THREE.RepeatWrapping; ballTex.repeat.set(2, 2);
                this.ball = new THREE.Mesh(new THREE.SphereGeometry(1.4, 16, 12), new THREE.MeshPhongMaterial({ map: ballTex }));
                this.ball.position.y = -0.4; this.ball.castShadow = true; this.modelContainer.add(this.ball);
                this.modelContainer.position.y = 1.4;
            }

            this.weaponGroup = new THREE.Group();
            if (this.type === 'Odin') {
                const shape = new THREE.Shape();
                shape.moveTo(0, 0); shape.lineTo(0.5, 2); shape.lineTo(-0.2, 1.8); shape.lineTo(0.4, 3.5);
                shape.lineTo(-0.3, 3.2); shape.lineTo(0.6, 6); shape.lineTo(-0.1, 3.8); shape.lineTo(0.5, 4.2);
                shape.lineTo(-0.1, 2.2); shape.lineTo(0.4, 2.5); shape.lineTo(0, 0);
                this.weaponMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.3, bevelEnabled: false }), new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffd700, emissiveIntensity: 2 }));
                this.weaponMesh.position.set(-0.2, -1, 0); this.weaponMesh.castShadow = true; this.weaponGroup.add(this.weaponMesh); 
            }
            this.weaponGroup.position.set(1.5, 1.2, 0.5); this.weaponGroup.rotation.x = -Math.PI/4; this.modelContainer.add(this.weaponGroup);
            
            this.hexShield = new THREE.Group();
            const hexColor = (this.type === 'Loki' ? 0xff0000 : 0x00ffff);
            const hexStar = new THREE.Mesh(createStarGeometry(), new THREE.MeshBasicMaterial({ color: hexColor, transparent: true, opacity: 0.6, side: THREE.DoubleSide }));
            this.hexShield.add(hexStar); 
            for (let i = 0; i < 6; i++) {
                const rune = createRuneLine(), angle = (i / 6) * Math.PI * 2;
                rune.position.set(Math.cos(angle) * 3.5, Math.sin(angle) * 3.5, 0.1); rune.rotation.z = angle; this.hexShield.add(rune);
            }
            const centralRune = createAlgizRune(); centralRune.scale.set(2, 2, 2); this.hexShield.add(centralRune);
            this.hexShield.position.set(0, 3, 3); this.hexShield.visible = false; this.group.add(this.hexShield);
            
            this.meatBlock = createMeatModelShared(); this.meatBlock.visible = false; this.group.add(this.meatBlock);
            
            this.selectionSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: createReticleTexture(), transparent: true, depthTest: false, depthWrite: false }));
            this.selectionSprite.scale.set(10, 10, 1); 
            this.selectionSprite.position.set(0, 3.0, 0); // Head height
            this.selectionSprite.visible = false;
            this.group.add(this.selectionSprite);
            
            this.targetLabel = createTextSprite(TRANSLATIONS[currentLang].targetLocked); this.targetLabel.scale.set(6, 1.5, 1); this.targetLabel.position.y = -6; this.targetLabel.visible = false; this.group.add(this.targetLabel);
            
            scene.add(this.group); this.face(new THREE.Vector3(0,cfg.y,0)); this.updateLabel();
        }

        getDisplayName() {
             const t = TRANSLATIONS[currentLang];
             let baseName = this.name;
             if (this.name.startsWith("BOT-")) baseName = `CPU${this.id}`;
             const wins = matchScores[this.id] || 0;
             return wins > 0 ? `${baseName} ${"ğŸ‘‘".repeat(wins)}` : baseName;
        }
        refreshLabel() { if(this.labelSprite) { this.labelSprite.material.map.dispose(); this.labelSprite.material.map = createTextSprite(this.getDisplayName()).material.map; } if(this.brokenShieldIcon) { this.brokenShieldIcon.material.map.dispose(); this.brokenShieldIcon.material.map = createBrokenShieldTexture(); } if(this.targetLabel) { this.targetLabel.material.map.dispose(); this.targetLabel.material.map = createTextSprite(TRANSLATIONS[currentLang].targetLocked).material.map; } }
        updateLabel() { 
            if (!this.uiCtx) return; 
            const ctx = this.uiCtx; 
            ctx.clearRect(0, 0, 512, 256); 
            const t = TRANSLATIONS[currentLang]; 
            
            if (!this.alive) { 
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; 
                ctx.fillRect(50, 40, 412, 160); 
                ctx.font = 'bold 80px Arial'; 
                ctx.textAlign = 'center'; 
                ctx.fillStyle = '#ff99cc'; 
                ctx.fillText(t.dead, 256, 150); 
                this.uiTexture.needsUpdate = true; 
                return; 
            } 
            const r = this.rage, u = Math.floor(Math.max(r.red, r.blue)); 
            
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; 
            if (this.id === myPlayerIndex) {
                 ctx.fillRect(50, 100, 412, 70); // Smaller bg for bars only
            } else {
                 ctx.fillRect(50, 40, 412, 160); // Full bg
            }

            // Text (Only for others)
            if (this.id !== myPlayerIndex) {
                ctx.font = 'bold 36px Arial'; 
                ctx.textAlign = 'center'; 
                ctx.fillStyle = 'white'; 
                ctx.fillText(`HP: ${this.hp}/${this.maxHP}  ${t.rage}: ${u}%`, 256, 85); 
            }
            
            // HP Bar
            ctx.fillStyle = '#1a1a1a'; 
            ctx.fillRect(80, 110, 352, 20); 
            ctx.fillStyle = '#2ecc71'; 
            ctx.fillRect(80, 110, 352 * (this.hp/this.maxHP), 20); 
            
            // Rage Bar
            ctx.fillStyle = '#1a1a1a'; 
            ctx.fillRect(80, 145, 352, 15); 
            ctx.fillStyle = (r.red > r.blue) ? '#ff5555' : (r.blue > r.red ? '#55ccff' : '#ffaa00'); 
            ctx.fillRect(80, 145, 352 * (u/100), 15); 
            
            this.uiTexture.needsUpdate = true; 
        }
        face(pos) { if (!this.alive) return; const lp = pos.clone(); lp.y = this.group.position.y; const dummy = new THREE.Object3D(); dummy.position.copy(this.group.position); dummy.lookAt(lp); this.targetQuaternion = dummy.quaternion.clone(); }
        takeDamage(amt, type = 0, sourcePos = null) { 
            this.hp = Math.max(0, this.hp - Math.floor(amt)); 
            SoundEngine.play('hit'); 
            const pColor = (type === 0) ? 0xffaa00 : (type === 1 ? 0x00ffff : 0xff0044); 
            for(let i=0; i<15; i++) activeParticles.push(new HitParticle(this.group.position.clone().add(new THREE.Vector3(0, 10, 0)), pColor)); 
            if (sourcePos) applyKnockback(this, sourcePos); 
            if (this.hp <= 0 && this.alive) { 
                this.alive = false; 
                this.modelContainer.visible = false; 
                this.meatBlock.visible = true; 
                this.aura.deactivate(); // FIX: Remove rage aura on death
            } 
            this.updateLabel(); updateHPUI(); 
        }
    }

    // --- GAME LOGIC ---
    function calcDamage(a, t, type, isSuper = false, skipFatigue = false) { 
        if (!t || !t.alive) return; 
        const txt = TRANSLATIONS[currentLang]; 
        // Modified Damages based on CSV
        let dmg = 0;
        if (a.type === 'Loki') {
             // Loki Dmg
             if (isSuper) {
                 dmg = (type === 0) ? 70 : (t.maxHP * 0.5); // Phys Ult 70 per hit, Mag Ult 50%
             } else {
                 dmg = (type === 0) ? 60 : 100; // Phys 60, Mag 100
             }
        } else {
             // Odin Dmg
             if (isSuper) {
                 dmg = (type === 0) ? 60 : (t.maxHP * 0.5); // Phys Ult 60 per hit, Mag Ult 50%
             } else {
                 dmg = (type === 0) ? 80 : 90; // Phys 80, Mag 90
             }
        }

        if (isSuper) createExplosion(t.group.position.clone().add(new THREE.Vector3(0, 15, 0)), 2.5); 
        else { 
            if (type === 0 && t.action.card === 2) { 
                if (t.type === 'Loki') return; 
                loseRage(a, true); 
                let counterDmg = 80; // Counter Dmg 80
                a.takeDamage(counterDmg, 0, t.group.position); 
                spawnDamageNumber(a, counterDmg); showMove(`[${t.getDisplayName()}] åæ“Šï¼ -> ${a.getDisplayName()} ${counterDmg} Dmg!`);
                if (t.type === 'Odin') gainRage(t, true, 20); return; 
            } 
            if (type === 1 && t.action.card === 3) { 
                loseRage(a, false); let reflectDmg = Math.floor(dmg*0.8); a.takeDamage(reflectDmg, 2, t.group.position); 
                spawnDamageNumber(a, reflectDmg); showMove(`[${t.getDisplayName()}] åå°„ï¼ -> ${a.getDisplayName()} ${reflectDmg} Dmg!`);
                gainRage(t, false, 20); return; 
            } 
        } 
        if (t.action.card === 4) { 
            if (!skipFatigue) { 
                t.defendHitCount++; let fatigueAdd = 0; 
                if (t.defendHitCount === 2) fatigueAdd = 20; else if (t.defendHitCount > 2) fatigueAdd = 10; 
                if (isSuper) fatigueAdd += 15; if (fatigueAdd > 0) t.fatigue = Math.min(150, t.fatigue + fatigueAdd); 
            } 
            // ä¿®æ­£æ ¼æ“‹é¡¯ç¤ºé‚è¼¯ï¼šå…ˆè·³é»ƒå­—ï¼Œå†è·³ç´…å­—å‚·å®³
            t.blockedInTurn = true; 
            SoundEngine.play('ding'); 
            spawnDamageNumber(t, txt.logBlock, "#ffff00"); // Yellow BLOCK text
            
            // å‚·å®³æ¸›å…è¨ˆç®— (75% reduction -> take 25% dmg)
            let reducedDmg = Math.floor(dmg * 0.25);
            // Apply reduced damage
            loseRage(t, type === 0); 
            t.takeDamage(reducedDmg, type, a.group.position);
            // Show red damage number slightly delayed or offset
            setTimeout(() => spawnDamageNumber(t, reducedDmg), 200);

            showMove(`[${t.getDisplayName()}] ${txt.logBlock}!`); updateHPUI(); return; 
        } 
        loseRage(t, type === 0); t.takeDamage(dmg, type, a.group.position); spawnDamageNumber(t, dmg);
        let skillName = isSuper ? "å¥§ç¾©" : (type === 0 ? "ç‰©ç†æ”»æ“Š" : "é­”æ³•æ”»æ“Š");
        showMove(`${a.getDisplayName()} å° ${t.getDisplayName()} ä½¿ç”¨ ${skillName}, é€ æˆ ${dmg} å‚·å®³!`);
        if (!isSuper) gainRage(a, type === 0, 35); 
    }

    async function focusOnAction(char1, char2 = null, dur = 600) { 
        if (!char1) return; 
        let tCenter, camTarget; 
        if (char2) { 
            const p1 = char1.group.position.clone(), p2 = char2.group.position.clone(); 
            const d = p1.distanceTo(p2); 
            tCenter = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5); 
            const zoomFactor = (window.innerWidth / window.innerHeight) > 1 ? 0.5 : 0.4; 
            camTarget = tCenter.clone().add(new THREE.Vector3(0, 180 + d * zoomFactor, 250 + d * 0.6)); 
        } else { 
            tCenter = char1.group.position.clone(); 
            camTarget = tCenter.clone().add(new THREE.Vector3(0, 200, 300));
        } 
        return new Promise(res => { 
            let sPos = camera.position.clone(); 
            let start = performance.now(); 
            function up() { 
                let p = Math.min(1, (performance.now() - start) / dur); 
                camera.position.lerpVectors(sPos, camTarget, p); 
                camera.lookAt(tCenter); 
                if (p < 1) requestAnimationFrame(up); else res(); 
            } 
            up(); 
        }); 
    }

    async function cinematicIntro(attacker, skillName) { const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(attacker.group.quaternion); const focusPos = attacker.group.position.clone().add(forward.multiplyScalar(150)); focusPos.y += 20; await new Promise(res => { let sPos = camera.position.clone(); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 400); camera.position.lerpVectors(sPos, focusPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); showMove(skillName); SoundEngine.play('click'); await sleep(500); return new Promise(res => { let sPos = camera.position.clone(); let zoomOutPos = attacker.group.position.clone().add(new THREE.Vector3(0, 240, 350)); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 1000); camera.position.lerpVectors(sPos, zoomOutPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    async function performAttack(attacker, target, type) { 
        if (!attacker || !target) return; const tp = target.group.position.clone(), orig = attacker.group.position.clone(); 
        if (type === 0 && target.action.card === 2 && target.type === 'Odin') { const strikePos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); await move(attacker.group, strikePos, 200); SoundEngine.play('magic'); target.group.visible = false; showMove("Spank!"); const behindPos = attacker.group.position.clone().add(target.group.position.clone().sub(attacker.group.position).normalize().multiplyScalar(-45)); target.group.position.copy(behindPos); target.face(attacker.group.position); target.group.visible = true; target.weaponGroup.rotation.z = 1.8; SoundEngine.play('counter'); await sleep(300); calcDamage(attacker, target, 0); gainRage(target, true, 20); await sleep(500); target.weaponGroup.rotation.z = 0; hideMove(); await move(attacker.group, orig, 400); target.group.position.copy(tp); target.face(attacker.group.position); return; } 
        if (type === 0 && target.action.card === 2 && target.type === 'Loki') { const victims = players.filter(p => p && p.alive && p.id !== target.id && p.id !== attacker.id); if (victims.length >= 1) { const victim = victims[Math.floor(Math.random()*victims.length)]; showMove("Swap!"); await sleep(800); const lokiOrigPos = target.group.position.clone(), victimOrigPos = victim.group.position.clone(); const magnet = createMagnetModel(); magnet.position.copy(target.group.position).add(new THREE.Vector3(0, 15, 10)); scene.add(magnet); SoundEngine.play('magic'); showMove("!!!"); const backDir = target.group.position.clone().sub(attacker.group.position).normalize(); const backPos = lokiOrigPos.clone().add(backDir.multiplyScalar(40)); await Promise.all([move(victim.group, lokiOrigPos, 1200), move(target.group, backPos, 1200)]); hideMove(); const strikePos = lokiOrigPos.clone().add(orig.clone().sub(lokiOrigPos).normalize().multiplyScalar(45)); if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 10.0; await sleep(600); await move(attacker.group, strikePos, 150); } else { await move(attacker.group, strikePos, 250); attacker.weaponGroup.rotation.z = 0.8; } SoundEngine.play(attacker.type === 'Loki' ? 'hit' : 'slash'); loseRage(attacker, true); 
        let dmg = (attacker.type === 'Loki') ? 60 : 80; // FIX: Base on attacker
        victim.takeDamage(dmg, 0, attacker.group.position); spawnDamageNumber(victim, dmg); await sleep(500); if (attacker.type === 'Odin') attacker.weaponGroup.rotation.z = 0; if (attacker.type === 'Loki') attacker.ballRotationMultiplier = 1.0; await move(attacker.group, orig, 500); scene.remove(magnet); await Promise.all([move(target.group, lokiOrigPos, 1200), move(victim.group, victimOrigPos, 1200)]); return; } } 
        if (type === 0) { if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 10.0; await sleep(600); const sPos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); await move(attacker.group, sPos, 150); SoundEngine.play('hit'); calcDamage(attacker, target, 0); await sleep(300); attacker.ballRotationMultiplier = 1.0; await move(attacker.group, orig, 500); } else { const sPos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); await move(attacker.group, sPos, 250); attacker.weaponGroup.rotation.z = 0.8; SoundEngine.play('slash'); calcDamage(attacker, target, 0); await sleep(300); attacker.weaponGroup.rotation.z = 0; await move(attacker.group, orig, 500); } } else { 
            if (attacker.type === 'Loki') { 
                const throwStart = attacker.group.position.clone().add(new THREE.Vector3(0, 30, 0)), throwEnd = target.group.position.clone().add(new THREE.Vector3(0, 20, 0)); activeProjectiles.push(new ParabolicMeatProjectile(throwStart, throwEnd)); SoundEngine.play('magic'); await sleep(800); 
            } else { 
                // ODIN MAGIC: 8 BOLTS
                const mouthPos = attacker.group.position.clone().add(new THREE.Vector3(0, 25, 0)); 
                for(let k=0; k<8; k++) {
                     // Add some randomness to target pos
                     const jitter = new THREE.Vector3((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*15);
                     activeLightnings.push(new OptimizedLightningBolt(mouthPos, target.group.position.clone().add(new THREE.Vector3(0,25,0)).add(jitter))); 
                }
                SoundEngine.play('magic'); 
                await sleep(800); 
            } 
            if (target.action.card === 3 && type === 1) { await focusOnAction(target, attacker, 400); if (target.type === 'Odin') { target.weaponGroup.rotation.z = 1.2; await move(target.weaponGroup, new THREE.Vector3(0,0,5), 100); showMove(CARD_NAMES[3]); for (let i = 0; i < 12; i++) { setTimeout(() => { activeLightnings.push(new OptimizedLightningBolt(target.group.position.clone().add(new THREE.Vector3(0,25,0)), attacker.group.position.clone().add(new THREE.Vector3(0,25,0)), 0xff0000)); SoundEngine.play('magic'); }, i * 50); } await sleep(1000); await move(target.weaponGroup, new THREE.Vector3(0,0,0), 100); target.weaponGroup.rotation.z = 0; hideMove(); } else if (target.type === 'Loki') { 
            // --- UPDATED LOKI MAGIC REFLECT ANIMATION ---
            target.ballRotationMultiplier = 15.0; 
            target.aura.activate(false); // Blue Aura for magic reflect
            const originalBallPos = target.ball.position.clone(); 
            const worldPosAttacker = new THREE.Vector3(); 
            attacker.group.getWorldPosition(worldPosAttacker); 
            worldPosAttacker.y += 30; 
            
            // Grow ball
            target.ball.scale.set(3,3,3);

            await new Promise(res => { 
                const start = target.ball.position.clone(), localTarget = target.modelContainer.worldToLocal(worldPosAttacker.clone()), t = performance.now(); 
                function fly() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(start, localTarget, p); if (p < 1) requestAnimationFrame(fly); else res(); } 
                fly(); 
            }); 
            
            SoundEngine.play('hit'); 
            createExplosion(attacker.group.position, 2.0); 
            
            await new Promise(res => { 
                const start = target.ball.position.clone(), t = performance.now(); 
                function back() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(start, originalBallPos, p); if (p < 1) requestAnimationFrame(back); else res(); } 
                back(); 
            }); 
            
            // Reset
            target.ball.scale.set(1,1,1);
            target.aura.deactivate();
            target.ballRotationMultiplier = 1.0; 
        } SoundEngine.play('counter'); await sleep(1000); } calcDamage(attacker, target, 1); } 
    }
    async function performLightningStorm(p) { 
        SoundEngine.play('super'); 
        const targets = players.filter(o => o && o.id !== p.id && o.alive); 
        
        if (p.type === 'Loki') { 
            // Loki Logic
            p.takeDamage(p.maxHP * 0.25, 2); 
            // ... MeatDrop loop ...
            for(let i=0; i<3; i++) { 
                targets.forEach(t => activeProjectiles.push(new MeatDrop(t.group.position, 8.75, true))); 
                await sleep(400); 
            } 
            await sleep(600); 
            
            // Damage and Steal
            for (const t of targets) {
                calcDamage(p, t, 1, true);
                // Steal Logic
                if (!t.blockedInTurn) {
                    let stolen = 0;
                    if (t.rage.red > 0) {
                        stolen = Math.floor(t.rage.red * 0.5);
                        t.rage.red -= stolen;
                    } else if (t.rage.blue > 0) {
                        stolen = Math.floor(t.rage.blue * 0.5);
                        t.rage.blue -= stolen;
                    }
                    
                    if (stolen > 0) {
                        // Loki gains Blue Rage
                        p.rage.blue = Math.min(100, p.rage.blue + stolen);
                        // Update Global if needed (though UI update handles it via object ref usually)
                        if (p.id === 0) playerRage.blue = p.rage.blue;
                        
                        // Visual
                        spawnDamageNumber(p, `+${stolen}%`, "#55ccff"); // Blue color
                    }
                }
            }
            window.updateHPUI();
        } else { 
            // Odin Logic (Existing)
            p.takeDamage(p.maxHP * 0.25, 2); // Assuming same self-dmg? No, Odin uses lightning
            const pullBackPos = new THREE.Vector3(0, 450, 650), pullBackCenter = new THREE.Vector3(0, 40, 0), originalCamPos = camera.position.clone(); await new Promise(res => { let s = performance.now(); function up() { let pv = Math.min(1, (performance.now() - s) / 800); camera.position.lerpVectors(originalCamPos, pullBackPos, pv); camera.lookAt(pullBackCenter); if (pv < 1) requestAnimationFrame(up); else res(); } up(); }); await sleep(300); for (let i = 0; i < 8; i++) { targets.forEach(t => { const sY = t.group.position.clone().add(new THREE.Vector3((Math.random()-0.5)*30, 500, (Math.random()-0.5)*30)); activeLightnings.push(new OptimizedLightningBolt(sY, t.group.position)); }); SoundEngine.play('magic'); await sleep(150); } await sleep(400); targets.forEach(t => calcDamage(p, t, 1, true)); await sleep(400); resetCamera();
        } 
    }
    
    async function performPhysicalSuper(attacker, target) { SoundEngine.play('super'); const op = attacker.group.position.clone(); if (!target) return; const tp = target.group.position.clone(); if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 15.0; const vec = tp.clone().sub(op).normalize(); const behindPos = tp.clone().add(vec.clone().multiplyScalar(40)); const hitBackPos = tp.clone().add(vec.clone().multiplyScalar(5)); await move(attacker.group, behindPos, 250); calcDamage(attacker, target, 0, true); createExplosion(tp, 1.5); SoundEngine.play('hit'); await sleep(100); await move(attacker.group, hitBackPos, 200); calcDamage(attacker, target, 0, true, true); SoundEngine.play('hit'); await move(attacker.group, behindPos, 200); await sleep(100); const frontPos = tp.clone().sub(vec.clone().multiplyScalar(40)); await move(attacker.group, frontPos, 250); calcDamage(attacker, target, 0, true); SoundEngine.play('hit'); createExplosion(tp, 1.5); await sleep(100); attacker.ballRotationMultiplier = 1.0; await move(attacker.group, op, 500); } else { for (let i = 0; i < 3; i++) { const strikePos = tp.clone().add(op.clone().sub(tp).normalize().multiplyScalar(40)); await move(attacker.group, strikePos, 150); calcDamage(attacker, target, 0, true, i > 0); await sleep(100); } await move(attacker.group, op, 400); } }

    async function resolveActions() { 
        // ä¿®æ­£ï¼šä¾é¸æ“‡æ™‚é–“æ’åºï¼Œå¥§ç¾© > å…¶ä»–
        const pMap = { 4: 0, 3: 0, 5: 1, 0: 2, 1: 2, 2: 3 }; 
        const q = players.filter(p => p && p.alive).sort((a, b) => {
            const prioA = pMap[a.action.card] ?? 5;
            const prioB = pMap[b.action.card] ?? 5;
            if (prioA !== prioB) return prioA - prioB;
            return a.action.selectionTime - b.action.selectionTime;
        });

        let localDemoId = currentDemoId; 
        
        showMove(TRANSLATIONS[currentLang].lockingTargets);
        await sleep(1200);
        hideMove();
        await sleep(300);
        
        for (let p of q) { 
            if (localDemoId !== currentDemoId) return;
            if (!p || !p.alive) continue; 
            const t = players.find(x => x && x.id === p.action.target);
            const cid = p.action.card; 
            let skillText = "";
            let targetName = t ? t.getDisplayName() : "";
            if (cid === 4) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[4]}!`;
            else if (cid === 3) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[3]}!`;
            else if (cid === 2) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[2]}!`;
            else if (cid === 5) {
                const isR = (p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99);
                skillText = isR ? `[${p.getDisplayName()}] ${TRANSLATIONS[currentLang].tutCardNames[5]} @ ${targetName}!` : `[${p.getDisplayName()}] ${TRANSLATIONS[currentLang].tutCardNames[6]}!`;
            } else if (cid >= 0) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[cid]} @ ${targetName}!`;
            
            if (cid === 4 || cid === 2 || cid === 3) { 
                showMove(skillText); SoundEngine.play('click'); await sleep(1000); 
            } else if (cid >= 0) await cinematicIntro(p, skillText);

            if (localDemoId !== currentDemoId) return; 
            if (!t || !t.alive) { 
                if (cid >= 0 && cid !== 4 && cid !== 2 && cid !== 3 && cid !== 5) {
                     showMove("ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ"); await sleep(1000); hideMove();
                }
                const isMagicUlt = (cid === 5 && !((p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99)));
                if (cid !== 4 && cid !== 2 && cid !== 3 && !isMagicUlt) {
                    window.updateHPUI(); await sleep(300); resetCamera(); continue; 
                }
            } 
            if (cid === 4) { p.fatigue = Math.min(150, p.fatigue + 75); window.updateHPUI(); } 

            // FIX: Face nearest enemy instead of self
            if (p.id === t.id) {
                let nearest = null; let minDst = 99999;
                players.forEach(o => { if (o.id !== p.id && o.alive) { const d = p.group.position.distanceTo(o.group.position); if (d < minDst) { minDst = d; nearest = o; } } });
                if (nearest) p.face(nearest.group.position); else p.face(new THREE.Vector3(0, 50, 0));
            } else { 
                if (t && t.alive && cid !== 3) t.face(p.group.position); 
            }

            if (cid === 4) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 2) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 3) { 
                p.hexShield.visible = true; SoundEngine.play('counter'); 
                const anyEnemy = players.find(x => x.id !== p.id && x.alive);
                if(anyEnemy) p.face(anyEnemy.group.position); else p.face(new THREE.Vector3(0,0,0));
                await focusOnAction(p, null, 400); await sleep(400); 
            } 
            else if (cid === 5) { 
                const isR = (p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99); 
                
                // Consume Rage FIRST
                p.rage.red = 0; p.rage.blue = 0; 
                if (p.id === 0) { playerRage.red = 0; playerRage.blue = 0; }
                window.updateHPUI();

                if (isR) { if (t?.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); await performPhysicalSuper(p, t); } } 
                else { p.face(new THREE.Vector3(0,0,0)); await performLightningStorm(p); }
                // Removed post-execution reset
            } 
            else if (cid >= 0 && cid < 2) { 
                if (t && t.alive) { 
                    await focusOnAction(p, t, 600); 
                    p.face(t.group.position); 
                } 
                // --- UPDATED LOKI PHYSICAL ATTACK ANIMATION ---
                if (p.type === 'Loki' && cid === 0) {
                     p.aura.activate(true); // Red Aura
                     p.ballRotationMultiplier = 15.0;
                     // Grow Ball
                     p.ball.scale.set(3,3,3);
                     await sleep(600); // Wait for grow/spin
                     
                     // Move Group
                     const op = p.group.position.clone();
                     const tp = t.group.position.clone();
                     const sPos = tp.clone().add(op.clone().sub(tp).normalize().multiplyScalar(45));
                     
                     await move(p.group, sPos, 150);
                     SoundEngine.play('hit'); 
                     calcDamage(p, t, 0); 
                     await sleep(300);
                     
                     // Reset
                     p.ball.scale.set(1,1,1);
                     p.aura.deactivate();
                     p.ballRotationMultiplier = 1.0;
                     await move(p.group, op, 500);
                } else {
                     await performAttack(p, t, cid); 
                }
            } 
            
            if (localDemoId !== currentDemoId) return; 
            hideMove(); window.updateHPUI(); await sleep(300); resetCamera(); await sleep(1500); 
        } 
        
        
            const survivors = players.filter(p => p.alive);
            if (survivors.length <= 1) {
                let winner = survivors.length > 0 ? survivors[0] : null; const t = TRANSLATIONS[currentLang];
                if (winner) { matchScores[winner.id] = (matchScores[winner.id] || 0) + 1; players.forEach(p => p.refreshLabel()); }
                if (winner && matchScores[winner.id] >= targetWins) {
                    showMsg(t.finalVictory.replace('{name}', winner.getDisplayName()), true); // Inject Winner Name
                    if (isMultiplayer && window.Online.isHost) window.Network.broadcast({ type: 'GAME_OVER', msg: t.finalVictory.replace('{name}', winner.getDisplayName()), isFinal: true, winnerName: winner.getDisplayName(), scores: matchScores });
                } else {
                    const wName = winner ? winner.getDisplayName() : "Draw";
                    if (isMultiplayer && window.Online.isHost) {
                        window.Network.broadcast({ type: 'GAME_OVER', isFinal: false, autoRestart: true, winnerName: wName, scores: matchScores });
                        setTimeout(() => { 
                            // Add cleanup overlay
                            const cleanupMsg = document.getElementById('cleanup-msg');
                            if(cleanupMsg) cleanupMsg.classList.add('active');
                            window.Network.broadcast({ type: 'SHOW_CLEANUP' }); // Broadcast cleanup
                            
                            setTimeout(() => {
                                if(gameState !== 'IDLE') {
                                    window.Network.hostStartGame(); 
                                    if(cleanupMsg) cleanupMsg.classList.remove('active');
                                    window.Network.broadcast({ type: 'HIDE_CLEANUP' }); // Broadcast hide cleanup
                                }
                            }, 3000); // 3 seconds cleanup time
                        }, 5000);
                    } else if (!isMultiplayer) { 
                        startRoundTransition(wName); 
                        setTimeout(() => {
                            const cleanupMsg = document.getElementById('cleanup-msg');
                            if(cleanupMsg) cleanupMsg.classList.add('active');
                            setTimeout(() => {
                                window.restartRound();
                                if(cleanupMsg) cleanupMsg.classList.remove('active');
                            }, 3000);
                        }, 5000); 
                    }
                }
            } else if (window.Online.isHost || !isMultiplayer) startTurn();
        
    }
    
    function endTurn() { 
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer);
        gameState = 'ANIMATING'; document.getElementById('turn-hint').style.display = 'none';
        
        // é è¨­é–å®šé‚è¼¯ï¼šå°é¢ -> å·¦ -> å³
        const getPriorityTarget = (myId) => {
            const opposite = (myId + 2) % 4;
            const left = (myId + 1) % 4;
            const right = (myId + 3) % 4;
            if (players[opposite] && players[opposite].alive) return opposite;
            if (players[left] && players[left].alive) return left;
            if (players[right] && players[right].alive) return right;
            return getRandomTarget(myId);
        };

        let myP = players[myPlayerIndex];
        if (myP.action.card === -1) {
             myP.action = { card: (myP.fatigue >= 100 ? 0 : 4), target: getPriorityTarget(myP.id), selectionTime: Date.now() + 10000 };
        }

        players.forEach((p, i) => {
            if (!p.alive) return;
            if (isMultiplayer) { if (window.Online.playerMap[i] && (window.Online.playerMap[i].isCpu || i === myPlayerIndex)) {} else if (p.action.card === -1) p.action = { card: (p.fatigue >= 100 ? 0 : 4), target: getPriorityTarget(p.id), selectionTime: Date.now() + 10000 }; }
            if (!isMultiplayer || (window.Online.playerMap[i] && window.Online.playerMap[i].isCpu)) { if (i !== myPlayerIndex) { if (p.action.card === -1) p.action = { card: 0, target: getPriorityTarget(p.id), selectionTime: Date.now() + 10000 }; if (players[p.action.target]) p.face(players[p.action.target].group.position); } }
        });
        if (isMultiplayer && window.Online.isHost) window.Network.broadcast({ type: 'TURN_RESOLVE', actions: players.map(p => p.action) });
        resolveActions(); 
    }
    
    function cpuThink() {
        if (gameState !== 'WAITING') return;
        if (timeLeft < (TURN_TIME - 6)) return;
        players.forEach((p, idx) => {
            if (!p.alive) return;
            if ((isMultiplayer && window.Online.playerMap[idx] && window.Online.playerMap[idx].isCpu) || (!isMultiplayer && idx !== 0)) {
                 const threats = players.filter(enemy => enemy.alive && enemy.id !== idx && enemy.action.target === idx);
                 let chosenTargetId = p.action.target;
                 const fatiguedTargets = players.filter(o => o.id !== idx && o.alive && o.fatigue >= 100);
                 if (chosenTargetId === -1 || Math.random() < 0.4 || threats.length > 0) {
                     if (fatiguedTargets.length > 0 && Math.random() < 0.85) chosenTargetId = fatiguedTargets[Math.floor(Math.random() * fatiguedTargets.length)].id;
                     else if (threats.length > 0 && Math.random() < 0.7) chosenTargetId = threats[Math.floor(Math.random() * threats.length)].id;
                     else { const validTargets = players.filter(o => o.id !== idx && o.alive); if (validTargets.length > 0) chosenTargetId = validTargets[Math.floor(Math.random() * validTargets.length)].id; }
                 }
                 if (chosenTargetId !== -1) { p.action.target = chosenTargetId; if (players[chosenTargetId]) p.face(players[chosenTargetId].group.position); }
                 if (p.action.card === -1 || Math.random() < 0.3) {
                    const r = p.rage; const maxRage = Math.max(r.red, r.blue); let choice = 0;
                    if (maxRage >= 99 && Math.random() < 0.9) choice = 5;
                    else { const isRed = r.red >= r.blue; const hasRage = maxRage > 20; if (hasRage) { const roll = Math.random(); if (isRed) choice = roll < 0.6 ? 0 : (roll < 0.9 ? 2 : 4); else choice = roll < 0.6 ? 1 : (roll < 0.9 ? 3 : 4); } else { const roll = Math.random(); choice = roll < 0.4 ? 0 : (roll < 0.8 ? 1 : 4); } }
                    if (choice === 4 && p.fatigue >= 100) choice = (r.red >= r.blue) ? 0 : 1;
                    p.action.card = choice;
                    // AI çš„é¸æ“‡æ™‚é–“ä¹Ÿè¨­ç‚ºç•¶å‰
                    p.action.selectionTime = Date.now();
                 }
            }
        });
    }

    function startTurn() {
        if (gameState === 'ENDED') return; if (isMultiplayer && window.Online.isHost) window.Network.broadcast({ type: 'TURN_START' });
        gameState = 'WAITING'; timeLeft = TURN_TIME; selectedSlot = -1; selectedTargetId = -1;
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected', 'disabled'));
        hideMove();
        const tEl = document.getElementById('timer'); if (tEl) { tEl.innerText = timeLeft; tEl.style.display = "block"; }
        document.getElementById('turn-hint').style.display = 'block';

        // é è¨­é–å®šé‚è¼¯ï¼šå°é¢ -> å·¦ -> å³
        const getPriorityTarget = (myId) => {
            const opposite = (myId + 2) % 4;
            const left = (myId + 1) % 4;
            const right = (myId + 3) % 4;
            if (players[opposite] && players[opposite].alive) return opposite;
            if (players[left] && players[left].alive) return left;
            if (players[right] && players[right].alive) return right;
            return getRandomTarget(myId);
        };

        players.forEach((p, i) => { 
            p.fatigue = Math.max(0, p.fatigue - 35); p.showBrokenShield = p.fatigue >= 100; p.defendHitCount = 0; p.blockedInTurn = false; 
            // åˆå§‹åŒ– actionï¼Œé è¨­ target
            const defaultTarget = getPriorityTarget(p.id);
            p.action = { card: -1, target: defaultTarget, selectionTime: 0 }; 
            if (p.hexShield) p.hexShield.visible = false; p.updateLabel(); 
            
            // è®“è§’è‰²é¢å‘é è¨­ç›®æ¨™
            if (defaultTarget !== -1 && players[defaultTarget]) {
                p.face(players[defaultTarget].group.position);
                // å°æ–¼æœ¬æ©Ÿç©å®¶ï¼Œæ›´æ–°ç´…è‰²é¸å–åœˆ
                if (i === myPlayerIndex) selectedTargetId = defaultTarget;
            } else {
                 if (i === myPlayerIndex) selectedTargetId = -1; // Hide Reticle
            }
        });
        resetCamera(); window.updateHPUI(); 
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer); 
        if (!isMultiplayer || window.Online.isHost) cpuThinkTimer = setInterval(cpuThink, 800); 
        timerInterval = setInterval(() => { timeLeft--; if (tEl) tEl.innerText = timeLeft; if (timeLeft <= 0) { if(tEl) tEl.style.display = "none"; if (!isMultiplayer || window.Online.isHost) endTurn(); } }, 1000);
    }

    window.selectCard = function(i) { 
        if (gameState !== 'WAITING') return; const p = players[myPlayerIndex]; if (!p || !p.alive) return;
        selectedSlot = i; document.querySelectorAll('.card').forEach((c, idx) => c.classList.toggle('selected', idx === i)); SoundEngine.play('click'); 
        showCardDescription(i); p.action.card = i;
        // æ›´æ–°é¸æ“‡æ™‚é–“ï¼Œç”¨æ–¼åˆ¤å®šå…ˆæ‰‹
        p.action.selectionTime = Date.now();

        // é—œéµä¿®æ­£ï¼šLoki ç£éµäº¤æ› (å¡ç‰‡2) éœ€è‡³å°‘ 2 åå°æ‰‹
        const aliveEnemies = players.filter(pl => pl.id !== p.id && pl.alive).length;
        if (p.type === 'Loki' && i === 2) {
             if (aliveEnemies < 2) {
                 showMove("éœ€2åä»¥ä¸Šå°æ‰‹"); 
                 // å–æ¶ˆé¸æ“‡
                 p.action.card = -1;
                 selectedSlot = -1;
                 document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                 return;
             }
        }

        const isMagicUlt = (i === 5 && !((p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99)));
        
        // ä¿®æ­£ï¼šæ”»æ“Šå¡ç›®æ¨™åˆ¤å®š
        if (i === 0 || i === 1 || (i === 5 && isMagicUlt === false)) {
            // æ˜¯æ”»æ“Šå¡
            if (p.action.target === myPlayerIndex || p.action.target === -1) {
                // å˜—è©¦ä½¿ç”¨ selectedTargetId
                if (selectedTargetId !== -1 && selectedTargetId !== myPlayerIndex && players[selectedTargetId].alive) {
                    p.action.target = selectedTargetId;
                } else {
                     // å¦å‰‡ä½¿ç”¨é è¨­å„ªå…ˆç´š
                    const getPriorityTarget = (myId) => {
                        const opposite = (myId + 2) % 4;
                        const left = (myId + 1) % 4;
                        const right = (myId + 3) % 4;
                        if (players[opposite] && players[opposite].alive) return opposite;
                        if (players[left] && players[left].alive) return left;
                        if (players[right] && players[right].alive) return right;
                        return -1;
                    };
                    p.action.target = getPriorityTarget(p.id);
                }
            }
            // Show Reticle if we have a target
            if (p.action.target !== -1 && p.action.target !== myPlayerIndex) {
                 selectedTargetId = p.action.target;
            }
        }
        
        // é˜²ç¦¦ã€åå°„ã€é­”æ³•å¥§ç¾©(AOE) ä»éœ€ä»¥è‡ªèº«ç‚ºç›®æ¨™ (é‚è¼¯ä¸Š)
        if (i === 2 || i === 3 || i === 4 || isMagicUlt) { 
             p.action.target = myPlayerIndex; 
             // Hide reticle for self-target moves
             selectedTargetId = -1;
        }

        if (isMultiplayer && !window.Online.isHost) window.Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
    };

    function handleInt(x, y) { 
        if (gameState !== 'WAITING') return; 
        // Allow clicking enemies even without card selected (to change target)
        // if (selectedSlot === -1) return; 
        
        const p = players[myPlayerIndex]; if (!p || !p.alive) return;
        const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((x - rect.left) / rect.width) * 2 - 1; mouse.y = -((y - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); 
        const chars = players.filter(pl => pl && pl.id !== myPlayerIndex && pl.alive).map(pl => pl.group); const intersects = raycaster.intersectObjects(chars, true); 
        if (intersects.length > 0) { 
            let o = intersects[0].object; while(o && !o.userData.isCharacter) o = o.parent; 
            if (o) { 
                if (o.userData.playerId === myPlayerIndex) return;
                selectedTargetId = o.userData.playerId; p.action.target = selectedTargetId; 
                // æ›´æ–°é¸æ“‡æ™‚é–“ï¼Œç”¨æ–¼åˆ¤å®šå…ˆæ‰‹
                p.action.selectionTime = Date.now();
                p.face(players[selectedTargetId].group.position); 
                SoundEngine.init(); SoundEngine.play('click'); window.updateHPUI(); 
                if (isMultiplayer && !window.Online.isHost) window.Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
            } 
        } 
    }

    function startRoundTransition(winnerName) {
        const timerEl = document.getElementById('timer'); if (timerEl) timerEl.style.display = 'none';
        const t = TRANSLATIONS[currentLang]; showMove(`${t.roundWinner} ${winnerName}`);
        setTimeout(() => { showMove(t.nextRoundIn); }, 2000);
    }

    window.startBattle = function(customConfigs = null) { document.getElementById('game-msg').style.display = 'none'; hideMove(); window.UI.show('game-ui'); initBattle(customConfigs); };

    function spawnPlayers(customConfigs) { 
        let configs = customConfigs;
        if (!configs) {
            configs = [
                { id: 0, x: 0, y: 50, z: 140, name: (selectedPlayerType === 'Loki' ? "æ´›åŸº" : "å¥§ä¸"), type: selectedPlayerType },
                { id: 1, x: 0, y: 50, z: -140, name: "æ´›åŸº", type: 'Loki' },
                { id: 2, x: 140, y: 50, z: 0, name: "å¥§ä¸A", type: 'Odin' },
                { id: 3, x: -140, y: 50, z: 0, name: "å¥§ä¸B", type: 'Odin' }
            ];
            myPlayerIndex = 0; isMultiplayer = false; if (gameState === 'IDLE' || Object.keys(matchScores).length === 0) { matchScores = {}; configs.forEach(p => matchScores[p.id] = 0); }
        }
        players = configs.map(cfg => new Odin(cfg)); window.updateText(); window.updateHPUI();
    }
    
    function initWorld() { scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 200, 2500); scene.add(new THREE.AmbientLight(0xffffff, 0.5)); const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(200, 400, 100); sun.castShadow = true; sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048; scene.add(sun); const arena = new THREE.Mesh(new THREE.BoxGeometry(375, 15, 375), new THREE.MeshPhongMaterial({ color: 0x88bb88 })); arena.position.y = -15; arena.receiveShadow = true; scene.add(arena); for(let i=0; i<12; i++) { const h = 700 + Math.random()*400; const m = new THREE.Mesh(new THREE.BoxGeometry(300, h, 300), new THREE.MeshPhongMaterial({ color: 0xcc99aa })); const a = (i/12)*Math.PI*2; m.position.set(Math.cos(a)*1200, h/2 - 1200, Math.sin(a)*1200); scene.add(m); const cap = new THREE.Mesh(new THREE.BoxGeometry(305, 70, 305), new THREE.MeshPhongMaterial({ color: 0xffffff })); cap.position.set(m.position.x, m.position.y + h/2, m.position.z); scene.add(cap); } }
    
    function initBattle(customConfigs) { 
        const v = document.getElementById('viewport'); const oldCanvas = v.querySelector('canvas'); if (oldCanvas) { v.removeChild(oldCanvas); } 
        scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000); 
        renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.setPixelRatio(window.devicePixelRatio); v.appendChild(renderer.domElement); 
        raycaster = new THREE.Raycaster(); clock = new THREE.Clock(); initWorld(); spawnPlayers(customConfigs); adjustCameraForResponsive(true); animate(); 
        window.addEventListener('resize', () => { if(camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); adjustCameraForResponsive(); } }); 
        window.addEventListener('mousedown', (e) => { SoundEngine.init(); handleInt(e.clientX, e.clientY); }); 
        window.addEventListener('touchstart', (e) => { SoundEngine.init(); if(e.touches[0]) handleInt(e.touches[0].clientX, e.touches[0].clientY); }); 
        if (!isMultiplayer || window.Online.isHost) startTurn(); else document.getElementById('turn-hint').innerText = TRANSLATIONS[currentLang].waitingOthers; 
    }
    
    function animate() { 
        animationId = requestAnimationFrame(animate); const dt = clock.getDelta(); 
        for(let i=activeLightnings.length-1; i>=0; i--) if(!activeLightnings[i].update()) activeLightnings.splice(i,1); 
        for(let i=activeParticles.length-1; i>=0; i--) if(!activeParticles[i].update(dt)) activeParticles.splice(i,1); 
        for(let i=activeProjectiles.length-1; i>=0; i--) if(!activeProjectiles[i].update(dt)) activeProjectiles.splice(i,1); 
        if (renderer && scene && camera) { players.forEach(p => { if(p && p.alive) { p.group.position.y = 50 + Math.sin(Date.now()*0.003 + p.id)*4; p.uiSprite.quaternion.copy(camera.quaternion); if (p.targetQuaternion) p.group.quaternion.slerp(p.targetQuaternion, 5 * dt); if(p.hexShield && p.hexShield.visible) p.hexShield.rotation.z += 0.05; if(p.type === 'Loki' && p.ball) { p.ball.rotation.y += 0.05 * p.ballRotationMultiplier; p.ball.rotation.x += 0.02 * p.ballRotationMultiplier; } const r = p.rage, maxRage = Math.max(r.red, r.blue); if (maxRage >= 99) { if (!p.aura.active || p.aura.isRed !== (r.red >= r.blue)) p.aura.activate(r.red >= r.blue); } else if (p.aura.active) p.aura.deactivate(); p.aura.update(dt); if (p.brokenShieldIcon && p.brokenShieldIcon.visible) { const s = 8 + Math.sin(Date.now() * 0.005) * 1.5; p.brokenShieldIcon.scale.set(s, s, 1); p.brokenShieldIcon.material.opacity = 0.6 + Math.sin(Date.now() * 0.005) * 0.2; } 
        // 2D Reticle Animation
        if (p.id === selectedTargetId && p.id !== myPlayerIndex && p.selectionSprite && players[selectedTargetId].alive) { 
            p.selectionSprite.visible = true; 
            // Scale reduced (Base 3.5, Var 0.7)
            const scaleBase = 3.5; const scaleVar = Math.sin(Date.now() * 0.005) * 0.7;
            p.selectionSprite.scale.set(scaleBase + scaleVar, scaleBase + scaleVar, 1);
            p.selectionSprite.material.rotation += 0.02;
        } else if (p.selectionSprite) { 
            p.selectionSprite.visible = false; 
        } 
        if (p.targetLabel) p.targetLabel.visible = false; } }); renderer.render(scene, camera); } 
    }

    
    window.resetGame = function() { 
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer); if (animationId) cancelAnimationFrame(animationId); 
        document.getElementById('game-msg').style.display = 'none'; document.getElementById('turn-hint').style.display = 'none'; 
        currentDemoId++; players.length = 0; playerRage = { red: 0, blue: 0 }; gameState = 'IDLE'; matchScores = {}; 
        document.getElementById('scoreboard').style.display = 'none'; window.UI.showMenu();
        hideCardDescription();
        
        // Clean Network
        if(window.Online.peer) window.Online.peer.destroy(); window.Online.peer = null; window.Online.playerMap = []; window.Online.connections = []; window.Online.hostConn = null;
    };
    
    window.askOracle = async function() { 
        SoundEngine.init(); const btn = document.getElementById('oracle-btn-card'); if (gameState !== 'WAITING' || btn.classList.contains('loading')) return; 
        btn.classList.add('loading'); const p = players[myPlayerIndex]; 
        try { const r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, { method: 'POST', body: JSON.stringify({ contents: [{ parts: [{ text: `Stats: HP:${p.hp}/500` }] }], systemInstruction: { parts: [{ text: "è±¬è±¬å…ˆçŸ¥ï¼Œçµ¦ç°¡çŸ­å»ºè­°ã€‚" }] } }) }); const res = await r.json(); const txt = res.candidates?.[0]?.content?.parts?.[0]?.text; if (txt) showMove(`âœ¨è±¬è±¬å…ˆçŸ¥: ${txt.trim()}`); } catch(e){} 
        btn.classList.remove('loading'); 
    };

    function showMsg(t, isFinal = false) { 
        const el = document.getElementById('game-msg'); const btnText = isFinal ? TRANSLATIONS[currentLang].finalMenu : TRANSLATIONS[currentLang].restart; const btnAction = isFinal ? "window.resetGame()" : "window.restartRound()";
        let btnHtml = `<button class="btn-gold" style="margin-top:10px;" onclick="${btnAction}">${btnText}</button>`;
        if (isMultiplayer && !window.Online.isHost && !isFinal) btnHtml = `<div style="font-size:0.9rem; color:#aaa; margin-top:10px;">${TRANSLATIONS[currentLang].waitingHost}</div>`;
        
        // Final Victory Special Styling
        let contentHtml = isFinal ? `<div class="final-victory-text">${t}</div>` : `<span>${t}</span>`;
        
        // Fireworks Trigger
        if (isFinal && typeof Fireworks !== 'undefined') {
            Fireworks.start();
        }

        el.innerHTML = `${contentHtml}<br>${btnHtml}`; el.style.display = 'flex'; 
    }

    window.restartRound = function() {
        if (isMultiplayer && !window.Online.isHost) return;
        if (typeof Fireworks !== 'undefined') Fireworks.stop(); // Stop fireworks on restart
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer);
        document.getElementById('game-msg').style.display = 'none'; hideMove();
        if (scene) { while(scene.children.length > 0){ const o = scene.children[0]; if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose(); scene.remove(o); } }
        players.length = 0; activeLightnings.length = 0; activeParticles.length = 0; activeProjectiles.length = 0; playerRage = { red: 0, blue: 0 }; 
        if (isMultiplayer && window.Online.isHost) window.Network.hostStartGame(); else window.startBattle(); 
    };
</script>
</body>
</html>