<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ë±¨Á•ûÈªÉÊòè Pignarok Arena (Responsive)</title>
    <style>
        /* --- Âü∫Á§éË®≠ÂÆö --- */
        :root {
            --ui-max-width: 500px;
            --primary-gold: #ff99cc;
            --bg-overlay: rgba(0, 0, 0, 0.4);
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: 'Cinzel', serif, "Microsoft JhengHei", "Helvetica Neue", sans-serif;
            background: #000; color: white;
            touch-action: none; width: 100vw; height: 100vh;
            -webkit-user-select: none; user-select: none;
        }
        
        #viewport {
            position: relative; width: 100%; height: 100%;
            background: #87CEEB; overflow: hidden;
        }

        #viewport canvas { display: block; width: 100% !important; height: 100% !important; outline: none; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle, rgba(40, 20, 80, 0.95) 0%, rgba(10, 5, 20, 1) 100%);
            z-index: 2000; transition: opacity 0.5s ease; padding: 20px; box-sizing: border-box;
        }

        h1 { 
            font-size: clamp(2.5rem, 8vw, 4.5rem); margin-bottom: 5px; color: var(--primary-gold); 
            text-shadow: 0 0 20px rgba(255, 153, 204, 0.6); letter-spacing: 5px; text-align: center; 
        }
        .sub-title { font-size: 1.2rem; color: #fff; margin-bottom: 30px; letter-spacing: 2px; opacity: 0.8; }
        h2 { font-size: 1.4rem; color: #fff; margin-bottom: 20px; border-bottom: 2px solid var(--primary-gold); padding-bottom: 8px; }

        #turn-hint {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 1rem; font-weight: bold; text-shadow: 0 0 10px #000;
            background: var(--bg-overlay); padding: 5px 15px; border-radius: 20px;
            display: none; z-index: 50; pointer-events: none;
            white-space: nowrap; border: 1px solid rgba(255, 255, 255, 0.2);
        }
        @media (min-width: 768px) { #turn-hint { top: 100px; font-size: 1.2rem; } }

        @keyframes hint-flash { 0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); } 50% { opacity: 0.3; transform: translateX(-50%) scale(0.95); } }
        .flashing { animation: hint-flash 1s infinite ease-in-out; }

        .btn-gold {
            padding: 12px 30px; font-size: 1.1rem; background: rgba(255, 153, 204, 0.2);
            border: 2px solid var(--primary-gold); color: var(--primary-gold); cursor: pointer; border-radius: 50px;
            transition: all 0.3s; font-family: 'Cinzel', serif; text-transform: uppercase;
            max-width: 300px; width: 100%; margin-bottom: 15px;
        }
        .btn-gold:hover { background: var(--primary-gold); color: #1a0d0d; transform: scale(1.05); }

        .lang-container {
            display: flex; gap: 15px; margin-bottom: 30px;
        }
        .btn-lang {
            padding: 8px 20px; font-size: 0.9rem; background: transparent;
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            transition: all 0.3s;
        }
        .btn-lang.active { background: var(--primary-gold); color: #000; border-color: var(--primary-gold); }
        .btn-lang:hover { transform: scale(1.1); }

        .selection-container { 
            display: flex; gap: 15px; margin-bottom: 30px; width: 100%; max-width: 600px;
            flex-direction: row; 
        }
        @media (max-width: 350px) { .selection-container { flex-direction: column; } }

        .char-card {
            flex: 1; background: rgba(255,255,255,0.05); border: 2px solid transparent;
            border-radius: 12px; padding: 15px; cursor: pointer; transition: 0.3s;
            display: flex; flex-direction: column; align-items: center; text-align: center;
        }
        .char-card.active { border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2); transform: translateY(-5px); }
        .char-portrait-icon { font-size: 3rem; margin-bottom: 5px; }

        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        
        #top-announcer {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            width: 100%; max-width: var(--ui-max-width);
            text-align: center; pointer-events: none; z-index: 100;
        }
        #timer { color: #fff; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1); }
        #move-display {
            color: var(--primary-gold); font-size: clamp(1.2rem, 4vw, 1.8rem); font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1);
            margin-top: 5px; opacity: 0; transition: opacity 0.3s;
            background: rgba(0,0,0,0.8); padding: 12px 40px; border-radius: 50px;
            display: inline-block; border: 3px solid var(--primary-gold);
            white-space: nowrap; transform: scale(1.1);
        }

        #status-log {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: var(--ui-max-width); height: 42px; background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 153, 204, 0.4); border-radius: 8px; padding: 5px; font-size: 0.8rem; overflow-y: auto;
            pointer-events: auto; color: #eee; backdrop-filter: blur(3px); z-index: 30; text-align: left;
        }
        
        #card-description {
            position: absolute; bottom: 115px; left: 0; width: 100%;
            text-align: center; color: #ffeb3b; font-size: 0.85rem; font-weight: bold;
            text-shadow: 0 0 5px #000; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            background: linear-gradient(to right, transparent, rgba(0,0,0,0.7), transparent);
            padding: 5px 0; z-index: 25;
        }

        #bottom-ui-container {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: flex; justify-content: center;
            padding: 10px 0 20px 0; 
            background: linear-gradient(to top, rgba(0,0,0,1) 30%, rgba(0,0,0,0.6) 80%, transparent);
            pointer-events: auto; z-index: 20;
        }

        #card-area { 
            display: flex; flex-direction: row; gap: 3px; 
            width: 98%; max-width: var(--ui-max-width); 
            justify-content: space-evenly; align-items: flex-end; 
        }

        #player-hp-card {
            flex: 1.2; height: 95px; min-width: 50px;
            background: rgba(80, 0, 40, 0.7); border: 1.5px solid var(--primary-gold); border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 4px 2px; color: #fff; backdrop-filter: blur(10px);
            font-size: 0.58rem; font-weight: bold; line-height: 1.3; text-align: center; box-sizing: border-box;
        }

        .name-text { font-size: 0.62rem; color: var(--primary-gold); margin-bottom: 2px; width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .hp-text { font-size: 0.58rem; color: #ffccdd; }
        .fatigue-text { color: #ffaa00; font-size: 0.52rem; }
        .rage-text { font-size: 0.52rem; color: #ff8888; }

        .card {
            flex: 1; height: 95px; min-width: 40px; 
            background: rgba(255, 255, 255, 0.1); border: 1.2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; cursor: pointer; transition: 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; color: #fff; font-weight: bold; backdrop-filter: blur(5px); 
            font-size: 0.55rem; 
            padding: 2px; box-sizing: border-box; user-select: none;
        }
        .card:active { transform: scale(0.92); }
        .card.selected { 
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.3); 
            transform: scale(1.15) translateY(-10px); box-shadow: 0 0 20px rgba(255, 153, 204, 0.6); z-index: 100;
        }
        .card.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .card:hover { background: rgba(255, 255, 255, 0.2); }

        @keyframes card-breathing-red { 0%, 100% { box-shadow: 0 0 5px #ff5555; } 50% { box-shadow: 0 0 20px #ff0000; } }
        @keyframes card-breathing-blue { 0%, 100% { box-shadow: 0 0 5px #55ccff; } 50% { box-shadow: 0 0 20px #0088ff; } }
        
        .card.super { color: #000; border-color: #fff; font-weight: 800; }
        .card.super-red { animation: card-breathing-red 1.5s infinite; background: linear-gradient(135deg, #ff9999, #fff); }
        .card.super-blue { animation: card-breathing-blue 1.5s infinite; background: linear-gradient(135deg, #99ccff, #fff); }

        .circle-btn {
            position: absolute; width: 45px; height: 45px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid var(--primary-gold);
            color: #fff; font-size: 0.8rem; font-weight: bold;
            cursor: pointer; z-index: 200; display: flex; justify-content: center; align-items: center;
            pointer-events: auto; transition: all 0.2s;
            top: 20px; top: max(20px, env(safe-area-inset-top));
        }
        .circle-btn:hover { transform: scale(1.1); background: var(--primary-gold); color: #000; }

        .home-btn { left: 20px; left: max(20px, env(safe-area-inset-left)); font-size: 1.5rem; padding-bottom: 3px; }

        #game-msg {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.2rem; color: #fff; display: none; background: rgba(0,0,0,0.95);
            padding: 25px 40px; border-radius: 20px; border: 3px solid var(--primary-gold); z-index: 3000;
            text-align: center; width: 80%; max-width: 400px; backdrop-filter: blur(10px);
        }

        #tutorial-ui {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: none; flex-direction: column; align-items: center;
            background: linear-gradient(to top, rgba(0,0,0,1) 40%, rgba(0,0,0,0.8) 90%, transparent);
            padding-bottom: 20px; pointer-events: auto; z-index: 25;
        }
        #tutorial-desc {
            color: #fff; font-size: 1rem; text-align: center; margin-bottom: 10px;
            padding: 10px 20px; background: rgba(0,0,0,0.5); border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2); width: 90%; max-width: var(--ui-max-width);
        }
        .tutorial-controls {
            display: flex; gap: 3px; width: 98%; max-width: var(--ui-max-width);
            justify-content: center; margin-bottom: 10px;
        }
        .back-btn-container { position: absolute; top: 20px; right: 20px; z-index: 200; }
        .btn-small {
            padding: 8px 15px; font-size: 0.9rem; background: rgba(0,0,0,0.6);
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            font-family: 'Cinzel', serif;
        }

        @media (min-width: 1024px) {
            #status-log { bottom: 150px; width: 100%; font-size: 1rem; height: 50px; }
            .card { font-size: 0.8rem; }
            .name-text, .hp-text, .fatigue-text, .rage-text { font-size: 0.75rem; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<div id="viewport">
    
    <div id="main-menu" class="overlay-screen">
        <h1 id="menu-title">Ë±¨Á•ûÈªÉÊòè</h1>
        <div class="sub-title">PIGNAROK ARENA</div>
        
        <!-- Language Selection in Main Menu -->
        <div class="lang-container">
            <button id="lang-zh" class="btn-lang active" onclick="window.setLang('zh-TW')">‰∏≠Êñá</button>
            <button id="lang-en" class="btn-lang" onclick="window.setLang('en-US')">ENG</button>
        </div>

        <button id="btn-single-player" class="btn-gold" onclick="window.showCharSelect()">ÂñÆ‰∫∫ÈÅäÊà≤</button>
        <button id="btn-tutorial" class="btn-gold" onclick="window.startTutorialSelection()">ËßíËâ≤ÊïôÂ≠∏</button>
    </div>

    <div id="turn-hint" class="flashing">Ë´ãÈÅ∏Êìá‰∏ãÊñπÁöÑÂç°Áâå‰∏¶ÈªûÈÅ∏Â∞çÊâã</div>

    <div id="char-select" class="overlay-screen" style="display:none;">
        <h2 id="char-select-title">ÈÅ∏Êìá‰Ω†ÁöÑË±¨Ë±¨Êà∞Â£´</h2>
        <div class="selection-container">
            <div id="select-odin" class="char-card active" onclick="window.pickChar('Odin')">
                <div class="char-portrait-icon">‚ö°üê∑</div>
                <div id="char-name-odin" class="char-name">Â•ß‰∏ÅË±¨</div>
                <div id="char-desc-odin" style="font-size:0.7rem; color:#ccc; margin-top:5px;">Èõ∑ÈúÜËàáÊ¶ÆËÄÄ</div>
            </div>
            <div id="select-loki" class="char-card" onclick="window.pickChar('Loki')">
                <div class="char-portrait-icon">üÉèüê∑</div>
                <div id="char-name-loki" class="char-name">Ê¥õÂü∫Ë±¨</div>
                <div id="char-desc-loki" style="font-size:0.7rem; color:#ccc; margin-top:5px;">Ë©≠Ë®àËàáÈÆÆËÇâ</div>
            </div>
        </div>
        <button id="btn-start-battle" class="btn-gold" onclick="window.confirmSelection()">ÈñãÂßãÊ±∫È¨•</button>
        <button id="btn-back-menu" class="btn-small" style="margin-top:10px; border:none; background:transparent; color:#aaa; font-size:0.8rem;" onclick="window.resetGame()">ËøîÂõû</button>
    </div>

    <div id="game-msg"></div>

    <div id="game-ui">
        <button class="circle-btn home-btn" onclick="window.resetGame()" title="Âõû‰∏ªÈÅ∏ÂñÆ">üè†</button>
        
        <div id="top-announcer">
            <div id="timer">10</div>
            <div id="move-display">Ê∫ñÂÇô‰∏≠...</div>
        </div>
        <div id="status-log"></div>
        <div id="card-description"></div> <!-- Âç°ÁâåÊèèËø∞È°ØÁ§∫ÂçÄ -->

        <div id="bottom-ui-container">
            <div id="card-area">
                <div id="player-hp-card">
                    <div id="player-name-display" class="name-text">Â•ß‰∏ÅË±¨</div>
                    <div id="hp-line" class="hp-text">HP: 500/500</div>
                    <div id="fatigue-line" class="fatigue-text">Áñ≤Âãû: 0%</div>
                    <div id="rage-line" class="rage-text">ÊÄíÊ∞£: 0%</div>
                </div>
                <div id="card-0" class="card" onclick="window.selectCard(0)">Áâ©ÁêÜ‚öîÔ∏è</div>
                <div id="card-1" class="card" onclick="window.selectCard(1)">È≠îÊ≥ïü™Ñ</div>
                <div id="slot-2-btn" class="card" onclick="window.selectCard(2)">ÂèçÊìäüõ°Ô∏è</div>
                <div id="card-3" class="card" onclick="window.selectCard(3)">ÂèçÂ∞Ñüíé</div>
                <div id="defend-card" class="card" onclick="window.selectCard(4)">Èò≤Á¶¶üß±</div>
                <div id="super-card" class="card super" style="display:none;" onclick="window.selectCard(5)">Â•ßÁæ©üî•</div>
                <div id="oracle-btn-card" onclick="window.askOracle()">‚ú®</div>
            </div>
        </div>
    </div>

    <!-- ÊïôÂ≠∏Ê®°Âºè UI -->
    <div id="tutorial-ui">
        <div class="back-btn-container">
            <button id="btn-back-tut" class="btn-small" onclick="window.quitTutorial()">Âõû‰∏ªÈÅ∏ÂñÆ</button>
        </div>
        <div id="tutorial-desc">ÈªûÊìä‰∏ãÊñπÂúñÁ§∫ËßÄÁúãÊäÄËÉΩÊºîÁ§∫</div>
        <div class="tutorial-controls">
            <div class="card" onclick="window.demoAction(0)">Áâ©ÁêÜ‚öîÔ∏è</div>
            <div class="card" onclick="window.demoAction(1)">È≠îÊ≥ïü™Ñ</div>
            <div class="card" onclick="window.demoAction(2)">ÂèçÊìäüõ°Ô∏è</div>
            <div class="card" onclick="window.demoAction(3)">ÂèçÂ∞Ñüíé</div>
            <div class="card" onclick="window.demoAction(4)">Èò≤Á¶¶üß±</div>
            <div class="card super super-red" onclick="window.demoAction(5)">Áâ©Â•ßüî•</div>
            <div class="card super super-blue" onclick="window.demoAction(6)">È≠îÂ•ß‚ö°</div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const apiKey = ""; 
    const MAX_HP_ODIN = 500; 
    const MAX_HP_LOKI = 400;
    const TURN_TIME = 10;
    let BASE_CAM_Y = 280; let BASE_CAM_Z = 600;
    let DEFAULT_CAM_POS = new THREE.Vector3(0, BASE_CAM_Y, BASE_CAM_Z);
    const DEFAULT_LOOK_AT = new THREE.Vector3(0, 40, -20);
    
    // --- TRANSLATION SYSTEM ---
    let currentLang = 'zh-TW';
    const TRANSLATIONS = {
        'zh-TW': {
            title: "Ë±¨Á•ûÈªÉÊòè", singlePlayer: "ÂñÆ‰∫∫ÈÅäÊà≤", tutorial: "ËßíËâ≤ÊïôÂ≠∏",
            selectCharTitle: "ÈÅ∏Êìá‰Ω†ÁöÑË±¨Ë±¨Êà∞Â£´", selectPracticeChar: "ÈÅ∏ÊìáË¶ÅÁ∑¥ÁøíÁöÑËßíËâ≤",
            startBattle: "ÈñãÂßãÊ±∫È¨•", startPractice: "ÈñãÂßãÁâπË®ì",
            back: "ËøîÂõû", backMenu: "Âõû‰∏ªÈÅ∏ÂñÆ",
            odinName: "Â•ß‰∏ÅË±¨", odinDesc: "Èõ∑ÈúÜËàáÊ¶ÆËÄÄ",
            lokiName: "Ê¥õÂü∫Ë±¨", lokiDesc: "Ë©≠Ë®àËàáÈÆÆËÇâ",
            turnHint: "Ë´ãÈÅ∏Êìá‰∏ãÊñπÁöÑÂç°Áâå‰∏¶ÈªûÈÅ∏Â∞çÊâã", ready: "Ê∫ñÂÇô‰∏≠...",
            moveNames: ["Áâ©ÁêÜÊîªÊìä", "È≠îÊ≥ïÊîªÊìä", "ÂèçÊìä", "È≠îÊ≥ïÂèçÂ∞Ñ", "Èò≤Á¶¶", "ÁµÇÊ•µÂ•ßÁæ©"],
            cardNames: { 0: "Áâ©ÁêÜ‚öîÔ∏è", 1: "È≠îÊ≥ïü™Ñ", 2: "ÂèçÊìäüõ°Ô∏è", 3: "ÂèçÂ∞Ñüíé", 4: "Èò≤Á¶¶üß±", 5: "Â•ßÁæ©üî•", swap: "Á©∫ÈñìüåÄ" },
            swapSkill: "Á©∫ÈñìË™øÊèõ", counterSkill: "Èò≤Á¶¶ÂèçÊìä",
            targetLocked: "(ÁõÆÊ®ôÈéñÂÆö‰∏≠)", dead: "Ëä≠ÊØîQÂï¶", fatigue: "Áñ≤Âãû", rage: "ÊÄíÊ∞£",
            defendFatigue: "Èò≤Á¶¶Áñ≤Âãû‰∏≠", defend: "Èò≤Á¶¶", tired: "ÂäõÁõ°üß±",
            tutDesc: "ÈªûÊìä‰∏ãÊñπÂúñÁ§∫ËßÄÁúãÊäÄËÉΩÊºîÁ§∫", tutEnd: "ÊºîÁ§∫ÂÆåÁï¢„ÄÇË´ãÈÅ∏Êìá‰∏ã‰∏ÄÂÄãÊäÄËÉΩ„ÄÇ",
            tut0_odin: "„ÄêÂ≤°Ê†ºÂ∞ºÁàæÊñ¨„ÄëOdin ÊèÆËàûÁ•ûÊßçÈÄ≤Ë°åËøëÊà∞ÊîªÊìäÔºåÈÄ†ÊàêÁâ©ÁêÜÂÇ∑ÂÆ≥‰∏¶Á¥ØÁ©çÁ¥ÖËâ≤ÊÄíÊ∞£„ÄÇ",
            tut0_loki: "„ÄêÊªæÁêÉÊîªÊìä„ÄëLoki Â∞áËá™Â∑±ËÆäÊàêÁêÉÊíûÂêëÊïµ‰∫∫ÔºåÈÄ†ÊàêÁâ©ÁêÜÂÇ∑ÂÆ≥‰∏¶Á¥ØÁ©çÁ¥ÖËâ≤ÊÄíÊ∞£„ÄÇ",
            tut1_odin: "„ÄêÈõ∑ÈúÜËê¨Èàû„ÄëÂè¨ÂñöÈñÉÈõªÊîªÊìäÊïµ‰∫∫ÔºåÈÄ†ÊàêÈ≠îÊ≥ïÂÇ∑ÂÆ≥ÔºåÁ¥ØÁ©çËóçËâ≤ÊÄíÊ∞£„ÄÇ",
            tut1_loki: "„ÄêÈÆÆËÇâÊäïÊì≤„Äë‰∏üÂá∫‰∏ÄÂ°äÂ∑®Â§ßÁöÑËÇâÔºåÂ∞çÊïµ‰∫∫ÈÄ†ÊàêÈ≠îÊ≥ïÂÇ∑ÂÆ≥ÔºåÁ¥ØÁ©çËóçËâ≤ÊÄíÊ∞£„ÄÇËÇâÂ°äËêΩÂú∞ÊúÉÁàÜÁÇ∏ÔºÅ",
            tut2_odin: "„ÄêÈò≤Á¶¶ÂèçÊìä„ÄëÈÄ≤ÂÖ•Èò≤Á¶¶ÂßøÊÖãÔºåËã•ÂèóÂà∞„ÄåÁâ©ÁêÜÊîªÊìä„ÄçÂ∞áËá™ÂãïÂèçÊìä„ÄÇ",
            tut2_loki: "„ÄêÁ©∫ÈñìË™øÊèõ„Äë(ÁâπÊÆä) Áï∂ÂèóÂà∞Áâ©ÁêÜÊîªÊìäÊôÇÔºåÂ∞áËá™Â∑±ËàáÂè¶‰∏ÄÂÄãÊïµ‰∫∫‰∫§Êèõ‰ΩçÁΩÆÔºÅ(ÈúÄÊúâÂ§öÂÄãÁõÆÊ®ô)",
            tut3_odin: "„ÄêÈ≠îÊ≥ïÂèçÂ∞Ñ„ÄëËã•ÂèóÂà∞È≠îÊ≥ïÊîªÊìäÔºå‰ΩøÁî®Á•ûÂäõÂèçÂΩàÂÇ∑ÂÆ≥„ÄÇ",
            tut3_loki: "„ÄêÈ≠îÊ≥ïÂèçÂ∞Ñ„ÄëËã•ÂèóÂà∞È≠îÊ≥ïÊîªÊìäÔºåÂ∞áÂÇ∑ÂÆ≥ÂèçÂΩàÁµ¶Â∞çÊâã„ÄÇ",
            tut4: "„ÄêÁµïÂ∞çÈò≤Á¶¶„ÄëÂ§ßÂπÖÈôç‰ΩéÂÇ∑ÂÆ≥Ôºå‰ΩÜÂ¢ûÂä†Áñ≤ÂãûÂÄº„ÄÇÁñ≤ÂãûÈÅéÈ´ò‰∏ãÂõûÂêàÁÑ°Ê≥ïÈò≤Á¶¶ÔºÅ",
            tut5_odin: "„ÄêË´∏Á•ûÈªÉÊòè„Äë(Áâ©ÁêÜÂ•ßÁæ©) ÊÄíÊ∞£ÂÖ®Êªø(Á¥Ö)ÊôÇÁôºÂãïÔºåÊØÄÊªÖÊÄßÈÄ£ÊìäÔºÅ",
            tut5_loki: "„ÄêË©≠Ë®à„ÉªËÇâÂΩàÊà∞Ëªä„Äë(Áâ©ÁêÜÂ•ßÁæ©) ÊÄíÊ∞£ÂÖ®Êªø(Á¥Ö)ÊôÇÁôºÂãïÔºåÈÄ£Á∫åÊíûÊìäÊâÄÊúâÊïµ‰∫∫ÔºÅ",
            tut6_odin: "„ÄêÈõ∑Á•û‰πãÊÄí„Äë(È≠îÊ≥ïÂ•ßÁæ©) ÊÄíÊ∞£ÂÖ®Êªø(Ëóç)ÊôÇÁôºÂãïÔºåÂè¨ÂñöÊØÄÊªÖÊÄßÁöÑÈõ∑Êö¥ÔºÅ",
            tut6_loki: "„ÄêË©≠Ë®à„ÉªÂ§©ÈôçËÇâÈõ®„Äë(È≠îÊ≥ïÂ•ßÁæ©) ÊÄíÊ∞£ÂÖ®Êªø(Ëóç)ÊôÇÁôºÂãïÔºåÂè¨ÂñöÂ∑®ÂûãËÇâÂ°äËΩüÁÇ∏Â†¥Âú∞ÔºÅ",
            cardDescs: {
                0: "ÈÄ†ÊàêÁâ©ÁêÜÂÇ∑ÂÆ≥ÔºåÂ¢ûÂä†Á¥ÖËâ≤ÊÄíÊ∞£",
                1: "ÈÄ†ÊàêÈ≠îÊ≥ïÂÇ∑ÂÆ≥ÔºåÂ¢ûÂä†ËóçËâ≤ÊÄíÊ∞£",
                2: { "Odin": "ÂèóÂà∞Áâ©ÁêÜÊîªÊìäÊôÇËá™ÂãïÂèçÊìä", "Loki": "ÂèóÂà∞Áâ©ÁêÜÊîªÊìäÊôÇËàáÊïµ‰∫∫‰∫§Êèõ‰ΩçÁΩÆ" },
                3: "ÂèçÂΩàÂèóÂà∞ÁöÑÈ≠îÊ≥ïÂÇ∑ÂÆ≥",
                4: "Â§ßÂπÖÊ∏õÂÇ∑Ôºå‰ΩÜÂ¢ûÂä†Áñ≤ÂãûÂÄº",
                5: { "Odin": "Ê∂àËÄóÂÖ®ÈÉ®ÊÄíÊ∞£ÔºåÈÄ†ÊàêÊØÄÊªÖÊÄßÈÄ£Êìä", "Loki": "Ê∂àËÄóÂÖ®ÈÉ®ÊÄíÊ∞£ÔºåÂåñË∫´Êà∞ËªäË°ùÊíûÂÖ®Â†¥" }
            },
            logBlock: "ÊàêÂäüÈò≤Á¶¶", logCounter: "ÁöÑÂèçÊìäÂú®Â•ßÁæ©Èù¢ÂâçÂ§±Êïà‰∫ÜÔºÅ",
            logReflect: "ÁöÑÂèçÂ∞ÑÂú®Â•ßÁæ©Èù¢ÂâçÂ§±Êïà‰∫ÜÔºÅ", logHit: "ÁöÑÊîªÊìäÔºÅ",
            playerSuffix: " (Áé©ÂÆ∂)", cpuPrefix: "(CPU) ",
            tutorialName: "ÊïôÂ≠∏", dummyName: "ÂÅá‰∫∫", civilian: "Ë∑Ø‰∫∫",
            ragnarok: "Ë´∏Á•ûÁöÑÈªÉÊòèÂ∑≤Á∂ìÈôçËá®...", pigKing: "Ë±¨Ë±¨‰πãÁéãË™ïÁîü‰∫ÜÔºÅ",
            lockingTargets: "ÈéñÂÆöÁõÆÊ®ôÔºÅ"
        },
        'en-US': {
            title: "PIGNAROK", singlePlayer: "Single Player", tutorial: "Tutorial",
            selectCharTitle: "Select Your Warrior", selectPracticeChar: "Select Character",
            startBattle: "Start Battle", startPractice: "Start Training",
            back: "Back", backMenu: "Main Menu",
            odinName: "Odin", odinDesc: "Thunder & Glory",
            lokiName: "Loki", lokiDesc: "Tricks & Meat",
            turnHint: "Select a card below and tap an enemy", ready: "Ready...",
            moveNames: ["Melee", "Magic", "Counter", "Reflect", "Defend", "Ultimate"],
            cardNames: { 0: "Melee‚öîÔ∏è", 1: "Magicü™Ñ", 2: "Countüõ°Ô∏è", 3: "Reflüíé", 4: "Defüß±", 5: "Ultüî•", swap: "SwapüåÄ" },
            swapSkill: "Spatial Swap", counterSkill: "Counter",
            targetLocked: "(Target Locked)", dead: "Barbecued", fatigue: "Fatigue", rage: "Rage",
            defendFatigue: "Fatigued", defend: "Defend", tired: "Tiredüß±",
            tutDesc: "Tap icons below to see skill demos", tutEnd: "Demo finished. Select next skill.",
            tut0_odin: "[Gungnir Slash] Melee attack. Deals physical dmg, builds Red Rage.",
            tut0_loki: "[Ball Attack] Rolls into enemy. Deals physical dmg, builds Red Rage.",
            tut1_odin: "[Thunderstrike] Summons lightning. Deals magic dmg, builds Blue Rage.",
            tut1_loki: "[Meat Throw] Throws giant meat. Magic dmg, Blue Rage. Explodes on impact!",
            tut2_odin: "[Counter] Defensive stance. Auto-counters Melee attacks.",
            tut2_loki: "[Swap] (Special) Swaps position with another enemy when hit by Melee! (Needs multiple targets)",
            tut3_odin: "[Reflect] Reflects Magic damage back to attacker.",
            tut3_loki: "[Reflect] Bounces Magic damage back to attacker.",
            tut4: "[Defend] Reduces dmg significantly but adds Fatigue. Cannot defend if Fatigued!",
            tut5_odin: "[Ragnarok] (Phys Ult) Requires Max Red Rage. Devastating combo!",
            tut5_loki: "[Meat Chariot] (Phys Ult) Requires Max Red Rage. Smashes all enemies!",
            tut6_odin: "[Thor's Wrath] (Magic Ult) Requires Max Blue Rage. Summon storms!",
            tut6_loki: "[Meat Rain] (Magic Ult) Requires Max Blue Rage. Bombards the field!",
            cardDescs: {
                0: "Deals Physical DMG, builds Red Rage",
                1: "Deals Magic DMG, builds Blue Rage",
                2: { "Odin": "Counters Physical attacks automatically", "Loki": "Swaps position when hit by Physical attack" },
                3: "Reflects Magic damage back",
                4: "Reduces damage significantly, adds Fatigue",
                5: { "Odin": "Consumes Max Rage for devastating combo", "Loki": "Consumes Max Rage to smash all enemies" }
            },
            logBlock: "blocked", logCounter: "'s counter failed against Ultimate!",
            logReflect: "'s reflect failed against Ultimate!", logHit: "'s attack!",
            playerSuffix: " (P1)", cpuPrefix: "(CPU) ",
            tutorialName: "Teacher", dummyName: "Dummy", civilian: "Civilian",
            ragnarok: "Ragnarok has come...", pigKing: "The Pig King is born!",
            lockingTargets: "Locking Targets!"
        }
    };
    let CARD_NAMES = []; 

    let scene, camera, renderer, clock, raycaster;
    let players = [], gameState = 'IDLE', timeLeft = TURN_TIME, selectedSlot = -1, selectedTargetId = -1;
    let timerInterval, playerRage = { red: 0, blue: 0 };
    let selectedPlayerType = 'Odin';
    let isTutorialMode = false; let isTutorialSelection = false;
    let currentDemoId = 0; 
    const mouse = new THREE.Vector2();
    let animationId = null; 
    
    let activeLightnings = [], activeParticles = [], activeProjectiles = [];
    const SHARED_BOX_GEO = new THREE.BoxGeometry(1.2, 1.2, 1.2);

    const SoundEngine = { ctx: null, init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); }, play(type) { this.init(); const now = this.ctx.currentTime; const masterGain = this.ctx.createGain(); masterGain.connect(this.ctx.destination); masterGain.gain.setValueAtTime(0.4, now); const osc = this.ctx.createOscillator(); const env = this.ctx.createGain(); osc.connect(env); env.connect(masterGain); let dur = 0.3; switch(type) { case 'click': osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); env.gain.setValueAtTime(0.2, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.1); dur=0.1; break; case 'slash': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(450, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.2); env.gain.setValueAtTime(0.2, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'magic': osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.4); env.gain.setValueAtTime(0.12, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.4); dur=0.4; break; case 'hit': osc.type = 'sine'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now+0.15); env.gain.setValueAtTime(0.4, now); env.gain.linearRampToValueAtTime(0, now+0.15); dur=0.15; break; case 'counter': osc.type = 'square'; osc.frequency.setValueAtTime(1100, now); env.gain.setValueAtTime(0.1, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'super': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(90, now); env.gain.setValueAtTime(0.3, now); env.gain.exponentialRampToValueAtTime(0.001, now+1.2); dur=1.2; break; case 'bonk': osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); env.gain.setValueAtTime(0.8, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.2); dur=0.2; break; case 'ding': osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(2400, now + 0.05); env.gain.setValueAtTime(0.5, now); env.gain.exponentialRampToValueAtTime(0.001, now + 0.3); dur = 0.3; break; } osc.start(now); osc.stop(now+dur); setTimeout(() => { if(osc) osc.disconnect(); if(env) env.disconnect(); if(masterGain) masterGain.disconnect(); }, 2000); } };

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function move(obj, target, ms) { return new Promise(res => { const start = obj.position.clone(), t = performance.now(); function up() { let p = Math.min(1, (performance.now() - t) / ms); obj.position.lerpVectors(start, target, p); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    function adjustCameraForResponsive() { if (!camera || !renderer) return; const aspect = window.innerWidth / window.innerHeight; let targetY = BASE_CAM_Y; let targetZ = BASE_CAM_Z; if (aspect > 1.2) { targetY = 240; targetZ = 550; } else if (aspect < 0.6) { targetZ = 650; targetY = 320; } DEFAULT_CAM_POS.set(0, targetY, targetZ); if (gameState === 'WAITING' || gameState === 'IDLE' || gameState === 'TUTORIAL_IDLE') { camera.position.lerp(DEFAULT_CAM_POS, 0.1); camera.lookAt(DEFAULT_LOOK_AT); } }
    function resetCamera() { if (camera) { adjustCameraForResponsive(); camera.position.copy(DEFAULT_CAM_POS); camera.lookAt(DEFAULT_LOOK_AT); } }
    function log(m) { const b = document.getElementById('status-log'); if (b) { const d = document.createElement('div'); d.innerHTML = `> ${m}`; b.appendChild(d); b.scrollTop = b.scrollHeight; } }

    window.setLang = function(lang) {
        currentLang = lang;
        document.getElementById('lang-zh').classList.toggle('active', lang === 'zh-TW');
        document.getElementById('lang-en').classList.toggle('active', lang === 'en-US');
        updateText();
    };

    function updateText() {
        const t = TRANSLATIONS[currentLang];
        document.getElementById('menu-title').innerText = t.title;
        document.getElementById('btn-single-player').innerText = t.singlePlayer;
        document.getElementById('btn-tutorial').innerText = t.tutorial;
        document.getElementById('char-select-title').innerText = isTutorialSelection ? t.selectPracticeChar : t.selectCharTitle;
        document.getElementById('char-name-odin').innerText = t.odinName;
        document.getElementById('char-desc-odin').innerText = t.odinDesc;
        document.getElementById('char-name-loki').innerText = t.lokiName;
        document.getElementById('char-desc-loki').innerText = t.lokiDesc;
        document.getElementById('btn-start-battle').innerText = isTutorialSelection ? t.startPractice : t.startBattle;
        document.getElementById('btn-back-menu').innerText = t.back;
        document.getElementById('btn-back-tut').innerText = t.backMenu;
        document.getElementById('turn-hint').innerText = t.turnHint;
        document.getElementById('card-0').innerText = t.cardNames[0];
        document.getElementById('card-1').innerText = t.cardNames[1];
        document.getElementById('card-3').innerText = t.cardNames[3];
        document.getElementById('defend-card').innerText = t.cardNames[4];
        document.getElementById('super-card').innerText = t.cardNames[5];
        if (gameState === 'TUTORIAL_IDLE') { document.getElementById('tutorial-desc').innerText = t.tutDesc; }
        CARD_NAMES = t.moveNames;
        
        // Use spread syntax correctly to avoid mutation
        CARD_NAMES = [...t.moveNames]; 

        if (players.length > 0) {
            const p = players[0];
            const slot2 = document.getElementById('slot-2-btn');
            if (p.type === 'Loki') {
                slot2.innerText = t.cardNames.swap; 
                CARD_NAMES[2] = t.swapSkill;
            } else {
                slot2.innerText = t.cardNames[2];
                CARD_NAMES[2] = t.counterSkill; // Ensure Odin's counter name is set
            }
            const defBtn = document.getElementById('defend-card');
            if (p.fatigue >= 100) defBtn.innerText = t.tired; else defBtn.innerText = t.cardNames[4];
            players.forEach(p => p.refreshLabel());
        }
        // Refresh description if a card is selected
        if (selectedSlot !== -1 && players.length > 0) {
            showCardDescription(selectedSlot);
        }
        if (players.length > 0 && players[0]) {
             document.getElementById('player-name-display').innerText = players[0].getDisplayName();
        }
    }

    function showCardDescription(index) {
        const descEl = document.getElementById('card-description');
        const t = TRANSLATIONS[currentLang];
        const p = players[0];
        let desc = "";

        if (!p) return;

        if (index === 2 || index === 5) {
            // These indices depend on character type
            desc = t.cardDescs[index][p.type];
        } else {
            desc = t.cardDescs[index];
        }

        descEl.innerText = desc;
        descEl.style.opacity = 1;
    }

    function hideCardDescription() {
        const descEl = document.getElementById('card-description');
        descEl.style.opacity = 0;
    }

    function updateHPUI() {
        const t = TRANSLATIONS[currentLang];
        const p = players[0]; if (!p) return;

        // Only update DOM UI if not in tutorial mode
        if (!isTutorialMode) {
            const hpLine = document.getElementById('hp-line'), fatLine = document.getElementById('fatigue-line');
            const rageLine = document.getElementById('rage-line'), defBtn = document.getElementById('defend-card'), superBtn = document.getElementById('super-card');
            if(hpLine) hpLine.innerText = `HP: ${p.hp}/${p.maxHP}`;
            if(fatLine) { fatLine.innerText = `${t.fatigue}: ${p.fatigue}%`; fatLine.style.color = p.fatigue >= 100 ? "#ff0000" : "#ffaa00"; }
            const curRage = Math.floor(Math.max(playerRage.red, playerRage.blue));
            if(rageLine) { rageLine.innerText = `${t.rage}: ${curRage}%`; rageLine.style.color = playerRage.red > playerRage.blue ? "#ff5555" : (playerRage.blue > playerRage.red ? "#55ccff" : "#ffaa00"); }
            if (defBtn) { if (p.fatigue >= 100) { defBtn.classList.add('disabled'); defBtn.innerText = t.tired; } else { defBtn.classList.remove('disabled'); defBtn.innerText = t.cardNames[4]; } }
            
            if (superBtn) {
                superBtn.className = "card super"; 
                if (curRage >= 99) {
                    superBtn.style.display = 'flex';
                    if (playerRage.blue > playerRage.red) { superBtn.classList.add('super-blue'); superBtn.innerText = t.cardNames[5]; }
                    else { superBtn.classList.add('super-red'); superBtn.innerText = t.cardNames[5]; }
                } else { superBtn.style.display = 'none'; }
            }
        }

        // Always update 3D labels (HP bars above heads) - Loop must run in all modes
        players.forEach(pl => { 
            if (pl.selectionRing) pl.selectionRing.visible = (selectedTargetId === pl.id); 
            if (pl.updateLabel) pl.updateLabel(); 
            if (pl.brokenShieldIcon) { pl.brokenShieldIcon.visible = pl.showBrokenShield; }
        });
    }

    function gainRage(p, isRed, amt) { const r = (p.id === 0) ? playerRage : p.rage; if (isRed) { r.blue = 0; r.red = Math.min(100, r.red + amt); } else { r.red = 0; r.blue = Math.min(100, r.blue + amt); } updateHPUI(); if(p.updateLabel) p.updateLabel(); }
    function loseRage(p, isRed) { const r = (p.id === 0) ? playerRage : p.rage; if (isRed) r.red = Math.max(0, r.red - 30); else r.blue = Math.max(0, r.blue - 30); }
    function focusOnAction(char1, char2 = null, dur = 600) { if (!char1) return; let tCenter, camTarget; if (char2) { const p1 = char1.group.position.clone(), p2 = char2.group.position.clone(); const d = p1.distanceTo(p2); tCenter = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5); const zoomFactor = (window.innerWidth / window.innerHeight) > 1 ? 0.6 : 0.45; camTarget = tCenter.clone().add(new THREE.Vector3(0, 250 + d * zoomFactor, 450 + d * 0.85)); } else { tCenter = char1.group.position.clone(); camTarget = tCenter.clone().add(new THREE.Vector3(0, 240, 350)); } return new Promise(res => { let sPos = camera.position.clone(); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / dur); camera.position.lerpVectors(sPos, camTarget, p); camera.lookAt(tCenter); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    async function cinematicIntro(attacker, skillName) { const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(attacker.group.quaternion); const focusPos = attacker.group.position.clone().add(forward.multiplyScalar(150)); focusPos.y += 20; await new Promise(res => { let sPos = camera.position.clone(); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 400); camera.position.lerpVectors(sPos, focusPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); const moveDisplay = document.getElementById('move-display'); moveDisplay.innerText = skillName; moveDisplay.style.opacity = "1"; SoundEngine.play('click'); await sleep(500); return new Promise(res => { let sPos = camera.position.clone(); let zoomOutPos = attacker.group.position.clone().add(new THREE.Vector3(0, 240, 350)); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 1000); camera.position.lerpVectors(sPos, zoomOutPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    // UI Sprite: depthTest false + high renderOrder ensures it draws on top of 3D models
    function createUnitUISprite() { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 256; const texture = new THREE.CanvasTexture(canvas); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false })); sprite.scale.set(12, 6, 1); sprite.renderOrder = 999; return { sprite, canvas, ctx, texture }; }
    
    function createBrokenShieldTexture() { const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d'); const t = TRANSLATIONS[currentLang]; ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.moveTo(30, 30); ctx.lineTo(226, 30); ctx.quadraticCurveTo(226, 150, 128, 240); ctx.quadraticCurveTo(30, 150, 30, 30); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#880000'; ctx.beginPath(); ctx.moveTo(50, 50); ctx.lineTo(206, 50); ctx.quadraticCurveTo(206, 140, 128, 220); ctx.quadraticCurveTo(50, 140, 50, 50); ctx.closePath(); ctx.fill(); ctx.globalCompositeOperation = 'destination-out'; ctx.lineWidth = 30; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(140, 10); ctx.lineTo(100, 90); ctx.lineTo(160, 140); ctx.lineTo(110, 250); ctx.stroke(); ctx.globalCompositeOperation = 'source-over'; ctx.font = 'bold 36px "Microsoft JhengHei", sans-serif'; ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 4; if(currentLang === 'zh-TW') { ctx.fillText('Èò≤Á¶¶', 128, 110); ctx.fillText('Áñ≤Âãû‰∏≠', 128, 150); } else { ctx.font = 'bold 28px "Arial", sans-serif'; ctx.fillText('FATIGUED', 128, 130); } return new THREE.CanvasTexture(canvas); }
    function createTextSprite(text) { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 128; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(20, 20, 472, 88); ctx.font = 'bold 50px "Microsoft JhengHei", Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#ff99cc'; ctx.fillText(text, 256, 85); const texture = new THREE.CanvasTexture(canvas); return new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true })); }
    function createShockwave(pos, color) { const m = new THREE.Mesh(new THREE.RingGeometry(1, 2, 64), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1, side: THREE.DoubleSide })); m.position.copy(pos); m.rotation.x = Math.PI / 2; const expand = () => { m.scale.x += 4; m.scale.y += 4; m.material.opacity -= 0.05; if(m.material.opacity > 0) requestAnimationFrame(expand); else if(m.parent) scene.remove(m); }; expand(); return m; }
    
    // Updated: Returns the group so it can be added to scene instantly
    function createExplosion(pos, scale=1.0) { 
        const g = new THREE.Group(); 
        const shock = createShockwave(pos, 0xffaa00); 
        g.add(shock); 
        g.position.copy(pos); // Set group position
        shock.position.set(0,0,0); // Reset shock local pos
        
        const count = Math.floor(40 * scale); 
        for(let i=0; i<count; i++) { 
            activeParticles.push(new HitParticle(pos.clone(), i % 2 === 0 ? 0xff4400 : 0xffff00)); 
        } 
        g.scale.set(scale, scale, scale); 
        SoundEngine.play('super'); 
        scene.add(g); // Add directly to scene
        return g; 
    }

    function applyKnockback(char, sourcePos) { if(!sourcePos) return; const dir = char.group.position.clone().sub(sourcePos).normalize(); dir.y = 0; const originalPos = char.group.position.clone(); const backPos = originalPos.clone().add(dir.multiplyScalar(25)); move(char.group, backPos, 100).then(() => { sleep(50).then(() => move(char.group, originalPos, 200)); }); }
    function createMagnetModel() { const group = new THREE.Group(); const redMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }), blueMat = new THREE.MeshPhongMaterial({ color: 0x0000ff }), silverMat = new THREE.MeshPhongMaterial({ color: 0xcccccc }); const bar1 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), redMat); bar1.position.set(-3, 3, 0); group.add(bar1); const bar2 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), blueMat); bar2.position.set(3, 3, 0); group.add(bar2); const connector = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 2), silverMat); connector.position.set(0, 0, 0); group.add(connector); group.scale.set(2,2,2); return group; }
    function createMeatModelShared(scale = 1) { const g = new THREE.Group(); const meat = new THREE.Mesh(new THREE.BoxGeometry(3.5 * scale, 2.5 * scale, 2.5 * scale), new THREE.MeshPhongMaterial({ color: 0xaa2222 })); meat.position.y = 1 * scale; meat.castShadow = true; g.add(meat); const bone = new THREE.Mesh(new THREE.BoxGeometry(6 * scale, 0.6 * scale, 0.6 * scale), new THREE.MeshPhongMaterial({ color: 0xeeeeee })); bone.position.y = 1 * scale; bone.castShadow = true; g.add(bone); const cutMat = new THREE.MeshBasicMaterial({ color: 0xffaaaa }); const cL = new THREE.Mesh(new THREE.PlaneGeometry(2.3 * scale, 2.3 * scale), cutMat), cR = cL.clone(); cL.position.set(-1.76 * scale, 1 * scale, 0); cL.rotation.y = Math.PI/2; cR.position.set(1.76 * scale, 1 * scale, 0); cR.rotation.y = Math.PI/2; g.add(cL, cR); return g; }
    function createBatModel() { const group = new THREE.Group(); const mat = new THREE.MeshPhongMaterial({ color: 0x8B4513, specular: 0x222222 }); const knob = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1, 16), mat); knob.position.y = 0.5; group.add(knob); const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.3, 8, 16), mat); handle.position.y = 5; group.add(handle); const taper = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.35, 10, 16), mat); taper.position.y = 14; group.add(taper); const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 10, 16), mat); barrel.position.y = 24; group.add(barrel); const cap = new THREE.Mesh(new THREE.SphereGeometry(0.9, 16, 16, 0, Math.PI*2, 0, Math.PI * 0.5), mat); cap.position.y = 29; group.add(cap); group.scale.set(4.8, 4.8, 4.8); return group; }
    function getRandomTarget(sid) { const os = players.filter(p => p.id !== sid && p.alive); return os.length ? os[Math.floor(Math.random()*os.length)].id : -1; }

    class HitParticle { constructor(pos, color) { const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true }); this.mesh = new THREE.Mesh(SHARED_BOX_GEO, mat); this.mesh.position.copy(pos); const a = Math.random() * Math.PI * 2, s = 5 + Math.random() * 5; this.velocity = new THREE.Vector3(Math.cos(a) * s, 4 + Math.random() * 6, Math.sin(a) * s); this.life = 1.0; scene.add(this.mesh); } update(dt) { this.mesh.position.add(this.velocity.clone().multiplyScalar(dt)); this.velocity.y -= 15 * dt; this.life -= dt * 1.5; this.mesh.material.opacity = this.life; if (this.life <= 0) { if(this.mesh.parent) scene.remove(this.mesh); if(this.mesh.material) this.mesh.material.dispose(); return false; } return true; } }
    class OptimizedLightningBolt { constructor(s, e, c=0x00ffff) { this.s=s.clone(); this.e=e.clone(); this.c=c; this.l=6; this.g=new THREE.Group(); scene.add(this.g); this.m=new THREE.MeshBasicMaterial({color:c,transparent:true}); this.gen(); } gen() { while(this.g.children.length>0){this.g.remove(this.g.children[0]);} const pts=[]; for(let i=0;i<=8;i++){ let p=new THREE.Vector3().lerpVectors(this.s,this.e,i/8); if(i>0&&i<8){ p.addScalar((Math.random()-0.5)*20); } pts.push(p); } for(let i=0;i<pts.length-1;i++){ const d=pts[i].distanceTo(pts[i+1]); const m=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,d),this.m); m.position.lerpVectors(pts[i],pts[i+1],0.5); m.lookAt(pts[i+1]); this.g.add(m); } this.m.color.setHex(Math.random()>0.4?0xffffff:this.c); } update() { this.l--; if(this.l>0){this.gen();return true;} else{scene.remove(this.g); return false;} } }
    class SuperAura { constructor(p) { this.active=false; this.g=new THREE.Group(); this.g.position.y=2.5; p.add(this.g); this.core=new THREE.Mesh(new THREE.IcosahedronGeometry(3,1),new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.3,blending:2})); this.g.add(this.core); this.spikes=new THREE.Mesh(new THREE.IcosahedronGeometry(3.5,0),new THREE.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.4,blending:2})); this.g.add(this.spikes); this.g.visible=false; this.t=0; } activate(r) { this.active=true; this.g.visible=true; const c=r?0xff3300:0x0088ff; this.spikes.material.color.setHex(c); this.core.material.color.setHex(r?0xffffaa:0xaaffff); } deactivate() { this.active=false; this.g.visible=false; } update(dt) { if(!this.active)return; this.t+=dt*15; const s=1+Math.sin(this.t)*0.05; this.spikes.scale.set(s,s,s); this.spikes.rotation.y+=dt*3; } }
    class MeatDrop { constructor(t,s=1, isSuper=false){this.m=createMeatModelShared(s);this.m.position.set(t.x,t.y+400,t.z);this.ty=t.y;this.v=0;this.e=false;this.isSuper=isSuper;scene.add(this.m);} update(dt){if(this.e)return false;this.v+=900*dt;this.m.position.y-=this.v*dt;this.m.rotation.y+=dt*5;if(this.m.position.y<=this.ty){this.m.position.y=this.ty;this.expl();return false;}return true;} expl(){if(this.e)return;this.e=true;const scale=this.isSuper?3.0:1.0;createExplosion(this.m.position,scale);if(this.m.parent)scene.remove(this.m);} }
    class ParabolicMeatProjectile { 
        constructor(s,e){
            this.s=s.clone();this.e=e.clone();
            // Loki Meat 50% larger -> 3.5 * 1.5 ~ 5.2 -> Let's make it 7.0 for clear visibility
            this.m=createMeatModelShared(7.0);
            scene.add(this.m);this.p=0;
        } 
        update(dt){
            if(this.p>=1){
                if(this.m.parent)scene.remove(this.m);
                // Trigger explosion on hit, scale 3.0 (same as ultra)
                createExplosion(this.m.position, 3.0); 
                return false;
            }
            this.p+=dt/0.8;
            const c=new THREE.Vector3().lerpVectors(this.s,this.e,this.p);
            c.y+=Math.sin(this.p*Math.PI)*150;
            this.m.position.copy(c);
            this.m.rotation.x+=dt*10;
            return true;
        } 
    }

    class Odin {
        constructor(cfg) {
            this.id = cfg.id; this.name = cfg.name; this.type = cfg.type || 'Odin';
            this.maxHP = (this.type === 'Loki' ? MAX_HP_LOKI : MAX_HP_ODIN);
            this.hp = this.maxHP; this.alive = true; this.rage = { red: 0, blue: 0 }; 
            this.fatigue = 0; 
            this.defendHitCount = 0; 
            this.showBrokenShield = false; 
            
            this.action = { card: -1, target: -1, selectionTime: 0 }; this.targetQuaternion = null;
            this.group = new THREE.Group(); this.group.position.set(cfg.x, cfg.y, cfg.z);
            this.group.userData = { isCharacter: true, playerId: cfg.id }; this.group.scale.set(8, 8, 8);
            this.aura = new SuperAura(this.group);
            this.ballRotationMultiplier = 1.0; 

            // Hidden hitbox for easier selection on mobile
            const hitGeo = new THREE.BoxGeometry(14, 25, 14); 
            const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            this.hitBox = new THREE.Mesh(hitGeo, hitMat);
            this.hitBox.position.y = 5;
            this.group.add(this.hitBox);

            const uiData = createUnitUISprite(); this.uiSprite = uiData.sprite; this.uiCtx = uiData.ctx; this.uiTexture = uiData.texture;
            this.uiSprite.position.y = 8.5; this.group.add(this.uiSprite);
            
            const shieldTex = createBrokenShieldTexture();
            const shieldMat = new THREE.SpriteMaterial({ map: shieldTex, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false }); // Added depthTest false
            this.brokenShieldIcon = new THREE.Sprite(shieldMat);
            this.brokenShieldIcon.scale.set(8, 8, 1);
            this.brokenShieldIcon.position.set(0, 14, 0); 
            this.brokenShieldIcon.renderOrder = 998; // Ensure on top but below HP bar
            this.brokenShieldIcon.visible = false;
            this.group.add(this.brokenShieldIcon);

            this.labelSprite = createTextSprite(this.getDisplayName());

            this.labelSprite.position.y = -3.5; this.labelSprite.scale.set(10, 2.5, 1); this.group.add(this.labelSprite);
            this.modelContainer = new THREE.Group(); this.group.add(this.modelContainer);
            const bodyColor = (this.type === 'Loki' ? 0x0a4a0a : 0xffcc00);
            this.body = new THREE.Mesh(new THREE.BoxGeometry(2.1, 2, 2.5), new THREE.MeshPhongMaterial({ color: bodyColor }));
            this.body.position.y = 1; this.body.castShadow = true; this.modelContainer.add(this.body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.8, 1.6), new THREE.MeshPhongMaterial({ color: 0xffdbac }));
            head.position.set(0, 2.5, 0.5); head.castShadow = true; this.modelContainer.add(head);
            this.snout = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.6), new THREE.MeshPhongMaterial({ color: 0xffaaaa }));
            this.snout.position.set(0, 2.3, 1.35); this.snout.castShadow = true; this.modelContainer.add(this.snout);
            const nL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), new THREE.MeshBasicMaterial({color:0x000000})), nR = nL.clone();
            nL.position.set(-0.25, 0.1, 0.35); nR.position.set(0.25, 0.1, 0.35); this.snout.add(nL, nR);
            const earL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.2), new THREE.MeshPhongMaterial({color: 0xffaaaa})), earR = earL.clone();
            earL.position.set(-1.0, 3.2, 0.5); earL.rotation.z = 0.6; earR.position.set(1.0, 3.2, 0.5); earR.rotation.z = -0.6;
            earL.castShadow = true; earR.castShadow = true; this.modelContainer.add(earL, earR);
            
            if (this.type === 'Loki') {
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d'); const cols = ['#ff3333', '#33ff33', '#ffffff', '#3333ff']; 
                for(let i=0; i<4; i++) for(let j=0; j<4; j++) { ctx.fillStyle = cols[(i + j) % 4]; ctx.fillRect(i * 64, j * 64, 64, 64); ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(i * 64, j * 64, 64, 64); }
                const ballTex = new THREE.CanvasTexture(canvas); ballTex.wrapS = ballTex.wrapT = THREE.RepeatWrapping; ballTex.repeat.set(2, 2);
                this.ball = new THREE.Mesh(new THREE.SphereGeometry(1.4, 16, 12), new THREE.MeshPhongMaterial({ map: ballTex }));
                this.ball.position.y = -0.4; this.ball.castShadow = true; this.modelContainer.add(this.ball);
                this.modelContainer.position.y = 1.4;
            }

            this.weaponGroup = new THREE.Group();
            if (this.type === 'Odin') {
                const shape = new THREE.Shape();
                shape.moveTo(0, 0); shape.lineTo(0.5, 2); shape.lineTo(-0.2, 1.8); shape.lineTo(0.4, 3.5);
                shape.lineTo(-0.3, 3.2); shape.lineTo(0.6, 6); shape.lineTo(-0.1, 3.8); shape.lineTo(0.5, 4.2);
                shape.lineTo(-0.1, 2.2); shape.lineTo(0.4, 2.5); shape.lineTo(0, 0);
                this.weaponMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.3, bevelEnabled: false }), new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffd700, emissiveIntensity: 2 }));
                this.weaponMesh.position.set(-0.2, -1, 0); this.weaponMesh.castShadow = true; this.weaponGroup.add(this.weaponMesh); 
            }
            this.weaponGroup.position.set(1.5, 1.2, 0.5); this.weaponGroup.rotation.x = -Math.PI/4; this.modelContainer.add(this.weaponGroup);
            this.hexShield = new THREE.Group();
            const hexColor = (this.type === 'Loki' ? 0xff0000 : 0x00ffff);
            const hexStar = new THREE.Mesh(this.createStarGeometry(), new THREE.MeshBasicMaterial({ color: hexColor, transparent: true, opacity: 0.6, side: THREE.DoubleSide }));
            this.hexShield.add(hexStar); 
            for (let i = 0; i < 6; i++) {
                const rune = this.createRuneLine(), angle = (i / 6) * Math.PI * 2;
                rune.position.set(Math.cos(angle) * 3.5, Math.sin(angle) * 3.5, 0.1); rune.rotation.z = angle; this.hexShield.add(rune);
            }
            const centralRune = this.createAlgizRune(); centralRune.scale.set(2, 2, 2); this.hexShield.add(centralRune);
            this.hexShield.position.set(0, 3, 3); this.hexShield.visible = false; this.group.add(this.hexShield);
            this.meatBlock = createMeatModelShared(); this.meatBlock.visible = false; this.group.add(this.meatBlock);
            this.selectionRing = new THREE.Mesh(new THREE.TorusGeometry(5, 0.4, 16, 64), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.9 }));
            this.selectionRing.rotation.x = Math.PI/2; this.selectionRing.position.y = -1.5; this.selectionRing.visible = false; this.group.add(this.selectionRing);
            
            this.targetLabel = createTextSprite(TRANSLATIONS[currentLang].targetLocked);
            this.targetLabel.scale.set(6, 1.5, 1);
            this.targetLabel.position.y = -6;
            this.targetLabel.visible = false;
            this.group.add(this.targetLabel);

            scene.add(this.group); this.face(new THREE.Vector3(0,cfg.y,0)); this.updateLabel();
        }

        getDisplayName() {
             const t = TRANSLATIONS[currentLang];
             if (isTutorialMode) {
                return (this.id === 0) ? t.tutorialName : (this.id === 2 ? t.civilian : t.dummyName);
             } else {
                 let baseName = (this.type === 'Odin') ? t.odinName : t.lokiName;
                 if (this.id === 0) return `${baseName}${t.playerSuffix}`;
                 else return `${t.cpuPrefix}${baseName}`;
             }
        }

        refreshLabel() {
            if(this.labelSprite) {
                this.labelSprite.material.map.dispose();
                const newTexture = createTextSprite(this.getDisplayName()).material.map;
                this.labelSprite.material.map = newTexture;
            }
            if(this.brokenShieldIcon) {
                this.brokenShieldIcon.material.map.dispose();
                this.brokenShieldIcon.material.map = createBrokenShieldTexture();
            }
            if(this.targetLabel) {
                 this.targetLabel.material.map.dispose();
                 this.targetLabel.material.map = createTextSprite(TRANSLATIONS[currentLang].targetLocked).material.map;
            }
        }
        
        createStarGeometry() { const s = new THREE.Shape(); const o=5.5, n=2.8; for(let i=0; i<12; i++){ const a=(i/12)*Math.PI*2, r=(i%2===0)?o:n; if(i===0) s.moveTo(Math.cos(a)*r, Math.sin(a)*r); else s.lineTo(Math.cos(a)*r, Math.sin(a)*r); } s.closePath(); return new THREE.ShapeGeometry(s); }
        createRuneLine() { const pts = [new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0.5, 0, 0), new THREE.Vector3(0, 0.5, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffffff })); }
        createAlgizRune() { const pts = [new THREE.Vector3(0, -0.8, 0), new THREE.Vector3(0, 0.8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-0.6, 0.6, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0.6, 0.6, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })); }
        
        updateLabel() {
            if (!this.uiCtx) return; 
            const ctx = this.uiCtx; 
            ctx.clearRect(0, 0, 512, 256);
            const t = TRANSLATIONS[currentLang];
            
            if (!this.alive) { 
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; 
                ctx.fillRect(50, 40, 412, 160); 
                ctx.font = 'bold 80px Arial'; 
                ctx.textAlign = 'center'; 
                ctx.fillStyle = '#ff99cc'; 
                ctx.fillText(t.dead, 256, 150); 
                this.uiTexture.needsUpdate = true; 
                return; 
            }
            
            // REMOVED isTutorialMode check -> ALWAYS DRAW
            const r = (this.id===0 ? playerRage : this.rage), u = Math.floor(Math.max(r.red, r.blue));
            
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; 
            ctx.fillRect(50, 40, 412, 160); 
            ctx.font = 'bold 36px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.fillStyle = 'white'; 
            ctx.fillText(`HP: ${this.hp}/${this.maxHP}  ${t.rage}: ${u}%`, 256, 85);
            
            ctx.fillStyle = '#1a1a1a'; 
            ctx.fillRect(80, 110, 352, 20); 
            ctx.fillStyle = '#2ecc71'; 
            ctx.fillRect(80, 110, 352 * (this.hp/this.maxHP), 20);
            
            ctx.fillStyle = '#1a1a1a'; 
            ctx.fillRect(80, 145, 352, 15); 
            ctx.fillStyle = (r.red > r.blue) ? '#ff5555' : (r.blue > r.red ? '#55ccff' : '#ffaa00');
            ctx.fillRect(80, 145, 352 * (u/100), 15); 
            
            this.uiTexture.needsUpdate = true;
        }

        face(pos) { if (!this.alive) return; const lp = pos.clone(); lp.y = this.group.position.y; const dummy = new THREE.Object3D(); dummy.position.copy(this.group.position); dummy.lookAt(lp); this.targetQuaternion = dummy.quaternion.clone(); }
        takeDamage(amt, type = 0, sourcePos = null) { 
            this.hp = Math.max(0, this.hp - Math.floor(amt)); SoundEngine.play('hit');
            const pColor = (type === 0) ? 0xffaa00 : (type === 1 ? 0x00ffff : 0xff0044);
            for(let i=0; i<15; i++) activeParticles.push(new HitParticle(this.group.position.clone().add(new THREE.Vector3(0, 10, 0)), pColor));
            if (sourcePos) { applyKnockback(this, sourcePos); }
            if (this.hp <= 0 && this.alive) { this.alive = false; this.modelContainer.visible = false; this.meatBlock.visible = true; log(`${this.name} ` + TRANSLATIONS[currentLang].dead); }
            this.updateLabel(); updateHPUI();
        }
    }

    function calcDamage(a, t, type, isSuper = false, skipFatigue = false) {
        if (!t || !t.alive) return;
        const txt = TRANSLATIONS[currentLang];
        let dmg = (a.type === 'Loki') ? (type === 0 ? (isSuper ? 70 : 45) : (isSuper ? t.maxHP*0.5 : 65)) : (type === 0 ? (isSuper ? 60 : 40) : (isSuper ? t.maxHP*0.5 : 50));
        if (isSuper) {
            createExplosion(t.group.position.clone().add(new THREE.Vector3(0, 15, 0)), 2.5);
            if (type === 0 && t.action.card === 2) log(`${t.name} ` + txt.logCounter);
            if (type === 1 && t.action.card === 3) log(`${t.name} ` + txt.logReflect);
        } else {
            if (type === 0 && t.action.card === 2) { 
                if (t.type === 'Loki') return; 
                loseRage(a, true); a.takeDamage(65, 0, t.group.position); if (t.type === 'Odin') gainRage(t, true, 20); return; 
            }
            if (type === 1 && t.action.card === 3) { 
                loseRage(a, false); a.takeDamage(Math.floor(dmg*0.8), 2, t.group.position); gainRage(t, false, 20); return; 
            }
        }
        if (t.action.card === 4) { 
            if (!skipFatigue) { 
                t.defendHitCount++; 
                let fatigueAdd = 0; 
                if (t.defendHitCount === 2) fatigueAdd = 20; 
                else if (t.defendHitCount > 2) fatigueAdd = 10; 
                
                if (isSuper) fatigueAdd += 15;

                if (fatigueAdd > 0) t.fatigue = Math.min(150, t.fatigue + fatigueAdd); 
            } 
            t.blockedInTurn = true; SoundEngine.play('ding'); 
            log(`${t.name} ` + txt.logBlock + ` ${a.name} ` + txt.logHit); updateHPUI(); return; 
        }
        loseRage(t, type === 0); t.takeDamage(dmg, type, a.group.position); gainRage(a, type === 0, 35);
    }

    async function performAttack(attacker, target, type) { 
        if (!attacker || !target) return;
        const tp = target.group.position.clone(), orig = attacker.group.position.clone(); 
        
        if (type === 0 && target.action.card === 2 && target.type === 'Odin') { 
            const strikePos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); 
            await move(attacker.group, strikePos, 200); SoundEngine.play('magic'); target.group.visible = false; 
            const moveDisplay = document.getElementById('move-display'); moveDisplay.innerText = "Êâì‰Ω†ÁöÑÂ±ÅËÇ°ÔºÅ"; moveDisplay.style.opacity = "1"; 
            const behindPos = attacker.group.position.clone().add(target.group.position.clone().sub(attacker.group.position).normalize().multiplyScalar(-45)); 
            target.group.position.copy(behindPos); target.face(attacker.group.position); target.group.visible = true; 
            target.weaponGroup.rotation.z = 1.8; SoundEngine.play('counter'); await sleep(300); 
            calcDamage(attacker, target, 0); gainRage(target, true, 20); await sleep(500); 
            target.weaponGroup.rotation.z = 0; moveDisplay.style.opacity = "0"; 
            await move(attacker.group, orig, 400); target.group.position.copy(tp); target.face(attacker.group.position); 
            return; 
        } 
        
        if (type === 0 && target.action.card === 2 && target.type === 'Loki') { 
            const victims = players.filter(p => p && p.alive && p.id !== target.id && p.id !== attacker.id); 
            if (victims.length >= 1) { 
                log(`${target.name} Swap!`); 
                const victim = victims[Math.floor(Math.random()*victims.length)]; 
                const moveDisplay = document.getElementById('move-display'); moveDisplay.innerText = "Swap!"; moveDisplay.style.opacity = "1"; await sleep(800); 
                const lokiOrigPos = target.group.position.clone(), victimOrigPos = victim.group.position.clone(); 
                const magnet = createMagnetModel(); magnet.position.copy(target.group.position).add(new THREE.Vector3(0, 15, 10)); scene.add(magnet); 
                SoundEngine.play('magic'); moveDisplay.innerText = "!!!"; 
                const backDir = target.group.position.clone().sub(attacker.group.position).normalize(); 
                const backPos = lokiOrigPos.clone().add(backDir.multiplyScalar(40)); 
                await Promise.all([move(victim.group, lokiOrigPos, 1200), move(target.group, backPos, 1200)]); 
                moveDisplay.style.opacity = "0"; 
                const strikePos = lokiOrigPos.clone().add(orig.clone().sub(lokiOrigPos).normalize().multiplyScalar(45)); 
                if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 10.0; await sleep(600); await move(attacker.group, strikePos, 150); } 
                else { await move(attacker.group, strikePos, 250); attacker.weaponGroup.rotation.z = 0.8; } 
                SoundEngine.play(attacker.type === 'Loki' ? 'hit' : 'slash'); loseRage(attacker, true); 
                let dmg = (attacker.type === 'Loki') ? (Math.floor(Math.random() * 21) + 35) : (Math.floor(Math.random() * 21) + 30); 
                victim.takeDamage(dmg, 0, attacker.group.position); await sleep(500); 
                if (attacker.type === 'Odin') attacker.weaponGroup.rotation.z = 0; if (attacker.type === 'Loki') attacker.ballRotationMultiplier = 1.0; 
                await move(attacker.group, orig, 500); scene.remove(magnet); 
                await Promise.all([move(target.group, lokiOrigPos, 1200), move(victim.group, victimOrigPos, 1200)]); 
                return; 
            } 
        } 
        
        if (type === 0) { 
            if (attacker.type === 'Loki') { 
                attacker.ballRotationMultiplier = 10.0; await sleep(600); 
                const sPos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); 
                await move(attacker.group, sPos, 150); SoundEngine.play('hit'); 
                calcDamage(attacker, target, 0); await sleep(300); 
                attacker.ballRotationMultiplier = 1.0; await move(attacker.group, orig, 500); 
            } else { 
                const sPos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); 
                await move(attacker.group, sPos, 250); attacker.weaponGroup.rotation.z = 0.8; 
                SoundEngine.play('slash'); calcDamage(attacker, target, 0); await sleep(300); 
                attacker.weaponGroup.rotation.z = 0; await move(attacker.group, orig, 500); 
            } 
        } else { 
            if (attacker.type === 'Loki') { 
                const throwStart = attacker.group.position.clone().add(new THREE.Vector3(0, 30, 0)), throwEnd = target.group.position.clone().add(new THREE.Vector3(0, 20, 0)); 
                activeProjectiles.push(new ParabolicMeatProjectile(throwStart, throwEnd)); 
                SoundEngine.play('magic'); await sleep(800); 
            } else { 
                const mouthPos = attacker.group.position.clone().add(new THREE.Vector3(0, 25, 0)); 
                const burst = setInterval(() => { activeLightnings.push(new OptimizedLightningBolt(mouthPos, target.group.position.clone().add(new THREE.Vector3(0,25,0)))); SoundEngine.play('magic'); }, 150); 
                await sleep(800); clearInterval(burst); 
            } 
            if (target.action.card === 3 && type === 1) { 
                await focusOnAction(target, attacker, 400); 
                if (target.type === 'Odin') { 
                    target.weaponGroup.rotation.z = 1.2; await move(target.weaponGroup, new THREE.Vector3(0,0,5), 100); 
                    const moveDisplay = document.getElementById('move-display'); 
                    moveDisplay.innerText = CARD_NAMES[3]; // FIX THIS
                    moveDisplay.style.opacity = "1"; 
                    for (let i = 0; i < 12; i++) { setTimeout(() => { activeLightnings.push(new OptimizedLightningBolt(target.group.position.clone().add(new THREE.Vector3(0,25,0)), attacker.group.position.clone().add(new THREE.Vector3(0,25,0)), 0xff0000)); SoundEngine.play('magic'); }, i * 50); } 
                    await sleep(1000); await move(target.weaponGroup, new THREE.Vector3(0,0,0), 100); target.weaponGroup.rotation.z = 0; moveDisplay.style.opacity = "0"; 
                } else if (target.type === 'Loki') { 
                    log(`${target.name} ${CARD_NAMES[3]}!`); target.ballRotationMultiplier = 15.0; await sleep(1000); 
                    const originalBallPos = target.ball.position.clone(); 
                    const worldPosAttacker = new THREE.Vector3(); attacker.group.getWorldPosition(worldPosAttacker); worldPosAttacker.y += 30; 
                    await new Promise(res => { const start = target.ball.position.clone(), localTarget = target.modelContainer.worldToLocal(worldPosAttacker.clone()), t = performance.now(); function fly() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(start, localTarget, p); if (p < 1) requestAnimationFrame(fly); else res(); } fly(); }); 
                    SoundEngine.play('hit'); 
                    
                    // Loki's Reflection Hit -> Explosion
                    createExplosion(attacker.group.position, 2.0);

                    await new Promise(res => { const start = target.ball.position.clone(), t = performance.now(); function back() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(start, originalBallPos, p); if (p < 1) requestAnimationFrame(back); else res(); } back(); }); target.ballRotationMultiplier = 1.0; 
                } 
                SoundEngine.play('counter'); await sleep(1000); 
            } 
            calcDamage(attacker, target, 1); 
        } 
    }

    async function performLightningStorm(p) { 
        log(`<b>${p.name} Ult!</b>`); SoundEngine.play('super'); 
        const targets = players.filter(o => o && o.id !== p.id && o.alive); 
        if (p.type === 'Loki') { 
            p.takeDamage(p.maxHP * 0.25, 2); 
            for(let i=0; i<3; i++) { 
                targets.forEach(t => activeProjectiles.push(new MeatDrop(t.group.position, 8.75, true))); 
                await sleep(400); 
            } 
            await sleep(600); targets.forEach(t => calcDamage(p, t, 1, true)); 
        } else { 
            const pullBackPos = new THREE.Vector3(0, 450, 650), pullBackCenter = new THREE.Vector3(0, 40, 0), originalCamPos = camera.position.clone(); 
            await new Promise(res => { let s = performance.now(); function up() { let pv = Math.min(1, (performance.now() - s) / 800); camera.position.lerpVectors(originalCamPos, pullBackPos, pv); camera.lookAt(pullBackCenter); if (pv < 1) requestAnimationFrame(up); else res(); } up(); }); 
            await sleep(300); 
            for (let i = 0; i < 8; i++) { 
                targets.forEach(t => { 
                    const sY = t.group.position.clone().add(new THREE.Vector3((Math.random()-0.5)*30, 500, (Math.random()-0.5)*30)); 
                    activeLightnings.push(new OptimizedLightningBolt(sY, t.group.position)); 
                }); 
                SoundEngine.play('magic'); await sleep(150); 
            } 
            await sleep(400); targets.forEach(t => calcDamage(p, t, 1, true)); await sleep(400); resetCamera(); 
        } 
    }
    
    async function performPhysicalSuper(attacker, target) { log(`<b>${attacker.name} Ult!</b>`); SoundEngine.play('super'); const op = attacker.group.position.clone(), tp = target.group.position.clone(); if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 15.0; const behindTarget = tp.clone().add(tp.clone().sub(op).normalize().multiplyScalar(80)); for (let i = 0; i < 3; i++) { const targetPoint = (i % 2 === 0) ? behindTarget : op.clone(); await move(attacker.group, targetPoint, 300); if (i === 0) calcDamage(attacker, target, 0, true); SoundEngine.play('hit'); await sleep(100); } attacker.ballRotationMultiplier = 1.0; await move(attacker.group, op, 400); } else { for (let i = 0; i < 3; i++) { const strikePos = tp.clone().add(op.clone().sub(tp).normalize().multiplyScalar(40)); await move(attacker.group, strikePos, 150); calcDamage(attacker, target, 0, true, i > 0); await sleep(100); } await move(attacker.group, op, 400); } }
    async function resolveActions() { 
        const pMap = { 4: 0, 3: 0, 5: 1, 0: 2, 1: 2, 2: 3 }; 
        const q = players.filter(p => p && p.alive).sort((a, b) => (pMap[a.action.card]??5) - (pMap[b.action.card]??5)); 
        
        let localDemoId = currentDemoId; 

        // --- Êñ∞Â¢ûÔºöÁõÆÊ®ôÈéñÂÆöÂ±ïÁ§∫ÈöéÊÆµ ---
        if (!isTutorialMode) {
            const md = document.getElementById('move-display'); 
            md.innerText = TRANSLATIONS[currentLang].lockingTargets; 
            md.style.opacity = "1";
            
            // Wait for rotation to finish (slerp takes time)
            await sleep(1200);
            
            md.style.opacity = "0";
            await sleep(300);
        }

        for (let p of q) { 
            if (localDemoId !== currentDemoId) return;
            if (!p || !p.alive) continue; 
            const t = players.find(x => x && x.id === p.action.target), cid = p.action.card; 
            
            if (cid === 4 || cid === 2) { 
                const md = document.getElementById('move-display'); md.innerText = CARD_NAMES[cid]; md.style.opacity = "1"; 
                SoundEngine.play('click'); await sleep(800); 
            } else if (cid >= 0) { 
                await cinematicIntro(p, CARD_NAMES[cid]); 
            } 

            if (localDemoId !== currentDemoId) return; 
            
            if (!t || !t.alive) { 
                if (cid >= 0 && cid !== 4) { const md = document.getElementById('move-display'); md.innerText = "ÔºüÔºüÔºüÔºüÔºü"; md.style.opacity = "1"; await sleep(1000); md.style.opacity = "0"; } 
                updateHPUI(); await sleep(300); resetCamera(); continue; 
            } 
            
            if (cid === 4) { p.fatigue = Math.min(150, p.fatigue + 75); updateHPUI(); } 
            if (t && t.alive) t.face(p.group.position); 
            
            if (cid === 4) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 2) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 3) { p.hexShield.visible = true; SoundEngine.play('counter'); await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 5) { 
                if (t?.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); } 
                const isR = (p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99); 
                if (isR) await performPhysicalSuper(p, t); else await performLightningStorm(p); 
                if (p.id === 0) { playerRage.red=0; playerRage.blue=0; } else { p.rage.red=0; p.rage.blue=0; } 
            } else if (cid >= 0 && cid < 2) { 
                if (t && t.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); } 
                await performAttack(p, t, cid); 
            } 
            
            if (localDemoId !== currentDemoId) return; 

            document.getElementById('move-display').style.opacity = "0"; updateHPUI(); await sleep(300); resetCamera(); 
        } 
        
        if (isTutorialMode) { 
            if (localDemoId === currentDemoId) { 
                gameState = 'TUTORIAL_IDLE'; 
                document.getElementById('tutorial-desc').innerText = TRANSLATIONS[currentLang].tutEnd; 
            }
        } else { 
            if (!players[0].alive) showMsg(TRANSLATIONS[currentLang].ragnarok); 
            else if (players.slice(1).every(p => !p.alive)) showMsg(TRANSLATIONS[currentLang].pigKing); 
            else startTurn(); 
        } 
    }
    
    function endTurn() { 
        if (timerInterval) clearInterval(timerInterval); gameState = 'ANIMATING'; document.getElementById('turn-hint').style.display = 'none';
        let playerCard = selectedSlot;
        if (playerCard === -1) { playerCard = (players[0] && players[0].fatigue >= 100) ? 0 : 4; } 
        else if (playerCard === 4 && players[0] && players[0].fatigue >= 100) { playerCard = 0; }
        
        if (players[0]) {
            players[0].action = { card: playerCard, target: selectedTargetId===-1?getRandomTarget(0):selectedTargetId, selectionTime: Date.now() }; 
        }
        
        const humanTargetId = players[0] ? players[0].action.target : -1;

        players.forEach((p, i) => {
            if (i === 0 || !p || !p.alive) return;

            // AI Target Selection Logic
            let tId = -1;
            // 5. Prioritize targets with fatigue > 99
            const vulnerable = players.filter(o => o && o.id !== p.id && o.alive && o.fatigue >= 99);

            if (vulnerable.length > 0) {
                 tId = vulnerable[Math.floor(Math.random() * vulnerable.length)].id;
            } else {
                 tId = getRandomTarget(p.id);
            }

            const isTargeted = players.some(attacker => attacker && attacker.alive && attacker.action && attacker.action.target === p.id);
            const r = p.rage; const maxRage = Math.max(r.red, r.blue);
            let choice = 0;

            if (maxRage >= 99) { 
                choice = Math.random() < 0.9 ? 5 : 0; 
            } else {
                // 3. Rage Bias Logic
                if (r.red > 50) { // High Red Rage -> Favor Physical (0)
                    choice = (Math.random() < 0.8) ? 0 : (Math.random() < 0.5 ? 2 : 4);
                } else if (r.blue > 50) { // High Blue Rage -> Favor Magic (1)
                     choice = (Math.random() < 0.8) ? 1 : (Math.random() < 0.5 ? 3 : 4);
                } else {
                    // Standard logic
                    if (p.id !== humanTargetId) { 
                        choice = Math.random() < 0.5 ? 0 : 1; 
                    } else { 
                        if (r.blue > 0 && r.blue > r.red) choice = Math.random() < 0.7 ? 1 : 3; 
                        else if (r.red > 0 && r.red >= r.blue) choice = Math.random() < 0.7 ? 0 : 2; 
                        else choice = Math.random() < 0.3 ? 4 : (Math.random() < 0.5 ? 0 : 1); 
                    }
                }
            }
            if (choice === 4 && p.fatigue >= 100) choice = 0;

            p.action = { card: choice, target: tId, selectionTime: Date.now() };
            // 2. Immediately face target
            if (players[tId]) p.face(players[tId].group.position);
        });
        resolveActions(); 
    }

    function startTurn() {
        if (gameState === 'ENDED') return; gameState = 'WAITING'; timeLeft = TURN_TIME; selectedSlot = -1; 
        selectedTargetId = 1; 
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected', 'disabled'));
        document.getElementById('move-display').style.opacity = "0"; document.getElementById('turn-hint').style.display = 'block'; 
        const tEl = document.getElementById('timer'); if (tEl) { tEl.innerText = timeLeft; tEl.style.display = "block"; }
        players.forEach((p, i) => { p.fatigue = Math.max(0, p.fatigue - 35); p.showBrokenShield = p.fatigue >= 100; p.defendHitCount = 0; p.blockedInTurn = false; if (p.hexShield) p.hexShield.visible = false; if (p.updateLabel) p.updateLabel(); });
        resetCamera(); updateHPUI(); clearInterval(timerInterval);
        timerInterval = setInterval(() => { timeLeft--; if (tEl) tEl.innerText = timeLeft; if (timeLeft <= 0) { if(tEl) tEl.style.display = "none"; endTurn(); } }, 1000);
    }

    // --- Ë£úÂõûÈÅ∫Â§±ÁöÑÈóúÈçµÂáΩÂºè ---
    window.startBattle = function() { 
        document.getElementById('char-select').style.display = 'none'; 
        document.getElementById('game-ui').style.display = 'block'; 
        initBattle(); 
    };

    window.selectCard = function(i) { 
        if (gameState !== 'WAITING') return; 
        selectedSlot = i; 
        document.querySelectorAll('.card').forEach((c, idx) => c.classList.toggle('selected', idx === i)); 
        SoundEngine.play('click'); 
        // Show description on select
        showCardDescription(i);
    };

    window.askOracle = async function() { 
        SoundEngine.init(); 
        const btn = document.getElementById('oracle-btn-card'); 
        if (gameState !== 'WAITING' || btn.classList.contains('loading')) return; 
        btn.classList.add('loading'); 
        const p = players[0]; 
        try { 
            const r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, { method: 'POST', body: JSON.stringify({ contents: [{ parts: [{ text: `Stats: HP:${p.hp}/500` }] }], systemInstruction: { parts: [{ text: "Ë±¨Ë±¨ÂÖàÁü•ÔºåÁµ¶Á∞°Áü≠Âª∫Ë≠∞„ÄÇ" }] } }) }); 
            const res = await r.json(); 
            const txt = res.candidates?.[0]?.content?.parts?.[0]?.text; 
            if (txt) log(`<span style='color:gold'><b>‚ú®Ë±¨Ë±¨ÂÖàÁü•:</b> ${txt.trim()}</span>`); 
        } catch(e){} 
        btn.classList.remove('loading'); 
    };

    // (spawnPlayers, initWorld, handleInt, initBattle, animate... ‰øùÊåÅ‰∏çËÆä)
    function spawnPlayers() { if (isTutorialMode) { const configs = [ { id: 0, x: -60, y: 50, z: 80, name: (selectedPlayerType === 'Loki' ? "Ê¥õÂü∫" : "Â•ß‰∏Å"), type: selectedPlayerType }, { id: 1, x: 60, y: 50, z: -80, name: "ÂÅá‰∫∫(ÊîªÊìä)", type: (selectedPlayerType === 'Loki' ? 'Odin' : 'Loki') }, { id: 2, x: 0, y: 50, z: -150, name: "ÁÑ°ËæúË∑Ø‰∫∫", type: 'Odin' } ]; players = configs.map(cfg => new Odin(cfg)); } else { const configs = [{ id: 0, x: 0, y: 50, z: 120, name: (selectedPlayerType === 'Loki' ? "Ê¥õÂü∫" : "Â•ß‰∏Å"), type: selectedPlayerType }, { id: 1, x: 0, y: 50, z: -110, name: "Ê¥õÂü∫", type: 'Loki' }, { id: 2, x: 110, y: 50, z: 0, name: "Â•ß‰∏ÅA", type: 'Odin' }, { id: 3, x: -110, y: 50, z: 0, name: "Â•ß‰∏ÅB", type: 'Odin' }]; players = configs.map(cfg => new Odin(cfg)); } document.getElementById('player-name-display').innerText = players[0].name; const slot2 = document.getElementById('slot-2-btn'); if (players[0].type === 'Loki') { slot2.innerText = TRANSLATIONS[currentLang].cardNames.swap; CARD_NAMES[2] = TRANSLATIONS[currentLang].swapSkill; } else { slot2.innerText = TRANSLATIONS[currentLang].cardNames[2]; CARD_NAMES[2] = TRANSLATIONS[currentLang].counterSkill; } updateHPUI(); 
    // Force text update on spawn to ensure correct lang
    updateText();
    }
    
    function initWorld() { scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 200, 2500); scene.add(new THREE.AmbientLight(0xffffff, 0.5)); const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(200, 400, 100); sun.castShadow = true; sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048; const d = 500; sun.shadow.camera.left = -d; sun.shadow.camera.right = d; sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d; scene.add(sun); const arena = new THREE.Mesh(new THREE.BoxGeometry(240, 15, 240), new THREE.MeshPhongMaterial({ color: 0x88bb88 })); arena.position.y = -15; arena.receiveShadow = true; scene.add(arena); for(let i=0; i<12; i++) { const h = 700 + Math.random()*400; const m = new THREE.Mesh(new THREE.BoxGeometry(300, h, 300), new THREE.MeshPhongMaterial({ color: 0xcc99aa })); const a = (i/12)*Math.PI*2; m.position.set(Math.cos(a)*1200, h/2 - 1200, Math.sin(a)*1200); scene.add(m); const cap = new THREE.Mesh(new THREE.BoxGeometry(305, 70, 305), new THREE.MeshPhongMaterial({ color: 0xffffff })); cap.position.set(m.position.x, m.position.y + h/2, m.position.z); scene.add(cap); } }
    
    function handleInt(x, y) { if (gameState !== 'WAITING') return; if (selectedSlot !== 0 && selectedSlot !== 1 && selectedSlot !== 5) return; const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((x - rect.left) / rect.width) * 2 - 1; mouse.y = -((y - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); const chars = players.filter(p => p && p.id > 0 && p.alive).map(p => p.group); const intersects = raycaster.intersectObjects(chars, true); if (intersects.length > 0) { let o = intersects[0].object; while(o && !o.userData.isCharacter) o = o.parent; if (o) { selectedTargetId = o.userData.playerId; players[0].face(players[selectedTargetId].group.position); SoundEngine.init(); SoundEngine.play('click'); updateHPUI(); } } }
    function initBattle() { const v = document.getElementById('viewport'); const oldCanvas = v.querySelector('canvas'); if (oldCanvas) { v.removeChild(oldCanvas); } scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.setPixelRatio(window.devicePixelRatio); v.appendChild(renderer.domElement); raycaster = new THREE.Raycaster(); clock = new THREE.Clock(); initWorld(); spawnPlayers(); adjustCameraForResponsive(); animate(); window.addEventListener('resize', () => { if(camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); adjustCameraForResponsive(); } }); window.addEventListener('mousedown', (e) => { SoundEngine.init(); handleInt(e.clientX, e.clientY); }); window.addEventListener('touchstart', (e) => { SoundEngine.init(); if(e.touches[0]) handleInt(e.touches[0].clientX, e.touches[0].clientY); }); if (isTutorialMode) { gameState = 'TUTORIAL_IDLE'; document.getElementById('game-ui').style.display = 'none'; document.getElementById('tutorial-ui').style.display = 'flex'; setTimeout(() => { window.demoAction(0); }, 800); } else { document.getElementById('game-ui').style.display = 'block'; document.getElementById('tutorial-ui').style.display = 'none'; startTurn(); } }
    function animate() { animationId = requestAnimationFrame(animate); const dt = clock.getDelta(); for(let i=activeLightnings.length-1; i>=0; i--) if(!activeLightnings[i].update()) activeLightnings.splice(i,1); for(let i=activeParticles.length-1; i>=0; i--) if(!activeParticles[i].update(dt)) activeParticles.splice(i,1); for(let i=activeProjectiles.length-1; i>=0; i--) if(!activeProjectiles[i].update(dt)) activeProjectiles.splice(i,1); if (renderer && scene && camera) { players.forEach(p => { if(p && p.alive) { p.group.position.y = 50 + Math.sin(Date.now()*0.003 + p.id)*4; p.uiSprite.quaternion.copy(camera.quaternion); if (p.targetQuaternion) { p.group.quaternion.slerp(p.targetQuaternion, 5 * dt); } if(p.hexShield && p.hexShield.visible) p.hexShield.rotation.z += 0.05; if(p.type === 'Loki' && p.ball) { p.ball.rotation.y += 0.05 * p.ballRotationMultiplier; p.ball.rotation.x += 0.02 * p.ballRotationMultiplier; } const r = (p.id === 0 ? playerRage : p.rage), maxRage = Math.max(r.red, r.blue); if (maxRage >= 99) { if (!p.aura.active || p.aura.isRed !== (r.red >= r.blue)) { p.aura.activate(r.red >= r.blue); } } else { if (p.aura.active) p.aura.deactivate(); } p.aura.update(dt); if (p.brokenShieldIcon && p.brokenShieldIcon.visible) { const s = 8 + Math.sin(Date.now() * 0.005) * 1.5; p.brokenShieldIcon.scale.set(s, s, 1); p.brokenShieldIcon.material.opacity = 0.6 + Math.sin(Date.now() * 0.005) * 0.2; } if (maxRage >= 99 && Math.random() > 0.92) { const s = p.group.position.clone().add(new THREE.Vector3((Math.random()-0.5)*20, Math.random()*40, (Math.random()-0.5)*20)), e = p.group.position.clone().add(new THREE.Vector3((Math.random()-0.5)*20, Math.random()*40, (Math.random()-0.5)*20)); activeLightnings.push(new OptimizedLightningBolt(s, e, Math.random() > 0.5 ? 0xff0000 : 0x00ffff)); } if (p.id === selectedTargetId && p.id !== 0 && p.selectionRing && p.targetLabel) { const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1; p.selectionRing.scale.set(pulse, pulse, 1); p.targetLabel.visible = true; } else if (p.targetLabel) { p.targetLabel.visible = false; } } }); renderer.render(scene, camera); } }

    window.startTutorialSelection = function() { SoundEngine.init(); isTutorialSelection = true; document.getElementById('main-menu').style.display = 'none'; document.getElementById('char-select').style.display = 'flex'; updateText(); };
    window.showCharSelect = function() { SoundEngine.init(); isTutorialSelection = false; document.getElementById('main-menu').style.display = 'none'; document.getElementById('char-select').style.display = 'flex'; updateText(); };
    window.pickChar = function(t) { selectedPlayerType = t; document.getElementById('select-odin').className = (t === 'Odin' ? 'char-card active' : 'char-card'); document.getElementById('select-loki').className = (t === 'Loki' ? 'char-card active' : 'char-card'); SoundEngine.play('click'); };
    window.confirmSelection = function() { if (isTutorialSelection) { window.startTutorial(); } else { window.startBattle(); } };
    window.startTutorial = function() { SoundEngine.init(); isTutorialMode = true; document.getElementById('char-select').style.display = 'none'; initBattle(); };
    window.quitTutorial = function() { SoundEngine.play('click'); isTutorialMode = false; window.resetGame(); };
    window.demoAction = async function(cardIndex) { if (gameState === 'ANIMATING') { currentDemoId++; await sleep(50); resetCamera(); updateHPUI(); } if (!players || players.length < 2) return; SoundEngine.init(); gameState = 'ANIMATING'; currentDemoId++; const p0 = players[0]; const p1 = players[1]; const descEl = document.getElementById('tutorial-desc'); p0.action = { card: (cardIndex === 6 ? 5 : cardIndex), target: 1, selectionTime: Date.now() }; p1.action = { card: 0, target: 0, selectionTime: Date.now() }; const isLoki = (p0.type === 'Loki'); if (cardIndex === 5) { playerRage.red = 100; playerRage.blue = 0; } else if (cardIndex === 6) { playerRage.red = 0; playerRage.blue = 100; } else { playerRage.red = 0; playerRage.blue = 0; } updateHPUI(); updateText(); const t = TRANSLATIONS[currentLang]; switch(cardIndex) { case 0: descEl.innerText = isLoki ? t.tut0_loki : t.tut0_odin; p1.action.card = -1; break; case 1: descEl.innerText = isLoki ? t.tut1_loki : t.tut1_odin; p1.action.card = -1; break; case 2: descEl.innerText = isLoki ? t.tut2_loki : t.tut2_odin; if(isLoki) p1.action.card = 0; else p1.action.card = 0; break; case 3: descEl.innerText = isLoki ? t.tut3_loki : t.tut3_odin; p1.action.card = 1; break; case 4: descEl.innerText = t.tut4; p1.action.card = 0; break; case 5: descEl.innerText = isLoki ? t.tut5_loki : t.tut5_odin; p1.action.card = -1; break; case 6: descEl.innerText = isLoki ? t.tut6_loki : t.tut6_odin; p1.action.card = -1; break; } await resolveActions(); if(isTutorialMode && currentDemoId === currentDemoId) { gameState = 'TUTORIAL_IDLE'; descEl.innerText = t.tutEnd; players.forEach(p => { p.hp = p.maxHP; p.fatigue = 0; p.showBrokenShield = false; p.updateLabel(); }); playerRage.red = 0; playerRage.blue = 0; updateHPUI(); } };
    
    // Fix: Check if scene is defined before clearing it
    window.resetGame = function() { 
        if (timerInterval) clearInterval(timerInterval); 
        if (animationId) cancelAnimationFrame(animationId); 
        document.getElementById('game-msg').style.display = 'none'; 
        document.getElementById('turn-hint').style.display = 'none'; 
        
        currentDemoId++; // Force stop any running animations

        if (scene) {
            while(scene.children.length > 0){ 
                const o = scene.children[0]; 
                if(o.geometry) o.geometry.dispose(); 
                if(o.material) o.material.dispose(); 
                scene.remove(o); 
            } 
        }
        
        players.length = 0; 
        activeLightnings.length = 0; 
        activeParticles.length = 0; 
        activeProjectiles.length = 0; 
        playerRage.red = 0; 
        playerRage.blue = 0; 
        gameState = 'IDLE'; 
        document.getElementById('status-log').innerHTML = ""; 
        document.getElementById('game-ui').style.display = 'none'; 
        document.getElementById('main-menu').style.display = 'flex'; 
        document.getElementById('tutorial-ui').style.display = 'none'; 
        document.getElementById('char-select').style.display = 'none'; 
        
        // Hide card description on reset
        hideCardDescription();
    };

    function showCardDescription(index) {
        const descEl = document.getElementById('card-description');
        const t = TRANSLATIONS[currentLang];
        const p = players[0];
        let desc = "";

        if (!p) return;

        if (index === 2 || index === 5) {
            // These indices depend on character type
            desc = t.cardDescs[index][p.type];
        } else {
            desc = t.cardDescs[index];
        }

        descEl.innerText = desc;
        descEl.style.opacity = 1;
    }

    function hideCardDescription() {
        const descEl = document.getElementById('card-description');
        descEl.style.opacity = 0;
    }

    function showMsg(t) { const el = document.getElementById('game-msg'); el.innerHTML = `<span>${t}</span><br><button class="btn-gold" style="margin-top:10px;" onclick="window.resetGame()">ÈáçÊñ∞ÈñãÂßã</button>`; el.style.display = 'flex'; }
</script>
</body>
</html>