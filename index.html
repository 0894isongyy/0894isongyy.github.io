<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è±¬ç¥é»ƒæ˜ Pignarok Arena (Ver 23.46 Final)</title>
    <!-- å¼•å…¥ PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- åŸºç¤è¨­å®š --- */
        :root {
            --ui-max-width: 500px;
            --primary-gold: #ff99cc;
            --bg-overlay: rgba(0, 0, 0, 0.4);
            --accent-blue: #55ccff;
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: 'Cinzel', serif, "Microsoft JhengHei", "Helvetica Neue", sans-serif;
            background: #000; color: white;
            touch-action: none; width: 100vw; height: 100vh;
            -webkit-user-select: none; user-select: none;
        }
        
        #viewport {
            position: relative; width: 100%; height: 100%;
            background: #87CEEB; overflow: hidden;
        }

        #viewport canvas { display: block; width: 100% !important; height: 100% !important; outline: none; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle, rgba(40, 20, 80, 0.95) 0%, rgba(10, 5, 20, 1) 100%);
            z-index: 2000; transition: opacity 0.5s ease; padding: 20px; box-sizing: border-box;
            opacity: 0; pointer-events: none;
        }

        .overlay-screen.scrollable {
            justify-content: flex-start;
            overflow-y: auto;
            padding-top: 60px;
            padding-bottom: 40px;
            -webkit-overflow-scrolling: touch;
        }
        
        .overlay-screen.active {
            opacity: 1; pointer-events: auto;
        }

        .menu-bg-pig {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            width: 80%;
            max-width: 500px;
            height: auto;
            max-height: 60vh; 
            opacity: 0.25; 
            z-index: 0; 
            pointer-events: none;
            object-fit: contain;
        }

        h1 { 
            font-size: clamp(2.5rem, 8vw, 4.5rem); margin-bottom: 5px; color: var(--primary-gold); 
            text-shadow: 0 0 20px rgba(255, 153, 204, 0.6); letter-spacing: 5px; text-align: center; 
            z-index: 2;
            position: relative; 
        }
        .sub-title { 
            font-size: 1.2rem; color: #fff; margin-bottom: 5px; letter-spacing: 2px; opacity: 0.8; 
            z-index: 2; 
            position: relative;
        }
        
        .version-text {
            font-size: 0.8rem;
            color: #d4af37; 
            margin-bottom: 30px;
            letter-spacing: 1px;
            opacity: 0.9;
            font-family: monospace;
            z-index: 2;
            position: relative;
        }

        .studio-footer {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            font-size: 0.75rem;
            color: #666;
            font-family: 'Cinzel', serif;
            letter-spacing: 3px;
            opacity: 0.7;
        }

        h2 { font-size: 1.4rem; color: #fff; margin-bottom: 15px; border-bottom: 2px solid var(--primary-gold); padding-bottom: 5px; margin-top: 0; }

        input.input-box, select.input-box {
            background: rgba(255, 255, 255, 0.1); border: 2px solid var(--primary-gold);
            color: white; padding: 10px; font-size: 1.1rem; margin: 5px 0;
            border-radius: 8px; text-align: center; width: 80%; max-width: 300px;
            font-family: inherit; outline: none;
        }
        select.input-box option { background: #333; color: white; }
        input.input-box::placeholder { color: #aaa; }

        .preset-container {
            display: flex; justify-content: center;
            width: 100%; margin-bottom: 10px;
        }

        .room-code-display {
            font-size: 3rem; color: var(--accent-blue); letter-spacing: 10px;
            margin: 20px 0; padding: 15px 40px; border: 3px dashed rgba(255, 255, 255, 0.3);
            background: rgba(0,0,0,0.3); border-radius: 10px;
        }

        .player-list {
            list-style: none; padding: 0; width: 100%; max-width: 400px; margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden;
        }
        .player-list li {
            background: rgba(255,255,255,0.05); padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
        }
        .tag-host { color: #f1c40f; font-size: 0.8rem; border: 1px solid #f1c40f; padding: 2px 6px; border-radius: 4px; }
        .tag-me { color: #2ecc71; font-size: 0.8rem; }

        @keyframes breathe {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }
        .breathing-text {
            animation: breathe 2.5s infinite ease-in-out;
            color: #88ccff;
            font-size: 0.9rem;
            margin-top: 10px;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 1px;
        }

        .mini-char-select {
            display: flex; gap: 10px; margin: 10px 0; width: 80%; max-width: 300px;
        }
        .mini-card {
            flex: 1; padding: 10px; border: 1px solid #888; border-radius: 8px;
            cursor: pointer; transition: 0.2s; background: rgba(0,0,0,0.3);
            display: flex; flex-direction: column; align-items: center; opacity: 0.6;
        }
        .mini-card.active {
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2);
            opacity: 1; transform: scale(1.05);
        }
        .mini-icon { font-size: 1.5rem; margin-bottom: 5px; }

        #turn-hint {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 1rem; font-weight: bold; text-shadow: 0 0 10px #000;
            background: var(--bg-overlay); padding: 5px 15px; border-radius: 20px;
            display: none; z-index: 50; pointer-events: none;
            white-space: nowrap; border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @keyframes breathe-purple {
            0% { transform: translateX(-50%) scale(1); opacity: 0.8; text-shadow: 0 0 10px #ffffff; }
            50% { transform: translateX(-50%) scale(1.05); opacity: 1; text-shadow: 0 0 20px #ffffff; }
            100% { transform: translateX(-50%) scale(1); opacity: 0.8; text-shadow: 0 0 10px #ffffff; }
        }

        #tutorial-rage-hint {
            position: absolute; top: 22%; left: 50%; transform: translateX(-50%);
            width: 90%; text-align: center; pointer-events: none; z-index: 45;
            display: none;
            color: #ffffff; /* White */
            font-size: 1.5rem;
            font-weight: 800;
            line-height: 1.5;
            animation: breathe-purple 2s infinite ease-in-out;
        }

        /* --- Tutorial Pointer Styles --- */
        .tutorial-pointer {
            position: absolute;
            font-size: 4rem;
            z-index: 6000;
            pointer-events: none;
            display: none;
            filter: drop-shadow(0 0 10px gold);
            transition: top 0.1s, left 0.1s;
        }
        @keyframes bounce-down { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(20px); } }
        @keyframes bounce-up { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }

        @keyframes hint-flash { 0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); } 50% { opacity: 0.3; transform: translateX(-50%) scale(0.95); } }
        .flashing { animation: hint-flash 1s infinite ease-in-out; }

        .btn-gold {
            padding: 12px 30px; font-size: 1.1rem; background: rgba(255, 153, 204, 0.2);
            border: 2px solid var(--primary-gold); color: var(--primary-gold); cursor: pointer; border-radius: 50px;
            transition: all 0.3s; font-family: 'Cinzel', serif; text-transform: uppercase;
            max-width: 300px; width: 100%; margin-bottom: 10px;
            z-index: 5;
        }
        .btn-gold:hover { background: var(--primary-gold); color: #1a0d0d; transform: scale(1.05); }
        .btn-gold:disabled { border-color: #555; color: #888; background: transparent; cursor: not-allowed; transform: none; }

        .btn-back { border-color: #aaa; color: #ccc; font-size: 0.9rem; padding: 8px 20px; margin-top: 5px; width: auto; }

        .lang-container {
            display: flex; gap: 15px; margin-bottom: 30px;
            z-index: 5;
        }
        .btn-lang {
            padding: 8px 20px; font-size: 0.9rem; background: transparent;
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            transition: all 0.3s;
        }
        .btn-lang.active { background: var(--primary-gold); color: #000; border-color: var(--primary-gold); }
        .btn-lang:hover { transform: scale(1.1); }

        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        
        #top-announcer {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            width: 100%; max-width: var(--ui-max-width);
            text-align: center; pointer-events: none; z-index: 100;
        }
        #timer { color: #fff; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1); }
        #move-display {
            color: var(--primary-gold); font-size: clamp(1rem, 3.5vw, 1.3rem); font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1);
            margin-top: 5px; opacity: 0; transition: opacity 0.3s;
            background: rgba(0,0,0,0.8); padding: 12px 30px; border-radius: 50px;
            display: inline-block; border: 3px solid var(--primary-gold);
            white-space: normal; width: auto;
        }

        #card-description {
            position: absolute; bottom: 160px; 
            left: 0; width: 100%;
            text-align: center; color: #ffeb3b; font-size: 0.85rem; font-weight: bold;
            text-shadow: 0 0 5px #000; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            background: linear-gradient(to right, transparent, rgba(0,0,0,0.7), transparent);
            padding: 5px 0; z-index: 25;
        }

        #bottom-ui-container {
            position: absolute; bottom: 30px; 
            left: 0; width: 100%;
            display: flex; justify-content: center;
            padding: 10px 0 20px 0; 
            background: linear-gradient(to top, rgba(0,0,0,1) 30%, rgba(0,0,0,0.6) 80%, transparent);
            pointer-events: auto; z-index: 20;
        }

        #card-area { 
            display: flex; flex-direction: row; gap: 3px; 
            width: 98%; max-width: var(--ui-max-width); 
            justify-content: space-evenly; align-items: flex-end; 
        }

        #player-hp-card {
            flex: 1.2; height: 95px; min-width: 50px;
            background: rgba(0, 40, 40, 0.8); 
            border: 1.5px solid #00ffff; 
            border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 4px 2px; color: #fff; backdrop-filter: blur(10px);
            font-size: 0.58rem; font-weight: bold; line-height: 1.3; text-align: center; box-sizing: border-box;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .name-text { font-size: 0.62rem; color: var(--primary-gold); margin-bottom: 2px; width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .hp-text { font-size: 0.58rem; color: #ffccdd; }
        .fatigue-text { color: #ffaa00; font-size: 0.75rem; font-weight: 800; }
        .rage-text { font-size: 0.75rem; color: #ff8888; font-weight: 800; }

        .card {
            flex: 1; height: 95px; min-width: 40px; 
            background: rgba(255, 255, 255, 0.1); border: 1.2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; cursor: pointer; transition: 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; color: #fff; font-weight: bold; backdrop-filter: blur(5px); 
            font-size: 0.55rem; 
            padding: 2px; box-sizing: border-box; user-select: none;
        }
        .card:active { transform: scale(0.92); }
        .card.selected { 
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.3); 
            transform: scale(1.15) translateY(-10px); box-shadow: 0 0 20px rgba(255, 153, 204, 0.6); z-index: 100;
        }
        .card.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }

        @keyframes card-breathing-red { 0%, 100% { box-shadow: 0 0 5px #ff5555; } 50% { box-shadow: 0 0 20px #ff0000; } }
        @keyframes card-breathing-blue { 0%, 100% { box-shadow: 0 0 5px #55ccff; } 50% { box-shadow: 0 0 20px #0088ff; } }
        
        .card.super { color: #000; border-color: #fff; font-weight: 800; }
        .card.super-red { animation: card-breathing-red 1.5s infinite; background: linear-gradient(135deg, #ff9999, #fff); }
        .card.super-blue { animation: card-breathing-blue 1.5s infinite; background: linear-gradient(135deg, #99ccff, #fff); }

        .circle-btn {
            position: absolute; width: 45px; height: 45px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid var(--primary-gold);
            color: #fff; font-size: 0.8rem; font-weight: bold;
            cursor: pointer; z-index: 200; display: flex; justify-content: center; align-items: center;
            pointer-events: auto; transition: all 0.2s;
            top: 20px; top: max(20px, env(safe-area-inset-top));
        }
        .circle-btn:hover { transform: scale(1.1); background: var(--primary-gold); color: #000; }

        .top-right-container {
            position: absolute;
            top: 20px;
            top: max(20px, env(safe-area-inset-top));
            right: 20px;
            right: max(20px, env(safe-area-inset-right));
            display: flex;
            flex-direction: row;
            gap: 15px;
            z-index: 4000; 
            align-items: center;
            pointer-events: auto;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .control-btn {
            width: 32px; 
            height: 32px; 
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); 
            border: 1.5px solid var(--primary-gold);
            color: #fff; 
            font-size: 1rem;
            cursor: pointer; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            transition: all 0.2s;
            pointer-events: auto;
            user-select: none;
        }
        
        .control-icon {
            width: 36px;
            height: 36px;
            font-size: 1.2rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--primary-gold);
            color: #000;
            border: 2px solid #fff;
            cursor: pointer;
            pointer-events: auto;
        }
        .control-icon.off { background: rgba(50,50,50,0.8); color: #888; border-color: #555; }
        
        .vol-btn { width: 24px; height: 24px; font-size: 0.9rem; border: 1px solid #aaa; background: rgba(0,0,0,0.6); color: #eee; cursor: pointer; }

        #btn-auto-play { width: auto; padding: 0 15px; border-radius: 20px; background: rgba(100, 100, 100, 0.5); border-color: #aaa; font-size: 0.8rem; font-weight: bold; }
        #btn-auto-play.active { background: rgba(255, 215, 0, 0.3); border-color: #ffd700; color: #ffd700; animation: breathe 2s infinite; }

        .home-btn { left: 20px; left: max(20px, env(safe-area-inset-left)); font-size: 1.5rem; padding-bottom: 3px; }

        #game-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1rem; 
            color: #fff; display: none; background: rgba(0,0,0,0.95);
            padding: 15px 25px; 
            border-radius: 15px; 
            border: 2px solid var(--primary-gold); 
            z-index: 3000;
            text-align: center; width: 80%; 
            max-width: 280px; 
            backdrop-filter: blur(10px);
            flex-direction: column; align-items: center; 
            gap: 10px; 
        }
        
        .final-victory-text { font-size: 2rem !important; color: #ffd700; text-shadow: 0 0 10px #ff0000; margin-bottom: 20px; }

        .btn-small { padding: 8px 15px; font-size: 0.9rem; background: rgba(0,0,0,0.6); border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px; font-family: 'Cinzel', serif; }

        .damage-popup {
            position: absolute;
            color: #ff0000; 
            font-family: "Arial Black", "Arial", sans-serif;
            font-weight: 900;
            font-size: 2.2rem;
            letter-spacing: -2px;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 3px 3px 5px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 4000;
            user-select: none;
            opacity: 0;
            transform: scale(0.5);
        }
        
        @keyframes damage-pop {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-30px) scale(1.3); opacity: 1; }
            40% { transform: translateY(-40px) scale(1.0); opacity: 1; }
            80% { transform: translateY(-60px) scale(1.0); opacity: 1; }
            100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
        }

        #cleanup-msg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.85); z-index: 5000; pointer-events: auto;
        }
        #cleanup-msg.active { display: flex; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<div id="viewport">
    <div id="cleanup-msg" class="overlay-screen">
        <h1 class="breathing-text">ç­‰å¾…æˆ°å ´æ¸…ç†ä¸­...</h1>
    </div>

    <div id="main-menu" class="overlay-screen active">
        <img src="pignarok_bg.jpg" class="menu-bg-pig" alt="Pig Background">
        <h1 id="menu-title">è±¬ç¥é»ƒæ˜</h1>
        <div class="sub-title">PIGNAROK ARENA</div>
        <div class="version-text" id="version-display">ç‰ˆæœ¬ 23.46</div>
        <div class="lang-container">
            <button id="lang-zh" class="btn-lang active" onclick="window.setLang('zh-TW')">ä¸­æ–‡</button>
            <button id="lang-en" class="btn-lang" onclick="window.setLang('en-US')">ENG</button>
        </div>
        <button id="btn-create" class="btn-gold" onclick="window.startMusicAndShow('screen-create')">å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)</button>
        <button id="btn-join" class="btn-gold" onclick="window.startMusicAndShow('screen-join')">åŠ å…¥ç¶²çµ¡å°æˆ°</button>
        <button id="btn-tutorial" class="btn-gold" onclick="window.startMusicAndShow('screen-tutorial')">æ•™å­¸æ¨¡å¼ (æŠ€èƒ½å±•ç¤º)</button>
        <div class="studio-footer">JASDEV STUDIO 2025</div>
    </div>

    <div id="screen-tutorial" class="overlay-screen scrollable">
        <h2 id="tutorial-title">é¸æ“‡æ•™å­¸è§’è‰²</h2>
        <p id="tut-char-hint" style="margin-top:10px; font-size:0.9rem; color:#aaa;">è«‹é¸æ“‡ä½ æƒ³è©¦ç”¨çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-tut-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div id="lbl-tut-odin">å¥§ä¸</div>
            </div>
            <div id="mini-tut-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div id="lbl-tut-loki">æ´›åŸº</div>
            </div>
        </div>
        <button id="btn-start-tutorial" class="btn-gold" onclick="window.startTutorial()">é–‹å§‹æ•™å­¸</button>
        <button id="btn-tut-back" class="btn-gold btn-back" onclick="window.UI.showMenu()">è¿”å›</button>
    </div>

    <div id="screen-create" class="overlay-screen scrollable">
        <h2 id="create-title">å‰µå»ºéŠæˆ²æˆ¿é–“</h2>
        <p id="create-name-label">è«‹è¼¸å…¥ä½ çš„æš±ç¨±</p>
        <input type="text" id="host-name" class="input-box" placeholder="åç¨± (16å­—å…§)" maxlength="16">
        <div id="host-presets" class="preset-container"></div>
        
        <p style="margin-top:5px; font-size:0.9rem; color:#aaa;">è³½åˆ¶ (Match Format)</p>
        <select id="match-format" class="input-box" style="width:80%; max-width:300px;">
            <option value="2">3 å±€ 2 å‹ (Best of 3)</option>
            <option value="3">5 å±€ 3 å‹ (Best of 5)</option>
            <option value="5">7 å±€ 5 å‹ (Best of 7)</option>
        </select>
        <p id="create-char-label" style="margin-top:10px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-host-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div id="lbl-host-odin">å¥§ä¸</div>
            </div>
            <div id="mini-host-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div id="lbl-host-loki">æ´›åŸº</div>
            </div>
        </div>
        <button id="btn-do-create" class="btn-gold" onclick="window.Network.createGame()">ç”Ÿæˆæˆ¿é–“</button>
        <button id="btn-create-back" class="btn-gold btn-back" onclick="window.UI.showMenu()">è¿”å›</button>
    </div>

    <div id="screen-join" class="overlay-screen scrollable">
        <h2 id="join-title">åŠ å…¥ç¶²çµ¡å°æˆ°</h2>
        <input type="text" id="join-name" class="input-box" placeholder="ä½ çš„æš±ç¨± (16å­—å…§)" maxlength="16">
        <div id="join-presets" class="preset-container"></div>

        <input type="number" id="join-code" class="input-box" placeholder="4ä½æ•¸æˆ¿è™Ÿ" maxlength="4">
        <p id="join-char-label" style="margin-top:10px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-join-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div id="lbl-join-odin">å¥§ä¸</div>
            </div>
            <div id="mini-join-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div id="lbl-join-loki">æ´›åŸº</div>
            </div>
        </div>
        <p id="join-status" style="color:#55ccff; font-size:0.9rem; min-height:20px;"></p>
        <button class="btn-gold" id="btn-connect" onclick="window.Network.joinGame()">é–‹å§‹é€£ç·š</button>
        <button id="btn-join-back" class="btn-gold btn-back" onclick="window.UI.showMenu()">è¿”å›</button>
    </div>

    <div id="screen-lobby" class="overlay-screen scrollable">
        <h2 id="lobby-title">æº–å‚™å¤§å»³</h2>
        <div class="room-code-display" id="lobby-code">----</div>
        <p id="lobby-share-hint">è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)</p>
        <div id="lobby-hint" class="breathing-text">(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)</div>
        <ul class="player-list" id="lobby-list"></ul>
        <div id="host-controls" style="display:none; width:100%; text-align:center;">
            <button class="btn-gold" id="btn-start-net" onclick="window.Network.hostStartGame()" disabled>é–‹å§‹éŠæˆ²</button>
        </div>
        <div id="client-msg" style="display:none; color:#aaa; margin-top:20px;">ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...</div>
        <button id="btn-leave-room" class="btn-gold btn-back" onclick="window.resetGame()">é›¢é–‹æˆ¿é–“</button>
    </div>

    <div id="turn-hint" class="flashing">è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹</div>
    <div id="tutorial-rage-hint">æ”¶é›†æ€’æ°£ä½¿å‡ºå¥§ç¾©æŠ€èƒ½ï¼</div>
    <div id="game-msg"></div>
    <div id="dmg-container" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:4000; overflow:hidden;"></div>

    <div id="game-ui">
        <button class="circle-btn home-btn" onclick="window.resetGame()" title="å›ä¸»é¸å–®">ğŸ </button>
        <div id="tutorial-pointer" class="tutorial-pointer">ğŸ‘†</div>
        
        <div class="top-right-container">
            <div class="control-group">
                <button class="control-btn vol-btn" onclick="window.adjustMusic(-0.1)">-</button>
                <button id="btn-music" class="control-icon" onclick="window.toggleMusic()">ğŸµ</button>
                <button class="control-btn vol-btn" onclick="window.adjustMusic(0.1)">+</button>
            </div>
            <div class="control-group">
                <button class="control-btn vol-btn" onclick="window.adjustSFX(-0.1)">-</button>
                <button id="btn-sfx" class="control-icon" onclick="window.toggleSFX()">ğŸ”Š</button>
                <button class="control-btn vol-btn" onclick="window.adjustSFX(0.1)">+</button>
            </div>
            <button class="control-btn" style="width:auto; padding:0 15px; border-radius:20px; font-size:0.8rem;" onclick="window.toggleAutoPlay()" id="btn-auto-play">AI ä»£æ‰“</button>
        </div>
        
        <div id="scoreboard" style="display:none;"></div>
        <div id="top-announcer">
            <div id="timer">10</div>
            <div id="move-display">æº–å‚™ä¸­...</div>
        </div>
        <div id="card-description"></div> 
        <div id="bottom-ui-container">
            <div id="card-area">
                <div id="player-hp-card">
                    <div id="player-name-display" class="name-text">å¥§ä¸è±¬</div>
                    <div id="hp-line" class="hp-text">HP: 500/500</div>
                    <div id="fatigue-line" class="fatigue-text">ç–²å‹: 0%</div>
                    <div id="rage-line" class="rage-text">æ€’æ°£: 0%</div>
                </div>
                <div id="card-0" class="card" onclick="window.selectCard(0)">ATKâš”ï¸</div>
                <div id="card-1" class="card" onclick="window.selectCard(1)">MATKğŸª„</div>
                <div id="slot-2-btn" class="card" onclick="window.selectCard(2)">åæ“ŠğŸ›¡ï¸</div>
                <div id="card-3" class="card" onclick="window.selectCard(3)">åå°„ğŸ’</div>
                <div id="defend-card" class="card" onclick="window.selectCard(4)">é˜²ç¦¦ğŸ§±</div>
                <div id="super-card" class="card super" style="display:none;" onclick="window.selectCard(5)">å¥§ç¾©ğŸ”¥</div>
                <div id="super-card-2" class="card super super-blue" style="display:none;" onclick="window.selectCard(6)">é­”å¥§âš¡</div>
                <div id="oracle-btn-card" onclick="window.askOracle()">âœ¨</div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    // --- 1. GLOBAL VARIABLES ---
    const APP_ID_PREFIX = "pig-arena-23-"; 
    const apiKey = ""; 
    const MAX_HP_ODIN = 500; 
    const MAX_HP_LOKI = 400;
    const TURN_TIME = 10; 
    let BASE_CAM_Y = 280; let BASE_CAM_Z = 600;
    let DEFAULT_CAM_POS = new THREE.Vector3(0, BASE_CAM_Y, BASE_CAM_Z);
    const DEFAULT_LOOK_AT = new THREE.Vector3(0, 40, -20);
    let targetWins = 2; 

    let scene, camera, renderer, clock, raycaster;
    let players = [], gameState = 'IDLE', timeLeft = TURN_TIME, selectedSlot = -1, selectedTargetId = -1;
    let timerInterval, cpuThinkTimer, playerRage = { red: 0, blue: 0 };
    let selectedPlayerType = 'Odin';
    let currentDemoId = 0; 
    const mouse = new THREE.Vector2();
    let animationId = null; 
    let myPlayerIndex = 0; 
    let isMultiplayer = false;
    let matchScores = {}; 
    let CARD_NAMES = []; 
    let isTutorialMode = false;
    let isAutoPlay = false;
    let tutorialTurnTimer = null;
    let tutorialState = 'none'; // 'pick_card', 'pick_target', 'none'
    let tutorialCardIndex = 0;
    let lastTutorialUpdate = 0;

    let activeLightnings = [], activeParticles = [], activeProjectiles = [];

    const PRESET_NAMES_ZH = ['å¥§ä¸ä¸‹ç­æ²’', 'æ´›åŸºæ–‘æ–‘', 'è‹±éˆæ®¿æ¸…æ½”å·¥', 'å¥³æ­¦ç¥å¤–é€ä¸­', 'å½©è™¹æ©‹æ”¶è²»å“¡', 'è…°é…¸èƒŒç´¢çˆ¾', 'èŠ¬é‡Œçˆ¾ä¸æ‹†å®¶', 'èŠçˆ¾AIæ ¡é•·', 'è€æŸ¯', 'éŸ“åœ‹é­šä¸¸é•·', 'ä¾¯å‹å®œçµé‡‘è˜­', 'èŠ±åª½', 'é„§ä¸éº—å›', 'å…¬é“ä¼¯'];
    const PRESET_NAMES_EN = ['LokiDoki', 'UnLoki', 'Thornado', 'OhMyOdin', 'OdinYouDidnt', 'TyrDrop', 'KickAsgard', 'KissMyAsgard'];

    // --- 2. TRANSLATION SYSTEM ---
    let currentLang = 'zh-TW';
    const TRANSLATIONS = {
        'zh-TW': {
            title: "è±¬ç¥é»ƒæ˜", singlePlayer: "å–®äººéŠæˆ²", tutorial: "è§’è‰²æ•™å­¸",
            createGameBtn: "å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)", joinGameBtn: "åŠ å…¥ç¶²çµ¡å°æˆ°", tutorialBtn: "æ•™å­¸æ¨¡å¼ (æŠ€èƒ½å±•ç¤º)",
            lobbyHint: "(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)",
            createTitle: "å‰µå»ºéŠæˆ²æˆ¿é–“", enterName: "è«‹è¼¸å…¥ä½ çš„æš±ç¨±", namePlaceholder: "åç¨± (16å­—å…§)",
            chooseChar: "é¸æ“‡ä½ çš„è§’è‰²", doCreateBtn: "ç”Ÿæˆæˆ¿é–“", backBtn: "è¿”å›",
            joinTitle: "åŠ å…¥ç¶²çµ¡å°æˆ°", codePlaceholder: "4ä½æ•¸æˆ¿è™Ÿ", doConnectBtn: "é–‹å§‹é€£ç·š",
            lobbyTitle: "æº–å‚™å¤§å»³", lobbyShare: "è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)", leaveRoom: "é›¢é–‹æˆ¿é–“",
            waitingHost: "ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...", startGame: "é–‹å§‹éŠæˆ²",
            selectCharTitle: "é¸æ“‡ä½ çš„è±¬è±¬æˆ°å£«",
            tutorialSelectTitle: "é¸æ“‡æ•™å­¸è§’è‰²", startTutorial: "é–‹å§‹æ•™å­¸",
            startBattle: "é–‹å§‹æ±ºé¬¥", back: "è¿”å›", backMenu: "å›ä¸»é¸å–®",
            odinName: "å¥§ä¸è±¬", odinDesc: "é›·éœ†èˆ‡æ¦®è€€",
            lokiName: "æ´›åŸºè±¬", lokiDesc: "è©­è¨ˆèˆ‡é®®è‚‰",
            charOdin: "å¥§ä¸", charLoki: "æ´›åŸº",
            turnHint: "è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹", ready: "æº–å‚™ä¸­...",
            moveNames: ["ç‰©ç†æ”»æ“Š", "é­”æ³•æ”»æ“Š", "åæ“Š", "é­”æ³•åå°„", "é˜²ç¦¦", "çµ‚æ¥µå¥§ç¾©"],
            cardNames: { 0: "ç‰©æ”»âš”ï¸", 1: "é­”æ³•ğŸª„", 2: "åæ“ŠğŸ›¡ï¸", 3: "åå°„ğŸ’", 4: "é˜²ç¦¦ğŸ§±", 5: "å¥§ç¾©ğŸ”¥", swap: "ç£éµğŸ§²" },
            tutCardNames: { 5: "ç‰©å¥§ğŸ”¥", 6: "é­”å¥§âš¡" },
            victory: "å‹åˆ©ï¼", gameOver: "å›åˆçµæŸ", restart: "é‡æ–°é–‹å§‹",
            finalVictory: "æ­å–œ {name} æˆç‚ºè±¬æ—åŒ¹æ–¯çš„ç‹è€…ï¼", finalMenu: "å›åˆ°ä¸»é¸å–®",
            swapSkill: "ç£éµäº¤æ›", counterSkill: "é˜²ç¦¦åæ“Š",
            targetLocked: "(ç›®æ¨™é–å®šä¸­)", dead: "èŠ­æ¯”Qå•¦", fatigue: "ç–²å‹", rage: "æ€’æ°£",
            defendFatigue: "é˜²ç¦¦ç–²å‹ä¸­", defend: "é˜²ç¦¦", tired: "åŠ›ç›¡ğŸ§±",
            cleanup: "ç­‰å¾…æˆ°å ´æ¸…ç†ä¸­...",
            incomplete: "åç¨±æˆ–æˆ¿è™Ÿä¸å®Œæ•´", connError: "é€£ç·šéŒ¯èª¤ï¼Œè«‹é‡è©¦", hostLeft: "æˆ¿ä¸»å·²é›¢é–‹", full: "æˆ¿é–“å·²æ»¿", connecting: "é€£ç·šä¸­...",
            aiAuto: "AI ä»£æ‰“", aiOn: "AI ON",
            cardDescs: {
                0: {
                    "Odin": "é€ æˆ ATK80 ç‰©ç†å‚·å®³(æ“Šä¸­å°æ‰‹ +35% ç‰©ç†æ€’æ°£)",
                    "Loki": "é€ æˆ ATK60 ç‰©ç†å‚·å®³(æ“Šä¸­å°æ‰‹ +35% ç‰©ç†æ€’æ°£)",
                    "default": "é€ æˆç‰©ç†å‚·å®³"
                },
                1: {
                    "Odin": "é€ æˆ MATK90 é­”æ³•å‚·å®³ (æ“Šä¸­å°æ‰‹ +35% é­”æ³•æ€’æ°£)",
                    "Loki": "é€ æˆ MATK80 é­”æ³•å‚·å®³ä¸¦æœ‰ 60%æ©Ÿç‡æ¿ºå°„å¦ä¸€å°æ‰‹(æ“Šä¸­å°æ‰‹ +35% é­”æ³•æ€’æ°£)",
                    "default": "é€ æˆé­”æ³•å‚·å®³"
                },
                2: { 
                    "Odin": "é€²å…¥åæ“Šç‹€æ…‹ï¼Œå—åˆ°ç‰©ç†æ”»æ“Šï¼Œè‡ªå‹•åæ“Š ATK80 çš„å‚·å®³ä¸¦è‡ªèº«å…å‚· (+17%æ€’æ°£)", 
                    "Loki": "é€²å…¥åæ“Šç‹€æ…‹ï¼Œå—åˆ°ç‰©ç†æ”»æ“Šï¼Œä¸Ÿå‡ºç£éµçµ¦éš¨æ©Ÿè§€æˆ°çš„å°æ‰‹ä¸¦è½‰ç§»å‚·å®³" 
                },
                3: "é€²å…¥é­”æ³•åå°„ç‹€æ…‹ï¼Œè©²å›åˆå°æ‰‹å°ä½ æ–½æ”¾çš„é­”æ³•ï¼Œæœƒä»¥ 80%çš„å‚·å®³åå°„çµ¦å°æ‰‹ (å¥§ç¾©)",
                4: "å¤§å¹…æ¸›å‚·ï¼Œä½†å¢åŠ ç–²å‹å€¼",
                5: { 
                    "Odin": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£çš„æ¯€æ¸›æ€§é€£æ“Šï¼Œæ“Šä¸­æ²’é˜²ç¦¦çš„å°æ‰‹æœƒè‡ªå‹•å›å¾© 83% çš„æ€’æ°£", 
                    "Loki": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£çš„æ¯€æ¸›æ€§é€£æ“Š" 
                },
                6: { 
                    "Odin": "å¬å–šé›·é›»é¢¨æš´æ‰“æ“Šå ´ä¸Šæ‰€æœ‰æ•µäºº (AOE)", 
                    "Loki": "èˆ‡å°æŒ‡æ•µäººäº’æ› 70% ç”Ÿå‘½å€¼ (75% æˆåŠŸç‡)" 
                } 
            },
            logBlock: "æ ¼æª”ï¼", logCounter: "çš„åæ“Šåœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼",
            logReflect: "çš„åå°„åœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼", logHit: "çš„æ”»æ“Šï¼",
            playerSuffix: " (æˆ‘)", cpuPrefix: "(CPU) ",
            lockingTargets: "é–å®šç›®æ¨™ï¼",
            waitingOthers: "ç­‰å¾…å…¶ä»–ç©å®¶...",
            roundWinner: "å›åˆå‹åˆ©è€…ï¼š", nextRoundIn: "ç­‰å¾…ç©å®¶é€£ç·šåŒæ­¥ä¸­...",
            currentRound: "ç•¶å‰å±€åˆ†",
            dmgLog: "é€ æˆ {dmg} å‚·å®³ï¼", winSuffix: "å‹",
            tutRageHint: "æ”¶é›†æ€’æ°£ä½¿å‡ºå¥§ç¾©æŠ€èƒ½ï¼",
            randomName: "ğŸ² éš¨æ©Ÿç”Ÿæˆåå­—",
            skillPhys: "ç‰©ç†æ”»æ“Š", skillMag: "é­”æ³•æ”»æ“Š", skillUlt: "å¥§ç¾©",
            combatLog: "{attacker} å° {target} ä½¿ç”¨ {skill}, é€ æˆ {dmg} å‚·å®³!",
            noTarget: "ç„¡ç›®æ¨™ï¼", redirected: "å‚·å®³è½‰ç§»ï¼",
            hpSwapSuccess: "HP äº¤æ›æˆåŠŸï¼ï¼", hpSwapFail: "HP äº¤æ›å¤±æ•—ï¼ï¼",
            versionPrefix: "ç‰ˆæœ¬", tutSelectHint: "è«‹é¸æ“‡ä½ æƒ³è©¦ç”¨çš„è§’è‰²"
        },
        'en-US': {
            title: "PIGNAROK", singlePlayer: "Single Player", tutorial: "Tutorial",
            createGameBtn: "Host Game (Online supported)", joinGameBtn: "Join Arena", tutorialBtn: "Tutorial Mode (Showcase)",
            lobbyHint: "(CPU will fill empty slots if < 4 players)",
            createTitle: "Create Game Room", enterName: "Enter your nickname", namePlaceholder: "Name (Max 16 chars)",
            chooseChar: "Choose Your Character", doCreateBtn: "Create Room", backBtn: "Back",
            joinTitle: "Join Network Arena", codePlaceholder: "4-Digit Room Code", doConnectBtn: "Connect",
            lobbyTitle: "Lobby", lobbyShare: "Share Room Code (Max 4 Players)", leaveRoom: "Leave Room",
            waitingHost: "Waiting for host to start...", startGame: "Start Game",
            selectCharTitle: "Select Your Warrior",
            tutorialSelectTitle: "Tutorial Character", startTutorial: "Start Tutorial",
            startBattle: "Start Battle", back: "Back", backMenu: "Main Menu",
            odinName: "Odin", odinDesc: "Thunder & Glory",
            lokiName: "Loki", lokiDesc: "Tricks & Meat",
            charOdin: "Odin", charLoki: "Loki",
            turnHint: "Select a card below and tap an enemy", ready: "Ready...",
            moveNames: ["Melee", "Magic", "Counter", "Reflect", "Defend", "Ultimate"],
            cardNames: { 0: "Meleeâš”ï¸", 1: "MagicğŸª„", 2: "CountğŸ›¡ï¸", 3: "ReflğŸ’", 4: "DefğŸ§±", 5: "UltğŸ”¥", swap: "MagnetğŸ§²" },
            tutCardNames: { 5: "Phys UltğŸ”¥", 6: "Mag Ultâš¡" },
            victory: "VICTORY!", gameOver: "GAME OVER", restart: "Play Again", finalVictory: "Congratulations {name}, the New King of Piglympus!", finalMenu: "Main Menu",
            swapSkill: "Magnet Swap", counterSkill: "Counter",
            targetLocked: "(Target Locked)", dead: "Barbecued", fatigue: "Fatigue", rage: "Rage",
            defendFatigue: "Can't Block!", defend: "Defend", tired: "TiredğŸ§±",
            cleanup: "Waiting for battlefield cleanup...",
            incomplete: "Name or Code incomplete", connError: "Connection Error", hostLeft: "Host disconnected", full: "Room Full", connecting: "Connecting...",
            aiAuto: "AI Auto", aiOn: "AI ON",
            cardDescs: {
                0: {
                    "Odin": "Deals 80 Phys DMG (+35% Red Rage)",
                    "Loki": "Deals 60 Phys DMG (+35% Red Rage)",
                    "default": "Deals Physical DMG"
                },
                1: {
                    "Odin": "Deals 90 Magic DMG (+35% Blue Rage)",
                    "Loki": "Deals 80 Magic DMG + 60% Splash chance (+35% Blue Rage)",
                    "default": "Deals Magic DMG"
                },
                2: { 
                    "Odin": "Counters Phys attacks with 80 DMG & Immunity (+17% Rage)", 
                    "Loki": "Redirects Phys attack to random bystander (Magnet)" 
                },
                3: "Reflects 80% Magic damage back",
                4: "Reduces damage significantly, adds Fatigue",
                5: { 
                    "Odin": "Consumes Max Rage for devastating combo, regains 83% Rage if hit undefended", 
                    "Loki": "Consumes Max Rage for devastating combo" 
                },
                6: { 
                    "Odin": "Summons Lightning Storm on all enemies (AOE)", 
                    "Loki": "Swaps 70% HP with enemy (75% Chance)" 
                }
            },
            logBlock: "Blocked", logCounter: "'s counter failed against Ultimate!",
            logReflect: "'s reflect failed against Ultimate!", logHit: "'s attack!",
            playerSuffix: " (Me)", cpuPrefix: "(CPU) ",
            lockingTargets: "Locking Targets!",
            waitingOthers: "Waiting for others...",
            roundWinner: "Round Winner: ", nextRoundIn: "Waiting for player sync...",
            currentRound: "Current Scores",
            dmgLog: "hit for {dmg} damage!", winSuffix: " Wins",
            tutRageHint: "Collect Rage to unleash Ultimate!",
            randomName: "ğŸ² Randomize ID",
            skillPhys: "Physical Attack", skillMag: "Magic Attack", skillUlt: "Ultimate",
            combatLog: "{attacker} used {skill} on {target} for {dmg} damage!",
            noTarget: "No Target!", redirected: "Redirected!",
            hpSwapSuccess: "HP Swap Success!!", hpSwapFail: "HP Swap Failed!!",
            versionPrefix: "Version", tutSelectHint: "Select the character you want to try"
        }
    };

    // --- 3. BASIC HELPERS ---
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function move(obj, target, ms) { return new Promise(res => { const start = obj.position.clone(), t = performance.now(); function up() { let p = Math.min(1, (performance.now() - t) / ms); obj.position.lerpVectors(start, target, p); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    function safeSetText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; }

    function renderNamePresets(containerId, inputId) {
        const container = document.getElementById(containerId);
        if (!container) return; container.innerHTML = '';
        const btn = document.createElement('button');
        btn.className = 'btn-small'; btn.style.marginBottom = '15px';
        btn.innerHTML = TRANSLATIONS[currentLang].randomName;
        btn.onclick = () => {
            const input = document.getElementById(inputId);
            const names = currentLang === 'zh-TW' ? PRESET_NAMES_ZH : PRESET_NAMES_EN;
            const randName = names[Math.floor(Math.random() * names.length)];
            if (input) input.value = randName;
            SoundEngine.init(); SoundEngine.play('click');
        };
        container.appendChild(btn);
    }

    function setCardHTML(id, name, statLabel, val, color) {
        const el = document.getElementById(id);
        if(el) {
            el.innerHTML = `
                <div style="margin-bottom: 3px; font-size: 0.8rem;">${name}</div>
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; line-height: 1;">
                    <span style="color:${color}; font-size: 1.4rem; font-weight: 800;">${val}</span>
                    <span style="color:${color}; font-size: 0.65rem; font-weight: bold; margin-top: 1px;">${statLabel}</span>
                </div>
            `;
        }
    }
    
    function setLargeTextCard(id, name) {
        const el = document.getElementById(id);
        if(el) {
            el.innerHTML = `<div style="font-size: 1.35rem; font-weight: 800; line-height: 1.1;">${name}</div>`;
        }
    }

    window.updateText = function() {
        const t = TRANSLATIONS[currentLang];
        safeSetText('menu-title', t.title);
        safeSetText('btn-create', t.createGameBtn);
        safeSetText('btn-join', t.joinGameBtn);
        safeSetText('btn-tutorial', t.tutorialBtn);
        safeSetText('lobby-hint', t.lobbyHint);
        safeSetText('create-title', t.createTitle);
        safeSetText('create-name-label', t.enterName);
        const hostName = document.getElementById('host-name'); if(hostName) hostName.placeholder = t.namePlaceholder;
        safeSetText('create-char-label', t.chooseChar);
        safeSetText('btn-do-create', t.doCreateBtn);
        safeSetText('btn-create-back', t.backBtn);
        safeSetText('join-title', t.joinTitle);
        const joinName = document.getElementById('join-name'); if(joinName) joinName.placeholder = t.namePlaceholder;
        const joinCode = document.getElementById('join-code'); if(joinCode) joinCode.placeholder = t.codePlaceholder;
        safeSetText('join-char-label', t.chooseChar);
        safeSetText('btn-connect', t.doConnectBtn);
        safeSetText('btn-join-back', t.backBtn);
        safeSetText('tutorial-title', t.tutorialSelectTitle);
        safeSetText('btn-start-tutorial', t.startTutorial);
        safeSetText('btn-tut-back', t.backBtn);
        safeSetText('lobby-title', t.lobbyTitle);
        safeSetText('lobby-share-hint', t.lobbyShare);
        safeSetText('btn-leave-room', t.leaveRoom);
        safeSetText('client-msg', t.waitingHost);
        const verEl = document.getElementById('version-display'); if(verEl) verEl.innerText = `${t.versionPrefix} 23.46`;
        const tutSelHint = document.getElementById('tut-char-hint'); if(tutSelHint) tutSelHint.innerText = t.tutSelectHint;
        safeSetText('lbl-host-odin', t.charOdin); safeSetText('lbl-host-loki', t.charLoki);
        safeSetText('lbl-join-odin', t.charOdin); safeSetText('lbl-join-loki', t.charLoki);
        safeSetText('lbl-tut-odin', t.charOdin); safeSetText('lbl-tut-loki', t.charLoki);
        safeSetText('turn-hint', t.turnHint);
        
        setLargeTextCard('card-3', t.cardNames[3]); 
        setLargeTextCard('defend-card', t.cardNames[4]); 

        const aiBtn = document.getElementById('btn-auto-play'); if(aiBtn) aiBtn.innerText = isAutoPlay ? t.aiOn : t.aiAuto;
        const cleanupMsg = document.querySelector('#cleanup-msg h1'); if(cleanupMsg) cleanupMsg.innerText = t.cleanup;
        const tutHint = document.getElementById('tutorial-rage-hint');
        if (tutHint) { tutHint.style.display = isTutorialMode ? 'block' : 'none'; if (gameState === 'WAITING' || gameState === 'IDLE') tutHint.innerText = t.tutRageHint; }
        CARD_NAMES = [...t.moveNames]; 
        if (players.length > 0) {
            const p = players[myPlayerIndex]; 
            if(p) {
                if (p.type === 'Odin') {
                    setCardHTML('card-0', t.cardNames[0], 'ATK', 80, '#ffaa00');
                    setCardHTML('card-1', t.cardNames[1], 'MATK', 90, '#55ccff');
                    setLargeTextCard('slot-2-btn', t.cardNames[2]); 
                    CARD_NAMES[2] = t.counterSkill;
                } else {
                    setCardHTML('card-0', t.cardNames[0], 'ATK', 60, '#ffaa00');
                    setCardHTML('card-1', t.cardNames[1], 'MATK', 80, '#55ccff');
                    setLargeTextCard('slot-2-btn', t.cardNames.swap); 
                    CARD_NAMES[2] = t.swapSkill;
                }

                const defBtn = document.getElementById('defend-card');
                if (defBtn) { 
                    if (p.fatigue >= 100) { 
                        setLargeTextCard('defend-card', t.tired); 
                        defBtn.classList.add('disabled');
                    } else { 
                        setLargeTextCard('defend-card', t.cardNames[4]); 
                        defBtn.classList.remove('disabled');
                    } 
                }
                
                if(isTutorialMode) { 
                    setLargeTextCard('super-card', t.tutCardNames[5]); 
                    setLargeTextCard('super-card-2', t.tutCardNames[6]); 
                } else { 
                    setLargeTextCard('super-card', t.cardNames[5]); 
                }
                players.forEach(pl => pl.refreshLabel());
                safeSetText('player-name-display', p.getDisplayName());
            }
        } else {
             // Defaults
        }
    };
    
    window.startMusicAndShow = function(screenId) { SoundEngine.ensureBGM(0.2); if(screenId === 'screen-create') window.UI.showCreate(); else if(screenId === 'screen-join') window.UI.showJoin(); else if(screenId === 'screen-tutorial') window.UI.showTutorial(); };

    window.toggleAutoPlay = function() { isAutoPlay = !isAutoPlay; const btn = document.getElementById('btn-auto-play'); const t = TRANSLATIONS[currentLang]; if(btn) { btn.classList.toggle('active', isAutoPlay); btn.innerText = isAutoPlay ? t.aiOn : t.aiAuto; } SoundEngine.play('click'); };

    window.toggleMusic = function() { const on = SoundEngine.toggleMusic(); const btn = document.getElementById('btn-music'); if (btn) { btn.classList.toggle('off', !on); btn.classList.toggle('active', on); } SoundEngine.init(); };

    window.toggleSFX = function() { const on = SoundEngine.toggleSFX(); const btn = document.getElementById('btn-sfx'); if (btn) { btn.classList.toggle('off', !on); btn.classList.toggle('active', on); btn.innerText = on ? 'ğŸ”Š' : 'ğŸ”‡'; } SoundEngine.init(); };

    window.adjustMusic = function(delta) { let v = SoundEngine.musicVolume + delta; if(v < 0) v = 0; if(v > 1) v = 1; SoundEngine.setMusicVolume(v); showMove(`Music: ${Math.round(v*100)}%`); setTimeout(() => hideMove(), 1000); };
    window.adjustSFX = function(delta) { let v = SoundEngine.sfxVolume + delta; if(v < 0) v = 0; if(v > 1) v = 1; SoundEngine.setSFXVolume(v); SoundEngine.play('click'); showMove(`SFX: ${Math.round(v*100)}%`); setTimeout(() => hideMove(), 1000); };

    window.setLang = function(lang) { currentLang = lang; document.getElementById('lang-zh').classList.toggle('active', lang === 'zh-TW'); document.getElementById('lang-en').classList.toggle('active', lang === 'en-US'); window.updateText(); };

    const SoundEngine = { ctx: null, init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); }, 
        isMusicEnabled: true, isSFXEnabled: true, musicVolume: 0.4, sfxVolume: 0.8, BASE_BGM_VOL: 0.05, 
        setMusicVolume(v) { this.musicVolume = v; }, setSFXVolume(v) { this.sfxVolume = v; },
        ensureBGM(vol) { this.init(); if (vol !== undefined) this.musicVolume = vol; if (this.isMusicEnabled && !this.isPlayingBGM) { this.playBGM(); } },
        toggleMusic() { this.isMusicEnabled = !this.isMusicEnabled; if (this.isMusicEnabled) { this.playBGM(); } else { this.stopBGM(); } return this.isMusicEnabled; },
        toggleSFX() { this.isSFXEnabled = !this.isSFXEnabled; return this.isSFXEnabled; },
        bgmOscillators: [], isPlayingBGM: false, melodyA: [{n:74,t:0,d:0.25},{n:74,t:0.5,d:0.25},{n:74,t:1,d:0.25},{n:76,t:1.5,d:0.25},{n:77,t:2,d:0.25},{n:76,t:2.5,d:0.25},{n:74,t:3,d:0.25},{n:69,t:3.5,d:0.25},{n:62,t:4,d:0.25},{n:69,t:4.5,d:0.25},{n:74,t:5,d:0.25},{n:77,t:5.5,d:0.25},{n:81,t:6,d:0.25},{n:82,t:6.25,d:0.25},{n:81,t:6.5,d:0.25},{n:77,t:7,d:0.25},{n:74,t:8,d:0.25},{n:74,t:8.5,d:0.25},{n:74,t:9,d:0.25},{n:76,t:9.5,d:0.25},{n:77,t:10,d:0.25},{n:76,t:10.5,d:0.25},{n:74,t:11,d:0.25},{n:69,t:11.5,d:0.25},{n:86,t:12,d:0.25},{n:81,t:13,d:0.25},{n:77,t:14,d:0.25},{n:74,t:15,d:0.5}, {n:82,t:32,d:1.5},{n:81,t:33.5,d:0.5},{n:77,t:34,d:2}, {n:84,t:36,d:1.5},{n:82,t:37.5,d:0.5},{n:81,t:38,d:1},{n:86,t:39,d:1}],
        playBGM() { if (!this.isMusicEnabled || this.isPlayingBGM) return; this.init(); this.isPlayingBGM = true; this.scheduleNote(0); },
        stopBGM() { this.isPlayingBGM = false; this.bgmOscillators.forEach(o => { try{o.osc.stop();o.gain.disconnect();}catch(e){} }); this.bgmOscillators=[]; if(this.bgmTimer) clearTimeout(this.bgmTimer); },
        midiToFreq(m){return 440*Math.pow(2,(m-69)/12);},
        scheduleNote(beatIndex){
            if(!this.isPlayingBGM)return;
            const loopLen=64; const curBeat=beatIndex%loopLen; const beatDur=60/165;
            const notes=this.melodyA.filter(n=>Math.abs(n.t-curBeat)<0.01);
            notes.forEach(note=>{
                const osc=this.ctx.createOscillator();const gain=this.ctx.createGain();
                osc.connect(gain);gain.connect(this.ctx.destination);
                osc.type='sawtooth'; osc.frequency.value=this.midiToFreq(note.n);
                const now=this.ctx.currentTime; const vol = this.BASE_BGM_VOL * this.musicVolume;
                gain.gain.setValueAtTime(vol,now); gain.gain.exponentialRampToValueAtTime(0.001,now+(note.d*beatDur));
                osc.start(now); osc.stop(now+(note.d*beatDur)); this.bgmOscillators.push({osc,gain});
            });
            if(beatIndex%1===0) this.play('bonk'); 
            this.bgmTimer=setTimeout(()=>{this.scheduleNote(beatIndex+0.25);},(beatDur*0.25)*1000);
        },
        play(type) { if (!this.isSFXEnabled) return; this.init(); const now = this.ctx.currentTime; const masterGain = this.ctx.createGain(); masterGain.connect(this.ctx.destination); masterGain.gain.setValueAtTime(0.4 * this.sfxVolume, now); const osc = this.ctx.createOscillator(); const env = this.ctx.createGain(); osc.connect(env); env.connect(masterGain); let dur = 0.3; switch(type) { case 'click': osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); env.gain.setValueAtTime(0.2, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.1); dur=0.1; break; case 'slash': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(450, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.2); env.gain.setValueAtTime(0.2, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'magic': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(2000, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.15); env.gain.setValueAtTime(0.2, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.3); dur=0.3; break; case 'hit': osc.type = 'sine'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now+0.15); env.gain.setValueAtTime(0.4, now); env.gain.linearRampToValueAtTime(0, now+0.15); dur=0.15; break; case 'counter': osc.type = 'square'; osc.frequency.setValueAtTime(1100, now); env.gain.setValueAtTime(0.1, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'super': osc.type = 'sawtooth'; env.gain.setValueAtTime(0.3, now); osc.frequency.setValueAtTime(90, now); env.gain.exponentialRampToValueAtTime(0.001, now+1.2); dur=1.2; break; case 'bonk': osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); env.gain.setValueAtTime(0.8, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.2); dur=0.2; break; case 'ding': osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(2400, now + 0.05); env.gain.setValueAtTime(0.5, now); env.gain.exponentialRampToValueAtTime(0.001, now + 0.3); dur = 0.3; break; case 'skid': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(400, now + 0.4); env.gain.setValueAtTime(0.3, now); env.gain.linearRampToValueAtTime(0, now + 0.4); dur=0.4; break; case 'electric': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(500, now); osc.frequency.linearRampToValueAtTime(2000, now + 0.1); osc.frequency.linearRampToValueAtTime(500, now + 0.2); env.gain.setValueAtTime(0.2, now); env.gain.exponentialRampToValueAtTime(0.01, now + 0.3); dur=0.3; break; } osc.start(now); osc.stop(now+dur); setTimeout(() => { if(osc) osc.disconnect(); if(env) env.disconnect(); if(masterGain) masterGain.disconnect(); }, 2000); } 
    };

    function showMove(text) { const md = document.getElementById('move-display'); if(md) { md.innerText = text; md.style.opacity = "1"; md.classList.add('announce-anim'); } }
    function hideMove() { const md = document.getElementById('move-display'); if(md) { md.style.opacity = "0"; md.classList.remove('announce-anim'); } }

    function spawnDamageNumber(target, amount, colorOverride = null) { 
        if (!target) return; const div = document.createElement('div'); div.className = 'damage-popup'; 
        if (typeof amount === 'number') { div.innerText = "-" + amount; div.style.color = colorOverride || "#ff0000"; } 
        else if (typeof amount === 'string' && amount.startsWith("+")) { div.innerText = amount; div.style.color = colorOverride || "#55ccff"; } 
        else { div.innerText = amount; div.style.color = colorOverride || "#ffff00"; } 
        const pos = target.group.position.clone().add(new THREE.Vector3(0, 40, 0)); const vector = pos.project(camera); 
        const x = (vector.x * .5 + .5) * window.innerWidth; const y = (-(vector.y * .5) + .5) * window.innerHeight; 
        div.style.left = `${x}px`; div.style.top = `${y}px`; div.style.animation = 'damage-pop 0.8s ease-out forwards'; 
        const container = document.getElementById('dmg-container'); if(container) container.appendChild(div); setTimeout(() => { if (div.parentNode) div.parentNode.removeChild(div); }, 800); 
    }

    function resetCamera() { if (camera) { adjustCameraForResponsive(); camera.position.copy(DEFAULT_CAM_POS); camera.lookAt(DEFAULT_LOOK_AT); } }
    
    function adjustCameraForResponsive(snap = false) { 
        if (!camera || !renderer) return; const aspect = window.innerWidth / window.innerHeight; let targetY = BASE_CAM_Y; let targetZ = BASE_CAM_Z; 
        if (aspect > 1.2) { targetY = 240; targetZ = 550; } else if (aspect < 0.6) { targetZ = 850; targetY = 320; } 
        let rotY = 0; if (myPlayerIndex === 1) rotY = Math.PI; else if (myPlayerIndex === 2) rotY = Math.PI/2; else if (myPlayerIndex === 3) rotY = -Math.PI/2;
        const basePos = new THREE.Vector3(0, targetY, targetZ); basePos.applyAxisAngle(new THREE.Vector3(0,1,0), rotY); DEFAULT_CAM_POS.copy(basePos);
        if (snap) { camera.position.copy(DEFAULT_CAM_POS); camera.lookAt(DEFAULT_LOOK_AT); } 
        else if (gameState === 'WAITING' || gameState === 'IDLE') { camera.position.lerp(DEFAULT_CAM_POS, 0.1); camera.lookAt(DEFAULT_LOOK_AT); } 
    }

    function showCardDescription(index) {
        const descEl = document.getElementById('card-description'); const t = TRANSLATIONS[currentLang]; const p = players[myPlayerIndex]; if (!p) return;
        let desc = "";
        if (typeof t.cardDescs[index] === 'object') {
            desc = t.cardDescs[index][p.type] || t.cardDescs[index]['default'];
        } else {
            desc = t.cardDescs[index];
        }
        if (descEl) { descEl.innerText = desc; descEl.style.opacity = 1; }
    }
    function hideCardDescription() { const el = document.getElementById('card-description'); if(el) el.style.opacity = 0; }

    function createUltraTextSprite(colorHex) {
        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 128; 
        ctx.fillStyle = colorHex; ctx.font = 'bold 80px "Cinzel", "Arial Black"'; ctx.textAlign = 'center'; ctx.shadowColor = colorHex; ctx.shadowBlur = 20; ctx.fillText("ULTRA", 256, 90); 
        const texture = new THREE.CanvasTexture(canvas); const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false }); return new THREE.Sprite(mat); 
    }

    function createEmojiSprite(emoji) {
        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 256; canvas.height = 256; ctx.font = '150px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(emoji, 128, 128);
        const texture = new THREE.CanvasTexture(canvas); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false })); sprite.scale.set(15, 15, 1); return sprite;
    }

    // --- GAME STATE HELPERS ---
    function updateHPUI() {
        const t = TRANSLATIONS[currentLang]; const p = players[myPlayerIndex]; if (!p) return; 
        if (!isTutorialMode) {
            const hpLine = document.getElementById('hp-line'), fatLine = document.getElementById('fatigue-line'), rageLine = document.getElementById('rage-line'), defBtn = document.getElementById('defend-card'), superBtn = document.getElementById('super-card'), superBtn2 = document.getElementById('super-card-2');
            if(superBtn2) superBtn2.style.display = 'none';
            if(hpLine) hpLine.innerText = `HP: ${p.hp}/${p.maxHP}`;
            if(fatLine) { fatLine.innerText = `${t.fatigue}: ${p.fatigue}%`; fatLine.style.color = p.fatigue >= 100 ? "#ff0000" : "#ffaa00"; }
            const curRage = Math.floor(Math.max(p.rage.red, p.rage.blue));
            if(rageLine) { rageLine.innerText = `${t.rage}: ${curRage}%`; rageLine.style.color = p.rage.red > p.rage.blue ? "#ff5555" : (p.rage.blue > p.rage.red ? "#55ccff" : "#ffaa00"); }
            if (defBtn) { if (p.fatigue >= 100) { defBtn.classList.add('disabled'); setLargeTextCard('defend-card', t.tired); } else { defBtn.classList.remove('disabled'); setLargeTextCard('defend-card', t.cardNames[4]); } }
            if (superBtn) {
                superBtn.className = "card super"; 
                if (curRage >= 99) { superBtn.style.display = 'flex'; if (p.rage.blue > p.rage.red) { superBtn.classList.add('super-blue'); setLargeTextCard('super-card', t.cardNames[5]); } else { superBtn.classList.add('super-red'); setLargeTextCard('super-card', t.cardNames[5]); } } else { superBtn.style.display = 'none'; }
            }
        } else {
            const hpLine = document.getElementById('hp-line'), fatLine = document.getElementById('fatigue-line'), rageLine = document.getElementById('rage-line'), defBtn = document.getElementById('defend-card'), superBtn = document.getElementById('super-card'), superBtn2 = document.getElementById('super-card-2');
            if(hpLine) hpLine.innerText = `HP: ${p.hp}/${p.maxHP}`; if(fatLine) { fatLine.innerText = `${t.fatigue}: ${p.fatigue}%`; }
            const curRage = Math.floor(Math.max(p.rage.red, p.rage.blue)); if(rageLine) { rageLine.innerText = `${t.rage}: ${curRage}%`; }
            if(defBtn) setLargeTextCard('defend-card', t.cardNames[4]);
            if (superBtn) { if (p.rage.red >= 100) { superBtn.style.display = 'flex'; superBtn.className = "card super super-red"; setLargeTextCard('super-card', t.tutCardNames[5]); } else { superBtn.style.display = 'none'; } }
            if (superBtn2) { if (p.rage.blue >= 100) { superBtn2.style.display = 'flex'; superBtn2.className = "card super super-blue"; setLargeTextCard('super-card-2', t.tutCardNames[6]); } else { superBtn2.style.display = 'none'; } }
        }
        players.forEach(p => { if (p.selectionRing) p.selectionRing.visible = (selectedTargetId === p.id); if (p.updateLabel) p.updateLabel(); if (p.brokenShieldIcon) { p.brokenShieldIcon.visible = p.showBrokenShield; } });
        if (window.UI) window.UI.updateScoreboard(); 
    }

    function gainRage(p, isRed, amt) { if (isRed) { p.rage.blue = 0; p.rage.red = Math.min(100, p.rage.red + amt); } else { p.rage.red = 0; p.rage.blue = Math.min(100, p.rage.blue + amt); } if (p.id === 0) { playerRage.red = p.rage.red; playerRage.blue = p.rage.blue; } updateHPUI(); if(p.updateLabel) p.updateLabel(); }
    
    function loseRage(p, isRed) { const currentRage = isRed ? p.rage.red : p.rage.blue; if (currentRage >= 100) return; if (isRed) p.rage.red = Math.max(0, p.rage.red - 30); else p.rage.blue = Math.max(0, p.rage.blue - 30); if (p.id === 0) { playerRage.red = p.rage.red; playerRage.blue = p.rage.blue; } }

    // --- 4. CORE OBJECTS ---
    window.Online = { isHost: false, myName: "Player", roomCode: "", peer: null, myPeerId: "", connections: [], hostConn: null, playerMap: [], hasActed: false, matchConfig: { targetWins: 2 } };

    window.UI = {
        screens: ['main-menu', 'screen-create', 'screen-join', 'screen-lobby', 'screen-tutorial', 'game-ui'],
        show(id) { this.screens.forEach(s => { const el = document.getElementById(s); if(el) { el.classList.remove('active'); el.style.display = 'none'; } }); const t = document.getElementById(id); if(t) { t.style.display = 'flex'; setTimeout(()=>t.classList.add('active'), 10); if(id === 'game-ui') t.style.display = 'block'; } },
        showMenu() { this.show('main-menu'); },
        showCreate() { selectedPlayerType = 'Odin'; document.getElementById('mini-host-odin').className = "mini-card active"; document.getElementById('mini-host-loki').className = "mini-card"; renderNamePresets('host-presets', 'host-name'); this.show('screen-create'); },
        showJoin() { selectedPlayerType = 'Odin'; document.getElementById('mini-join-odin').className = "mini-card active"; document.getElementById('mini-join-loki').className = "mini-card"; document.getElementById('join-status').innerText = ""; document.getElementById('btn-connect').disabled = false; renderNamePresets('join-presets', 'join-name'); this.show('screen-join'); },
        showTutorial() { selectedPlayerType = 'Odin'; document.getElementById('mini-tut-odin').className = "mini-card active"; document.getElementById('mini-tut-loki').className = "mini-card"; this.show('screen-tutorial'); },
        updateLobby(roomCode, playersList) {
            this.show('screen-lobby'); document.getElementById('lobby-code').innerText = roomCode; const list = document.getElementById('lobby-list'); list.innerHTML = "";
            playersList.forEach(p => { const li = document.createElement('li'); let html = `<span>${p.name} <small style="color:#aaa">(${p.type})</small></span> <div>`; if (p.isHost) html += `<span class="tag-host">HOST</span> `; if (p.peerId === window.Online.myPeerId) html += `<span class="tag-me">YOU</span>`; html += `</div>`; li.innerHTML = html; list.appendChild(li); });
            if (window.Online.isHost) { document.getElementById('host-controls').style.display = 'block'; document.getElementById('client-msg').style.display = 'none'; document.getElementById('btn-start-net').disabled = false; } else { document.getElementById('host-controls').style.display = 'none'; document.getElementById('client-msg').style.display = 'block'; }
        },
        updateScoreboard() {
            const sb = document.getElementById('scoreboard'); sb.innerHTML = `<h3 style="margin:0 0 10px 0; color:#ff99cc; border-bottom:1px solid #555;">${TRANSLATIONS[currentLang].currentRound}</h3>`;
            players.forEach(p => { const wins = matchScores[p.id] || 0; const crowns = "ğŸ‘‘".repeat(wins); const row = document.createElement('div'); row.className = 'score-row'; row.innerHTML = `${p.getDisplayName()} <span class="score-num">${crowns}</span>`; sb.appendChild(row); });
        }
    };

    window.selectMiniChar = function(type) { selectedPlayerType = type; SoundEngine.init(); SoundEngine.play('click'); const setUI = (prefix) => { const el1 = document.getElementById(prefix + '-odin'), el2 = document.getElementById(prefix + '-loki'); if (el1) el1.className = type === 'Odin' ? "mini-card active" : "mini-card"; if (el2) el2.className = type === 'Loki' ? "mini-card active" : "mini-card"; }; setUI('mini-host'); setUI('mini-join'); setUI('mini-tut'); };

    window.Network = {
        createGame() {
            const name = document.getElementById('host-name').value.trim(); const format = document.getElementById('match-format').value; if(!name) return alert(TRANSLATIONS[currentLang].incomplete);
            window.Online.isHost = true; window.Online.myName = name; window.Online.roomCode = Math.floor(1000 + Math.random() * 9000).toString(); window.Online.matchConfig.targetWins = parseInt(format) || 2; targetWins = window.Online.matchConfig.targetWins;
            window.Online.peer = new Peer(APP_ID_PREFIX + window.Online.roomCode);
            window.Online.peer.on('open', (id) => { window.Online.myPeerId = id; window.Online.playerMap = [{ name: window.Online.myName, isHost: true, peerId: id, isCpu: false, type: selectedPlayerType }]; window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap); });
            window.Online.peer.on('error', (err) => { alert(TRANSLATIONS[currentLang].connError); location.reload(); });
            window.Online.peer.on('connection', (conn) => { if(window.Online.playerMap.length >= 4) { conn.on('open', () => { conn.send({type:'ERROR', msg:'Full'}); setTimeout(()=>conn.close(), 500); }); return; } window.Online.connections.push(conn); conn.on('data', (data) => window.Network.handleHostData(conn, data)); 
                conn.on('close', () => { const pIdx = window.Online.playerMap.findIndex(x => x.peerId === conn.peer); if (pIdx !== -1) { const p = window.Online.playerMap[pIdx]; if (gameState === 'IDLE') { window.Online.playerMap.splice(pIdx, 1); window.Online.connections = window.Online.connections.filter(c => c !== conn); window.Network.broadcast({type: 'LOBBY_UPDATE', players: window.Online.playerMap}); window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap); } else { p.isCpu = true; p.name += " (CPU)"; window.Network.broadcast({type: 'LOBBY_UPDATE', players: window.Online.playerMap}); } } });
            });
        },
        joinGame() {
            const name = document.getElementById('join-name').value.trim(); const code = document.getElementById('join-code').value.trim(); if(!name || code.length!==4) return alert(TRANSLATIONS[currentLang].incomplete);
            window.Online.isHost = false; window.Online.myName = name; window.Online.roomCode = code; const btn = document.getElementById('btn-connect'); btn.disabled = true; btn.innerText = TRANSLATIONS[currentLang].connecting;
            const timeOut = setTimeout(() => { if(btn.disabled) { btn.disabled = false; btn.innerText = TRANSLATIONS[currentLang].doConnectBtn; alert("é€£ç·šé€¾æ™‚ (Timeout)"); } }, 10000);
            SoundEngine.playBGM(); window.Online.peer = new Peer();
            window.Online.peer.on('open', (id) => { window.Online.myPeerId = id; const conn = window.Online.peer.connect(APP_ID_PREFIX + code); conn.on('open', () => { clearTimeout(timeOut); window.Online.hostConn = conn; conn.send({type: 'JOIN_REQUEST', name: name, characterType: selectedPlayerType}); }); conn.on('data', (data) => window.Network.handleClientData(data)); conn.on('close', () => { alert(TRANSLATIONS[currentLang].hostLeft); location.reload(); }); });
            window.Online.peer.on('error', (err) => { alert(TRANSLATIONS[currentLang].connError); location.reload(); });
        },
        handleHostData(conn, data) { if(data.type === 'JOIN_REQUEST') { const pType = data.characterType || 'Odin'; const newP = { name: data.name, isHost: false, peerId: conn.peer, isCpu: false, type: pType }; window.Online.playerMap.push(newP); window.Network.broadcast({type: 'LOBBY_UPDATE', players: window.Online.playerMap}); } else if (data.type === 'ACTION_SUBMIT') { const senderIdx = window.Online.playerMap.findIndex(p => p.peerId === conn.peer); if(senderIdx !== -1 && players[senderIdx]) { players[senderIdx].action = data.action; } } },
        handleClientData(data) {
            if(data.type === 'LOBBY_UPDATE') { window.Online.playerMap = data.players; window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap); } 
            else if (data.type === 'GAME_START') { myPlayerIndex = data.myIndex; isMultiplayer = true; if (data.scores) matchScores = data.scores; if (data.targetWins) targetWins = data.targetWins; window.startBattle(data.configs); } 
            else if (data.type === 'TURN_START') { startTurn(); } 
            else if (data.type === 'TURN_RESOLVE') { data.actions.forEach((act, idx) => { if(players[idx]) players[idx].action = act; }); resolveActions(); } 
            else if (data.type === 'GAME_OVER') { if (data.isFinal) showMsg(data.msg, true); else if (data.autoRestart) { if (data.scores) { matchScores = data.scores; players.forEach(p => p.refreshLabel()); } startRoundTransition(data.winnerName); } else showMsg(data.msg, false); } 
            else if (data.type === 'SHOW_CLEANUP') { const el = document.getElementById('cleanup-msg'); if(el) el.classList.add('active'); } 
            else if (data.type === 'HIDE_CLEANUP') { const el = document.getElementById('cleanup-msg'); if(el) el.classList.remove('active'); }
        },
        broadcast(msg) { window.Online.connections.forEach(c => { if(c.open) c.send(msg); }); if(msg.type === 'LOBBY_UPDATE') window.UI.updateLobby(window.Online.roomCode, window.Online.playerMap); },
        sendHost(msg) { if(window.Online.hostConn && window.Online.hostConn.open) window.Online.hostConn.send(msg); },
        hostStartGame() {
            while(window.Online.playerMap.length < 4) { const isLoki = Math.random() > 0.5; window.Online.playerMap.push({ name: `BOT-${window.Online.playerMap.length}`, isHost: false, peerId: 'cpu-'+Math.random(), isCpu: true, type: isLoki ? 'Loki' : 'Odin' }); }
            const configs = [ { id: 0, x: 0, y: 50, z: 140, name: window.Online.playerMap[0].name, type: window.Online.playerMap[0].type }, { id: 1, x: 0, y: 50, z: -140, name: window.Online.playerMap[1].name, type: window.Online.playerMap[1].type }, { id: 2, x: 140, y: 50, z: 0, name: window.Online.playerMap[2].name, type: window.Online.playerMap[2].type }, { id: 3, x: -140, y: 50, z: 0, name: window.Online.playerMap[3].name, type: window.Online.playerMap[3].type } ];
            if (Object.keys(matchScores).length === 0 || gameState === 'IDLE') { matchScores = {}; configs.forEach(p => matchScores[p.id] = 0); }
            window.Online.playerMap.forEach((p, idx) => { if(p.isHost) { myPlayerIndex = 0; isMultiplayer = true; window.startBattle(configs); } else if (!p.isCpu) { const conn = window.Online.connections.find(c => c.peer === p.peerId); if(conn) conn.send({ type: 'GAME_START', configs: configs, myIndex: idx, scores: matchScores, targetWins: targetWins }); } });
        }
    };

    // --- 6. CLASS DEFINITIONS ---
    class HitParticle { constructor(pos, color) { const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true }); this.mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), mat); this.mesh.position.copy(pos); const a = Math.random() * Math.PI * 2, s = 5 + Math.random() * 5; this.velocity = new THREE.Vector3(Math.cos(a) * s, 4 + Math.random() * 6, Math.sin(a) * s); this.life = 1.0; scene.add(this.mesh); } update(dt) { this.mesh.position.add(this.velocity.clone().multiplyScalar(dt)); this.velocity.y -= 15 * dt; this.life -= dt * 1.5; this.mesh.material.opacity = this.life; if (this.life <= 0) { if(this.mesh.parent) scene.remove(this.mesh); return false; } return true; } }
    class OptimizedLightningBolt { constructor(s, e, c=0x00ffff) { this.s=s.clone(); this.e=e.clone(); this.c=c; this.l=6; this.g=new THREE.Group(); scene.add(this.g); this.m=new THREE.MeshBasicMaterial({color:c,transparent:true}); this.gen(); } gen() { while(this.g.children.length>0){this.g.remove(this.g.children[0]);} const pts=[]; for(let i=0;i<=8;i++){ let p=new THREE.Vector3().lerpVectors(this.s,this.e,i/8); if(i>0&&i<8){ p.addScalar((Math.random()-0.5)*20); } pts.push(p); } for(let i=0;i<pts.length-1;i++){ const d=pts[i].distanceTo(pts[i+1]); const m=new THREE.Mesh(new THREE.BoxGeometry(3.6,3.6,d),this.m); m.position.lerpVectors(pts[i],pts[i+1],0.5); m.lookAt(pts[i+1]); this.g.add(m); } this.m.color.setHex(Math.random()>0.4?0xffffff:this.c); } update() { this.l--; if(this.l>0){this.gen();return true;} else{scene.remove(this.g); return false;} } }
    class SuperAura { constructor(p) { this.active=false; this.g=new THREE.Group(); this.g.position.y=2.5; p.add(this.g); this.core=new THREE.Mesh(new THREE.IcosahedronGeometry(3,1),new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.3,blending:2})); this.g.add(this.core); this.spikes=new THREE.Mesh(new THREE.IcosahedronGeometry(3.5,0),new THREE.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.4,blending:2})); this.g.add(this.spikes); this.g.visible=false; this.t=0; } activate(r) { this.active=true; this.g.visible=true; this.spikes.material.color.setHex(r?0xff3300:0x0088ff); this.core.material.color.setHex(r?0xffffaa:0xaaffff); } deactivate() { this.active=false; this.g.visible=false; } update(dt) { if(!this.active)return; this.t+=dt*15; const s=1+Math.sin(this.t)*0.05; this.spikes.scale.set(s,s,s); this.spikes.rotation.y+=dt*3; } }
    class ParabolicMeatProjectile { constructor(s,e){this.s=s.clone();this.e=e.clone();this.m=createMeatModelShared(7.0);scene.add(this.m);this.p=0;} update(dt){if(this.p>=1){if(this.m.parent)scene.remove(this.m);createExplosion(this.m.position, 3.0); return false;}this.p+=dt/0.8;const c=new THREE.Vector3().lerpVectors(this.s,this.e,this.p);c.y+=Math.sin(this.p*Math.PI)*150;this.m.position.copy(c);this.m.rotation.x+=dt*10;return true;} }
    
    // --- 8. HELPER FUNCTIONS ---
    function createUnitUISprite() { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 256; const texture = new THREE.CanvasTexture(canvas); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false })); sprite.scale.set(12, 6, 1); sprite.renderOrder = 999; return { sprite, canvas, ctx, texture }; }
    function createBrokenShieldTexture() { 
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.moveTo(30, 30); ctx.lineTo(226, 30); ctx.quadraticCurveTo(226, 150, 128, 240); ctx.quadraticCurveTo(30, 150, 30, 30); ctx.closePath(); ctx.fill(); ctx.font = 'bold 36px "Microsoft JhengHei", sans-serif'; ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
        if (currentLang === 'zh-TW') { ctx.fillText('é˜²ç¦¦', 128, 110); ctx.fillText('ç–²å‹ä¸­', 128, 150); } else { ctx.font = 'bold 30px Arial'; ctx.fillText('Can\'t', 128, 110); ctx.fillText('Block!', 128, 150); }
        return new THREE.CanvasTexture(canvas); 
    }
    function createTextSprite(text) { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 128; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(20, 20, 472, 88); ctx.font = 'bold 50px "Microsoft JhengHei", Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#ff99cc'; ctx.fillText(text, 256, 85); const texture = new THREE.CanvasTexture(canvas); const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false }); return new THREE.Sprite(mat); }
    function createShockwave(pos, color) { const m = new THREE.Mesh(new THREE.RingGeometry(1, 2, 64), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1, side: THREE.DoubleSide })); m.position.copy(pos); m.rotation.x = Math.PI / 2; const expand = () => { m.scale.x += 4; m.scale.y += 4; m.material.opacity -= 0.05; if(m.material.opacity > 0) requestAnimationFrame(expand); else if(m.parent) scene.remove(m); }; expand(); return m; }
    function createExplosion(pos, scale=1.0) { const g = new THREE.Group(); const shock = createShockwave(pos, 0xffaa00); g.add(shock); g.position.copy(pos); shock.position.set(0,0,0); const count = Math.floor(40 * scale); for(let i=0; i<count; i++) { activeParticles.push(new HitParticle(pos.clone(), i % 2 === 0 ? 0xff4400 : 0xffff00)); } g.scale.set(scale, scale, scale); SoundEngine.play('super'); scene.add(g); return g; }
    function applyKnockback(char, sourcePos) { if(!sourcePos) return; const dir = char.group.position.clone().sub(sourcePos).normalize(); dir.y = 0; const originalPos = char.group.position.clone(); const backPos = originalPos.clone().add(dir.multiplyScalar(25)); move(char.group, backPos, 100).then(() => { sleep(50).then(() => move(char.group, originalPos, 200)); }); }
    function createMagnetModel() { const group = new THREE.Group(); const bar1 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), new THREE.MeshPhongMaterial({ color: 0xff0000 })); bar1.position.set(-3, 3, 0); group.add(bar1); const bar2 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), new THREE.MeshPhongMaterial({ color: 0x0000ff })); bar2.position.set(3, 3, 0); group.add(bar2); const connector = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 2), new THREE.MeshPhongMaterial({ color: 0xcccccc })); connector.position.set(0, 0, 0); group.add(connector); group.scale.set(2,2,2); return group; }
    function createMeatModelShared(scale = 1) { const g = new THREE.Group(); const meat = new THREE.Mesh(new THREE.BoxGeometry(3.5 * scale, 2.5 * scale, 2.5 * scale), new THREE.MeshPhongMaterial({ color: 0xaa2222 })); meat.position.y = 1 * scale; meat.castShadow = true; g.add(meat); const bone = new THREE.Mesh(new THREE.BoxGeometry(6 * scale, 0.6 * scale, 0.6 * scale), new THREE.MeshPhongMaterial({ color: 0xeeeeee })); bone.position.y = 1 * scale; bone.castShadow = true; g.add(bone); const cL = new THREE.Mesh(new THREE.PlaneGeometry(2.3 * scale, 2.3 * scale), new THREE.MeshBasicMaterial({ color: 0xffaaaa })), cR = cL.clone(); cL.position.set(-1.76 * scale, 1 * scale, 0); cL.rotation.y = Math.PI/2; cR.position.set(1.76 * scale, 1 * scale, 0); cR.rotation.y = Math.PI/2; g.add(cL, cR); return g; }
    function getRandomTarget(sid) { const os = players.filter(p => p.id !== sid && p.alive); return os.length ? os[Math.floor(Math.random()*os.length)].id : -1; }
    
    function createStarGeometry() { const s = new THREE.Shape(); const o=5.5, n=2.8; for(let i=0; i<12; i++){ const a=(i/12)*Math.PI*2, r=(i%2===0)?o:n; if(i===0) s.moveTo(Math.cos(a)*r, Math.sin(a)*r); else s.lineTo(Math.cos(a)*r, Math.sin(a)*r); } s.closePath(); return new THREE.ShapeGeometry(s); }
    function createRuneLine() { const pts = [new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0.5, 0, 0), new THREE.Vector3(0, 0.5, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffffff })); }
    function createAlgizRune() { const pts = [new THREE.Vector3(0, -0.8, 0), new THREE.Vector3(0, 0.8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-0.6, 0.6, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0.6, 0.6, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })); }
    function createReticleTexture() { const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d'); ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 12; ctx.beginPath(); ctx.setLineDash([30, 15]); ctx.arc(128, 128, 110, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.lineWidth = 9; ctx.beginPath(); ctx.moveTo(128, 40); ctx.lineTo(128, 10); ctx.moveTo(128, 216); ctx.lineTo(128, 246); ctx.moveTo(40, 128); ctx.lineTo(10, 128); ctx.moveTo(216, 128); ctx.lineTo(246, 128); ctx.stroke(); ctx.fillStyle = '#ff3333'; ctx.beginPath(); ctx.arc(128, 128, 12, 0, Math.PI * 2); ctx.fill(); return new THREE.CanvasTexture(canvas); }

    class Odin {
        constructor(cfg) {
            this.id = cfg.id; this.name = cfg.name; this.type = cfg.type || 'Odin';
            this.maxHP = (this.type === 'Loki' ? MAX_HP_LOKI : MAX_HP_ODIN);
            this.hp = this.maxHP; this.alive = true; this.rage = { red: 0, blue: 0 }; this.fatigue = 0; this.defendHitCount = 0; this.showBrokenShield = false; this.action = { card: -1, target: -1, selectionTime: 0 }; this.targetQuaternion = null;
            this.group = new THREE.Group(); this.group.position.set(cfg.x, cfg.y, cfg.z); this.group.userData = { isCharacter: true, playerId: cfg.id }; this.group.scale.set(8, 8, 8);
            this.aura = new SuperAura(this.group); this.ballRotationMultiplier = 1.0; 
            const hitGeo = new THREE.BoxGeometry(3, 6, 3); const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false, colorWrite: false }); 
            this.hitBox = new THREE.Mesh(hitGeo, hitMat); this.hitBox.position.y = 3.5; this.group.add(this.hitBox);
            const uiData = createUnitUISprite(); this.uiSprite = uiData.sprite; this.uiCtx = uiData.ctx; this.uiTexture = uiData.texture; this.uiSprite.position.y = 8.5; this.group.add(this.uiSprite);
            const uiHitGeo = new THREE.BoxGeometry(18, 30, 18); const uiHitBox = new THREE.Mesh(uiHitGeo, hitMat); uiHitBox.position.set(0, 8, 0); 
            if (this.id !== myPlayerIndex) this.group.add(uiHitBox);
            this.brokenShieldIcon = new THREE.Sprite(new THREE.SpriteMaterial({ map: createBrokenShieldTexture(), transparent: true, opacity: 0.5, depthTest: false, depthWrite: false })); this.brokenShieldIcon.scale.set(8, 8, 1); this.brokenShieldIcon.position.set(0, 14, 0); this.brokenShieldIcon.visible = false; this.group.add(this.brokenShieldIcon); 
            this.labelSprite = createTextSprite(this.getDisplayName()); this.labelSprite.position.y = -3.5; this.labelSprite.scale.set(10, 2.5, 1); if (this.id !== myPlayerIndex) this.group.add(this.labelSprite);
            this.ultraRedSprite = createUltraTextSprite("#ff3333"); this.ultraRedSprite.position.y = -7; this.ultraRedSprite.scale.set(10, 2.5, 1); this.ultraRedSprite.visible = false; this.group.add(this.ultraRedSprite);
            this.ultraBlueSprite = createUltraTextSprite("#3333ff"); this.ultraBlueSprite.position.y = -7; this.ultraBlueSprite.scale.set(10, 2.5, 1); this.ultraBlueSprite.visible = false; this.group.add(this.ultraBlueSprite);
            this.smirkSprite = createEmojiSprite("ğŸ˜ˆ"); this.smirkSprite.position.y = 8; this.smirkSprite.visible = false; this.group.add(this.smirkSprite);
            this.sweatSprite = createEmojiSprite("ğŸ˜“"); this.sweatSprite.position.y = 8; this.sweatSprite.visible = false; this.group.add(this.sweatSprite);
            this.modelContainer = new THREE.Group(); this.group.add(this.modelContainer);
            this.body = new THREE.Mesh(new THREE.BoxGeometry(2.1, 2, 2.5), new THREE.MeshPhongMaterial({ color: (this.type === 'Loki' ? 0x0a4a0a : 0xffcc00) })); this.body.position.y = 1; this.body.castShadow = true; this.modelContainer.add(this.body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.8, 1.6), new THREE.MeshPhongMaterial({ color: 0xffdbac })); head.position.set(0, 2.5, 0.5); head.castShadow = true; this.modelContainer.add(head);
            this.snout = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.6), new THREE.MeshPhongMaterial({ color: 0xffaaaa })); this.snout.position.set(0, 2.3, 1.35); this.snout.castShadow = true; this.modelContainer.add(this.snout);
            const nL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), new THREE.MeshBasicMaterial({color:0x000000})), nR = nL.clone(); nL.position.set(-0.25, 0.1, 0.35); nR.position.set(0.25, 0.1, 0.35); this.snout.add(nL, nR);
            const earL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.2), new THREE.MeshPhongMaterial({color: 0xffaaaa})), earR = earL.clone(); earL.position.set(-1.0, 3.2, 0.5); earL.rotation.z = 0.6; earR.position.set(1.0, 3.2, 0.5); earR.rotation.z = -0.6; this.modelContainer.add(earL, earR);
            if (this.type === 'Loki') {
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d'); const cols = ['#ff3333', '#33ff33', '#ffffff', '#3333ff']; 
                for(let i=0; i<4; i++) for(let j=0; j<4; j++) { ctx.fillStyle = cols[(i + j) % 4]; ctx.fillRect(i * 64, j * 64, 64, 64); }
                this.ball = new THREE.Mesh(new THREE.SphereGeometry(1.4, 16, 12), new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas) })); this.ball.position.y = -0.4; this.ball.castShadow = true; this.modelContainer.add(this.ball); this.modelContainer.position.y = 1.4;
            }
            this.weaponGroup = new THREE.Group();
            if (this.type === 'Odin') {
                const shape = new THREE.Shape(); shape.moveTo(0, 0); shape.lineTo(0.5, 2); shape.lineTo(-0.2, 1.8); shape.lineTo(0.4, 3.5); shape.lineTo(-0.3, 3.2); shape.lineTo(0.6, 6); shape.lineTo(-0.1, 3.8); shape.lineTo(0.5, 4.2); shape.lineTo(-0.1, 2.2); shape.lineTo(0.4, 2.5); shape.lineTo(0, 0);
                this.weaponMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.3, bevelEnabled: false }), new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffd700, emissiveIntensity: 2 })); this.weaponMesh.position.set(-0.2, -1, 0); this.weaponMesh.castShadow = true; this.weaponGroup.add(this.weaponMesh); 
            }
            this.weaponGroup.position.set(1.5, 1.2, 0.5); this.weaponGroup.rotation.x = -Math.PI/4; this.modelContainer.add(this.weaponGroup);
            this.hexShield = new THREE.Group(); const hexStar = new THREE.Mesh(createStarGeometry(), new THREE.MeshBasicMaterial({ color: (this.type === 'Loki' ? 0xff0000 : 0x00ffff), transparent: true, opacity: 0, side: THREE.DoubleSide })); this.hexShield.add(hexStar); 
            for (let i = 0; i < 6; i++) { const rune = createRuneLine(), angle = (i / 6) * Math.PI * 2; rune.position.set(Math.cos(angle) * 3.5, Math.sin(angle) * 3.5, 0.1); rune.rotation.z = angle; this.hexShield.add(rune); }
            this.hexShield.add(createAlgizRune()); this.hexShield.position.set(0, 3, 3); this.hexShield.visible = false; this.group.add(this.hexShield);
            this.meatBlock = createMeatModelShared(); this.meatBlock.visible = false; this.group.add(this.meatBlock);
            this.selectionSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: createReticleTexture(), transparent: true, depthTest: false, depthWrite: false })); this.selectionSprite.scale.set(15, 15, 1); this.selectionSprite.position.set(0, 3.5, 0); this.selectionSprite.visible = false; this.group.add(this.selectionSprite);
            scene.add(this.group); this.face(new THREE.Vector3(0,cfg.y,0)); this.updateLabel();
        }
        respawn() {
            this.hp = this.maxHP; this.alive = true; this.meatBlock.visible = false; this.modelContainer.visible = true; this.brokenShieldIcon.visible = false; this.uiSprite.visible = true; if (this.id !== myPlayerIndex) this.labelSprite.visible = true; this.updateLabel(); updateHPUI();
            for(let i=0; i<15; i++) activeParticles.push(new HitParticle(this.group.position.clone().add(new THREE.Vector3(0, 10, 0)), 0x00ff00)); spawnDamageNumber(this, "å¾©æ´»!", "#00ff00");
        }
        getDisplayName() { const wins = matchScores[this.id] || 0; return wins > 0 ? `${this.name} ${"ğŸ‘‘".repeat(wins)}` : this.name; }
        refreshLabel() { if(this.labelSprite) { this.labelSprite.material.map.dispose(); this.labelSprite.material.map = createTextSprite(this.getDisplayName()).material.map; } }
        updateLabel() { 
            if (!this.uiCtx) return; const ctx = this.uiCtx; ctx.clearRect(0, 0, 512, 256); 
            if (!this.alive) { ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(50, 40, 412, 160); ctx.font = 'bold 60px "Microsoft JhengHei", Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#ff3333'; ctx.fillText(TRANSLATIONS[currentLang].dead, 256, 130); this.uiTexture.needsUpdate = true; return; } 
            const r = this.rage, u = Math.floor(Math.max(r.red, r.blue)); 
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; if (this.id === myPlayerIndex) ctx.fillRect(50, 100, 412, 70); else ctx.fillRect(50, 40, 412, 160);
            if (this.id !== myPlayerIndex) { ctx.font = 'bold 36px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = 'white'; ctx.fillText(`HP: ${this.hp}/${this.maxHP}  ${TRANSLATIONS[currentLang].rage}: ${u}%`, 256, 85); }
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(80, 110, 352, 20); ctx.fillStyle = '#2ecc71'; ctx.fillRect(80, 110, 352 * (this.hp/this.maxHP), 20); 
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(80, 145, 352, 15); ctx.fillStyle = (r.red > r.blue) ? '#ff5555' : (r.blue > r.red ? '#55ccff' : '#ffaa00'); ctx.fillRect(80, 145, 352 * (u/100), 15); 
            this.uiTexture.needsUpdate = true; 
        }
        face(pos) { if (!this.alive) return; const lp = pos.clone(); lp.y = this.group.position.y; const dummy = new THREE.Object3D(); dummy.position.copy(this.group.position); dummy.lookAt(lp); this.targetQuaternion = dummy.quaternion.clone(); }
        takeDamage(amt, type = 0, sourcePos = null) { 
            this.hp = Math.max(0, this.hp - Math.floor(amt)); SoundEngine.play('hit'); 
            const pColor = (type === 0) ? 0xffaa00 : (type === 1 ? 0x00ffff : 0xff0044); 
            for(let i=0; i<15; i++) activeParticles.push(new HitParticle(this.group.position.clone().add(new THREE.Vector3(0, 10, 0)), pColor)); 
            if (sourcePos) applyKnockback(this, sourcePos); 
            if (this.hp <= 0 && this.alive) { 
                this.alive = false; this.modelContainer.visible = false; this.meatBlock.visible = true; this.aura.deactivate(); this.brokenShieldIcon.visible = false; this.selectionSprite.visible = false;
                if(this.id === myPlayerIndex) this.uiSprite.visible = false; else this.labelSprite.visible = false; 
                if (isTutorialMode && this.id !== myPlayerIndex) setTimeout(() => { if(this.hp <= 0) this.respawn(); }, 1500);
            } this.updateLabel(); updateHPUI(); 
        }
    }

    function calcDamage(a, t, type, isSuper = false, skipFatigue = false) { 
        if (!t || !t.alive) return; const txt = TRANSLATIONS[currentLang]; 
        let dmg = (a.type === 'Loki') ? (isSuper ? (type === 0 ? 70 : t.maxHP * 0.5) : (type === 0 ? 60 : 80)) : (isSuper ? (type === 0 ? 60 : t.maxHP * 0.5) : (type === 0 ? 80 : 90));
        if (isSuper) createExplosion(t.group.position.clone().add(new THREE.Vector3(0, 15, 0)), 2.5); 
        else { 
            if (type === 0 && t.action.card === 2) { if (t.type === 'Loki') return; loseRage(a, true); a.takeDamage(80, 0, t.group.position); spawnDamageNumber(a, 80); showMove(`[${t.getDisplayName()}] åæ“Šï¼ -> ${a.getDisplayName()} 80 Dmg!`); if (t.type === 'Odin') gainRage(t, true, 20); return; } 
            if (type === 1 && t.action.card === 3) { loseRage(a, false); let rd = Math.floor(dmg*0.8); a.takeDamage(rd, 2, t.group.position); spawnDamageNumber(a, rd); showMove(`[${t.getDisplayName()}] åå°„ï¼ -> ${a.getDisplayName()} ${rd} Dmg!`); gainRage(t, false, 20); return; } 
        } 
        if (t.action.card === 4) { if (!skipFatigue) { t.defendHitCount++; let fa = (t.defendHitCount === 2 ? 20 : (t.defendHitCount > 2 ? 10 : 0)) + (isSuper ? 15 : 0); if (fa > 0) t.fatigue = Math.min(150, t.fatigue + fa); } SoundEngine.play('ding'); spawnDamageNumber(t, txt.logBlock, "#ffff00"); let redD = Math.floor(dmg * 0.20); t.takeDamage(redD, type, a.group.position); setTimeout(() => spawnDamageNumber(t, redD), 200); return; } 
        loseRage(t, type === 0); t.takeDamage(dmg, type, a.group.position); spawnDamageNumber(t, dmg); let skillName = isSuper ? txt.skillUlt : (type === 0 ? txt.skillPhys : txt.skillMag); showMove(txt.combatLog.replace('{attacker}', a.getDisplayName()).replace('{target}', t.getDisplayName()).replace('{skill}', skillName).replace('{dmg}', dmg)); if (!isSuper) gainRage(a, type === 0, 35); 
    }

    async function focusOnAction(char1, char2 = null, dur = 600) { 
        if (!char1) return; let tCenter, camTarget; 
        if (char2) { const p1 = char1.group.position.clone(), p2 = char2.group.position.clone(); const d = p1.distanceTo(p2); tCenter = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5); camTarget = tCenter.clone().add(new THREE.Vector3(0, 180 + d * ((window.innerWidth / window.innerHeight) > 1 ? 0.5 : 0.4), 250 + d * 0.6)); } 
        else { tCenter = char1.group.position.clone(); camTarget = tCenter.clone().add(new THREE.Vector3(0, 200, 300)); } 
        return new Promise(res => { let sPos = camera.position.clone(); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / dur); camera.position.lerpVectors(sPos, camTarget, p); camera.lookAt(tCenter); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); 
    }

    async function cinematicIntro(attacker, skillName) { const focusPos = attacker.group.position.clone().add(new THREE.Vector3(0, 0, 1).applyQuaternion(attacker.group.quaternion).multiplyScalar(150)); focusPos.y += 20; await new Promise(res => { let sPos = camera.position.clone(); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 400); camera.position.lerpVectors(sPos, focusPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); showMove(skillName); SoundEngine.play('click'); await sleep(500); return new Promise(res => { let sPos = camera.position.clone(); let zoomOutPos = attacker.group.position.clone().add(new THREE.Vector3(0, 240, 350)); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 1000); camera.position.lerpVectors(sPos, zoomOutPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    async function performAttack(attacker, target, type) { 
        if (!attacker || !target) return; const tp = target.group.position.clone(), orig = attacker.group.position.clone(); 
        if (type === 1 && attacker.type === 'Loki') { if (Math.random() < 0.6) { attacker.smirkSprite.visible = true; setTimeout(() => { if(attacker.smirkSprite) attacker.smirkSprite.visible = false; }, 2000); attacker.group.userData.splashFailed = false; } else { attacker.sweatSprite.visible = true; setTimeout(() => { if(attacker.sweatSprite) attacker.sweatSprite.visible = false; }, 2000); attacker.group.userData.splashFailed = true; } } 
        else { if(attacker.group.userData) attacker.group.userData.splashFailed = false; }
        if (type === 0 && target.action.card === 2 && target.type === 'Odin') { await move(attacker.group, tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)), 200); SoundEngine.play('magic'); target.group.visible = false; target.group.position.copy(attacker.group.position.clone().add(target.group.position.clone().sub(attacker.group.position).normalize().multiplyScalar(-45))); target.face(attacker.group.position); target.group.visible = true; target.weaponGroup.rotation.z = 1.8; SoundEngine.play('counter'); await sleep(300); calcDamage(attacker, target, 0); gainRage(target, true, 20); await sleep(500); target.weaponGroup.rotation.z = 0; hideMove(); await move(attacker.group, orig, 400); target.group.position.copy(tp); target.face(attacker.group.position); return; } 
        if (type === 0 && target.action.card === 2 && target.type === 'Loki') { 
            const victims = players.filter(p => p && p.alive && p.id !== target.id && p.id !== attacker.id); showMove("Magnet!"); await sleep(800); const magnet = createMagnetModel(); magnet.position.copy(target.group.position).add(new THREE.Vector3(0, 40, 0)); scene.add(magnet); SoundEngine.play('magic');
            if (victims.length >= 1) { 
                const victim = victims[Math.floor(Math.random()*victims.length)]; await move(magnet, victim.group.position.clone().add(new THREE.Vector3(0, 40, 0)), 600); const vPos = victim.group.position.clone(); const strikePos = vPos.clone().add(orig.clone().sub(vPos).normalize().multiplyScalar(45)); attacker.face(vPos);
                if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 10.0; await sleep(600); await move(attacker.group, strikePos, 150); } else { await move(attacker.group, strikePos, 250); attacker.weaponGroup.rotation.z = 0.8; } 
                SoundEngine.play(attacker.type === 'Loki' ? 'hit' : 'slash'); loseRage(attacker, true); victim.takeDamage((attacker.type === 'Loki' ? 60 : 80), 0, attacker.group.position); spawnDamageNumber(victim, (attacker.type === 'Loki' ? 60 : 80)); showMove(TRANSLATIONS[currentLang].redirected);
                await sleep(500); attacker.weaponGroup.rotation.z = 0; attacker.ballRotationMultiplier = 1.0; await Promise.all([ move(attacker.group, orig, 500), move(magnet, target.group.position.clone().add(new THREE.Vector3(0, 40, 0)), 600) ]); scene.remove(magnet); return; 
            } else { await move(magnet, target.group.position.clone().add(new THREE.Vector3(0, 80, 0)), 300); showMove(TRANSLATIONS[currentLang].noTarget); await sleep(500); scene.remove(magnet); }
        } 
        if (type === 0) { if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 10.0; await sleep(600); await move(attacker.group, tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)), 150); SoundEngine.play('hit'); calcDamage(attacker, target, 0); await sleep(300); attacker.ballRotationMultiplier = 1.0; await move(attacker.group, orig, 500); } else { await move(attacker.group, tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)), 250); attacker.weaponGroup.rotation.z = 0.8; SoundEngine.play('slash'); calcDamage(attacker, target, 0); await sleep(300); attacker.weaponGroup.rotation.z = 0; await move(attacker.group, orig, 500); } } 
        else { 
            if (attacker.type === 'Loki') { activeProjectiles.push(new ParabolicMeatProjectile(attacker.group.position.clone().add(new THREE.Vector3(0, 30, 0)), target.group.position.clone().add(new THREE.Vector3(0, 20, 0)))); SoundEngine.play('magic'); await sleep(800); } 
            else { for(let k=0; k<8; k++) activeLightnings.push(new OptimizedLightningBolt(attacker.group.position.clone().add(new THREE.Vector3(0, 25, 0)), target.group.position.clone().add(new THREE.Vector3(0,25,0)).add(new THREE.Vector3((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*15)))); SoundEngine.play('magic'); await sleep(800); } 
            if (target.action.card === 3 && type === 1) { await focusOnAction(target, attacker, 400); if (target.type === 'Odin') { target.weaponGroup.rotation.z = 1.2; await move(target.weaponGroup, new THREE.Vector3(0,0,5), 100); showMove(CARD_NAMES[3]); for (let i = 0; i < 12; i++) { setTimeout(() => { activeLightnings.push(new OptimizedLightningBolt(target.group.position.clone().add(new THREE.Vector3(0,25,0)), attacker.group.position.clone().add(new THREE.Vector3(0,25,0)), 0xff0000)); SoundEngine.play('magic'); }, i * 50); } await sleep(1000); await move(target.weaponGroup, new THREE.Vector3(0,0,0), 100); target.weaponGroup.rotation.z = 0; hideMove(); } else if (target.type === 'Loki') { target.ballRotationMultiplier = 15.0; target.aura.activate(false); const obp = target.ball.position.clone(); target.ball.scale.set(3,3,3); await new Promise(res => { const start = target.ball.position.clone(), localT = target.modelContainer.worldToLocal(attacker.group.position.clone().add(new THREE.Vector3(0,30,0))), t = performance.now(); function fly() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(start, localT, p); if (p < 1) requestAnimationFrame(fly); else res(); } fly(); }); createExplosion(attacker.group.position, 2.0); await new Promise(res => { const s = target.ball.position.clone(), t = performance.now(); function back() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(s, obp, p); if (p < 1) requestAnimationFrame(back); else res(); } back(); }); target.ball.scale.set(1,1,1); target.aura.deactivate(); target.ballRotationMultiplier = 1.0; } SoundEngine.play('counter'); await sleep(1000); } 
            calcDamage(attacker, target, 1); 
            if (attacker.type === 'Loki' && type === 1 && target.action.card !== 4 && target.action.card !== 3 && !attacker.group.userData.splashFailed) { const bTs = players.filter(pl => pl && pl.id !== attacker.id && pl.id !== target.id && pl.alive); if (bTs.length > 0) { const t2 = bTs[Math.floor(Math.random() * bTs.length)]; activeProjectiles.push(new ParabolicMeatProjectile(target.group.position.clone().add(new THREE.Vector3(0, 20, 0)), t2.group.position.clone().add(new THREE.Vector3(0, 20, 0)))); await sleep(600); t2.takeDamage(60, 1, target.group.position); spawnDamageNumber(t2, 60); gainRage(attacker, false, 20); } }
        } 
    }
    async function performLightningStorm(p) { 
        SoundEngine.play('super'); const targets = players.filter(o => o && o.id !== p.id && o.alive); p.takeDamage(p.maxHP * 0.25, 2); const originalCamPos = camera.position.clone(); await new Promise(res => { let s = performance.now(); function up() { let pv = Math.min(1, (performance.now() - s) / 800); camera.position.lerpVectors(originalCamPos, new THREE.Vector3(0, 450, 650), pv); camera.lookAt(new THREE.Vector3(0, 40, 0)); if (pv < 1) requestAnimationFrame(up); else res(); } up(); }); await sleep(300); for (let i = 0; i < 8; i++) { targets.forEach(t => activeLightnings.push(new OptimizedLightningBolt(t.group.position.clone().add(new THREE.Vector3((Math.random()-0.5)*30, 500, (Math.random()-0.5)*30)), t.group.position))); SoundEngine.play('magic'); await sleep(150); } await sleep(400); targets.forEach(t => calcDamage(p, t, 1, true)); await sleep(400); resetCamera();
    }

    async function performLokiBlueUlt(attacker, target) {
        if (Math.random() < 0.75) {
            attacker.smirkSprite.visible = true; setTimeout(() => { if(attacker.smirkSprite) attacker.smirkSprite.visible = false; }, 3000);
            if (target && target.action.card === 4) { SoundEngine.play('ding'); spawnDamageNumber(target, TRANSLATIONS[currentLang].logBlock, "#ffff00"); showMove(`[${target.getDisplayName()}] ${TRANSLATIONS[currentLang].logBlock}!`); } 
            else if (target) { const mH = attacker.hp; attacker.hp = target.hp; target.hp = mH; SoundEngine.play('magic'); spawnDamageNumber(attacker, "HP SWAP!", "#00ff00"); spawnDamageNumber(target, "HP SWAP!", "#00ff00"); showMove(TRANSLATIONS[currentLang].hpSwapSuccess); attacker.updateLabel(); target.updateLabel(); window.updateHPUI(); }
        } else { attacker.sweatSprite.visible = true; setTimeout(() => { if(attacker.sweatSprite) attacker.sweatSprite.visible = false; }, 3000); SoundEngine.play('bonk'); showMove(TRANSLATIONS[currentLang].hpSwapFail); } await sleep(1500);
    }
    
    async function performPhysicalSuper(attacker, target) { 
        SoundEngine.play('super'); const op = attacker.group.position.clone(); if (!target) return; const tp = target.group.position.clone(); 
        if (attacker.type === 'Loki') { 
            attacker.ballRotationMultiplier = 15.0; const vec = tp.clone().sub(op).normalize(); const bp = tp.clone().add(vec.clone().multiplyScalar(40)); await move(attacker.group, bp, 250); calcDamage(attacker, target, 0, true); createExplosion(tp, 1.5); SoundEngine.play('hit'); await sleep(100); await move(attacker.group, tp.clone().add(vec.clone().multiplyScalar(5)), 200); calcDamage(attacker, target, 0, true, true); SoundEngine.play('hit'); await move(attacker.group, bp, 200); await sleep(100); await move(attacker.group, tp.clone().sub(vec.clone().multiplyScalar(40)), 250); calcDamage(attacker, target, 0, true); createExplosion(tp, 1.5); await sleep(100); attacker.ballRotationMultiplier = 1.0; await move(attacker.group, op, 500); 
        } else { for (let i = 0; i < 3; i++) { await move(attacker.group, tp.clone().add(op.clone().sub(tp).normalize().multiplyScalar(40)), 150); calcDamage(attacker, target, 0, true, i > 0); await sleep(100); } await move(attacker.group, op, 400); if (attacker.type === 'Odin' && target && target.action.card !== 4) { gainRage(attacker, true, 83); spawnDamageNumber(attacker, "+83% Rage!", "#ff5555"); } } 
    }

    async function resolveActions() { 
        if (gameState === 'ANIMATING') return; 
        gameState = 'ANIMATING'; tutorialState = 'none'; // Clear tutorial pointer
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer);
        document.getElementById('turn-hint').style.display = 'none';
        const getPrio = (p) => { const c = p.action.card; if (c === 5 || c === 6) return 10; if (c === 4) return 20; if (c === 2 && p.type === 'Odin') return 30; if (c === 3) return 35; if (c === 2 && p.type === 'Loki') return 38; if (c === 0) return 40; if (c === 1) return 70; return 100; };
        const q = players.filter(p => p && p.alive).sort((a, b) => { const prioA = getPrio(a); const prioB = getPrio(b); if (prioA !== prioB) return prioA - prioB; return a.action.selectionTime - b.action.selectionTime; });
        let localId = currentDemoId; showMove(TRANSLATIONS[currentLang].lockingTargets); await sleep(1200); hideMove(); await sleep(300);
        for (let p of q) { 
            if (localId !== currentDemoId) return; if (!p || !p.alive) continue; 
            const t = players.find(x => x && x.id === p.action.target); const cid = p.action.card; if (cid === -1) continue; 
            if (isTutorialMode && p.id === myPlayerIndex) {
                 const tl = TRANSLATIONS[currentLang]; const hint = document.getElementById('tutorial-rage-hint'); if(hint) {
                     let name = (cid === 5 ? tl.tutCardNames[5] : (cid === 6 ? tl.tutCardNames[6] : (cid === 2 ? (p.type === 'Loki' ? tl.cardNames.swap : tl.cardNames[2]) : tl.cardNames[cid])));
                     let desc = "";
                     if (typeof tl.cardDescs[cid] === 'object') {
                         desc = tl.cardDescs[cid][p.type] || tl.cardDescs[cid]['default'];
                     } else {
                         desc = tl.cardDescs[cid];
                     }
                     hint.innerHTML = `<span style="color:#ffcc00; font-size:1.2rem;">${name}</span><br><span style="font-size:1rem; color:#fff;">${desc}</span>`;
                 }
            }
            let skillText = (cid === 4 || cid === 3 || cid === 2) ? `[${p.getDisplayName()}] ${cid === 2 ? (p.type === 'Loki' ? TRANSLATIONS[currentLang].cardNames.swap : TRANSLATIONS[currentLang].cardNames[2]) : CARD_NAMES[cid]}!` : `[${p.getDisplayName()}] ${cid === 5 ? ( ( (!isTutorialMode && p.rage.blue > p.rage.red) || (isTutorialMode && cid === 6) ) ? TRANSLATIONS[currentLang].tutCardNames[6] : TRANSLATIONS[currentLang].tutCardNames[5] ) : CARD_NAMES[cid]} @ ${t ? t.getDisplayName() : ""}!`;
            if (cid === 4 || cid === 2 || cid === 3) { showMove(skillText); SoundEngine.play('click'); await sleep(1000); } else await cinematicIntro(p, skillText);
            if (localId !== currentDemoId) return; 
            if (!t || !t.alive) { const isMagUlt = (cid === 6 || (cid === 5 && !((p.id === 0 ? playerRage.red : p.rage.red) >= 99) && !isTutorialMode)); if (cid >= 0 && cid !== 4 && cid !== 2 && cid !== 3 && cid !== 5 && cid !== 6) { showMove("ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ"); await sleep(1000); hideMove(); } if (cid !== 4 && cid !== 2 && cid !== 3 && !isMagUlt && !(isTutorialMode && cid === 6)) { window.updateHPUI(); await sleep(300); resetCamera(); continue; } } 
            if (cid === 4) { p.fatigue = Math.min(150, p.fatigue + 75); window.updateHPUI(); } 
            if (p.id === t?.id) { let nr = null, md = 99999; players.forEach(o => { if (o.id !== p.id && o.alive) { const d = p.group.position.distanceTo(o.group.position); if (d < md) { md = d; nr = o; } } }); if (nr) p.face(nr.group.position); else p.face(new THREE.Vector3(0, 50, 0)); } 
            else if (t && t.alive && cid !== 3) t.face(p.group.position);
            if (cid === 4 || cid === 2) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 3) { p.hexShield.visible = true; SoundEngine.play('counter'); const ae = players.find(x => x.id !== p.id && x.alive); if(ae) p.face(ae.group.position); await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 5 || cid === 6) { 
                let isRedUlt = isTutorialMode ? (cid === 5) : ((p.id === 0 ? playerRage.red : p.rage.red) >= 99); 
                p.rage.red = 0; p.rage.blue = 0; if (p.id === 0) playerRage = { red: 0, blue: 0 }; window.updateHPUI();
                if (isRedUlt) { if (t?.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); await performPhysicalSuper(p, t); } } 
                else { if (p.type === 'Loki') { await focusOnAction(p, t, 600); if(t) p.face(t.group.position); await performLokiBlueUlt(p, t); } else { p.face(new THREE.Vector3(0,0,0)); await performLightningStorm(p); } }
            } else if (cid >= 0 && cid < 2) { 
                if (t && t.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); } 
                if (p.type === 'Loki' && cid === 0) { 
                    p.aura.activate(true); 
                    p.ballRotationMultiplier = 15.0; 
                    p.ball.scale.set(3,3,3); 
                    await sleep(600); 
                    const op = p.group.position.clone(); // Capture Origin
                    const tpv = t.group.position.clone(); 
                    await move(p.group, tpv.clone().add(op.clone().sub(tpv).normalize().multiplyScalar(45)), 150); 
                    SoundEngine.play('skid'); 
                    calcDamage(p, t, 0); 
                    await sleep(300); 
                    p.ball.scale.set(1,1,1); 
                    p.aura.deactivate(); 
                    p.ballRotationMultiplier = 1.0; 
                    await move(p.group, op, 500); // Return to Origin
                } 
                else await performAttack(p, t, cid);
            } 
            if (localId !== currentDemoId) return; hideMove(); window.updateHPUI(); await sleep(300); resetCamera(); await sleep(1500); 
        } 
        const s = players.filter(p => p.alive);
        if (s.length <= 1) {
            let winner = s.length > 0 ? s[0] : null; if (winner) { matchScores[winner.id] = (matchScores[winner.id] || 0) + 1; players.forEach(p => p.refreshLabel()); }
            if (winner && matchScores[winner.id] >= targetWins) { if (isTutorialMode) startTurn(); else { showMsg(TRANSLATIONS[currentLang].finalVictory.replace('{name}', winner.getDisplayName()), true); if (isMultiplayer && window.Online.isHost) window.Network.broadcast({ type: 'GAME_OVER', msg: TRANSLATIONS[currentLang].finalVictory.replace('{name}', winner.getDisplayName()), isFinal: true, scores: matchScores }); } } 
            else { const wn = winner ? winner.getDisplayName() : "Draw"; if (isMultiplayer && window.Online.isHost) { startRoundTransition(wn); window.Network.broadcast({ type: 'GAME_OVER', autoRestart: true, winnerName: wn, scores: matchScores }); setTimeout(() => { window.Network.broadcast({ type: 'SHOW_CLEANUP' }); setTimeout(() => { window.Network.hostStartGame(); window.Network.broadcast({ type: 'HIDE_CLEANUP' }); }, 3000); }, 5000); } else if (!isMultiplayer) { if (isTutorialMode) startTurn(); else { startRoundTransition(wn); setTimeout(() => { const c = document.getElementById('cleanup-msg'); if(c) c.classList.add('active'); setTimeout(() => { window.restartRound(); if(c) c.classList.remove('active'); }, 3000); }, 5000); } } }
        } else startTurn();
    }
    
    function endTurn() { 
        if (gameState !== 'WAITING') return; if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer);
        const getPri = (myId) => { const o = (myId + 2) % 4, l = (myId + 1) % 4, r = (myId + 3) % 4; if (players[o]?.alive) return o; if (players[l]?.alive) return l; if (players[r]?.alive) return r; return getRandomTarget(myId); };
        let myP = players[myPlayerIndex]; if (myP.action.card === -1) myP.action = { card: (isTutorialMode ? -1 : (myP.fatigue >= 100 ? 0 : 4)), target: getPri(myP.id), selectionTime: Date.now() + 10000 };
        if (isTutorialMode) { const uc = players[myPlayerIndex].action.card, dAI = players[1]; if (dAI && dAI.alive) { if (uc === 2 || uc === 4) { dAI.action = { card: 0, target: myPlayerIndex, selectionTime: Date.now() }; dAI.face(players[myPlayerIndex].group.position); } else if (uc === 3) { dAI.action = { card: 1, target: myPlayerIndex, selectionTime: Date.now() }; dAI.face(players[myPlayerIndex].group.position); } else dAI.action = { card: -1, target: -1 }; } players.forEach((p, i) => { if (i !== myPlayerIndex && i !== 1) p.action = { card: -1, target: -1 }; }); }
        players.forEach((p, i) => { if (!p.alive || (isTutorialMode && i !== myPlayerIndex)) return; if (isMultiplayer) { if (p.action.card === -1 && (!window.Online.playerMap[i] || !window.Online.playerMap[i].isCpu)) p.action = { card: (p.fatigue >= 100 ? 0 : 4), target: getPri(p.id), selectionTime: Date.now() + 10000 }; } if (!isMultiplayer || (window.Online.playerMap[i]?.isCpu)) { if (i !== myPlayerIndex && p.action.card === -1) { p.action = { card: 0, target: getPri(p.id), selectionTime: Date.now() + 10000 }; if (players[p.action.target]) p.face(players[p.action.target].group.position); } } });
        if (isMultiplayer && window.Online.isHost) window.Network.broadcast({ type: 'TURN_RESOLVE', actions: players.map(p => p.action) });
        resolveActions(); 
    }
    
    function cpuThink() {
        if (gameState !== 'WAITING' || isTutorialMode || timeLeft > (TURN_TIME - 1) || timeLeft <= 4) return;
        players.forEach((p, idx) => {
            if (!p.alive) return;
            const isCpu = (isMultiplayer && window.Online.playerMap[idx]?.isCpu) || (!isMultiplayer && idx !== 0) || (idx === myPlayerIndex && isAutoPlay);
            if (isCpu) {
                 const threats = players.filter(enemy => enemy.alive && enemy.id !== idx && enemy.action.target === idx); let chosenT = p.action.target; 
                 if (chosenT === -1 || Math.random() < 0.4 || threats.length > 0) { const fTs = players.filter(o => o.id !== idx && o.alive && o.fatigue >= 100); if (fTs.length > 0 && Math.random() < 0.85) chosenT = fTs[Math.floor(Math.random() * fTs.length)].id; else if (threats.length > 0 && Math.random() < 0.7) chosenT = threats[Math.floor(Math.random() * threats.length)].id; else { const vTs = players.filter(o => o.id !== idx && o.alive); if (vTs.length > 0) chosenT = vTs[Math.floor(Math.random() * vTs.length)].id; } }
                 if (chosenT !== -1 && players[chosenT]) { p.action.target = chosenT; p.face(players[chosenT].group.position); }
                 let choice = p.action.card; if (choice === -1 || Math.random() < 0.3) { 
                     const maxR = Math.max(p.rage.red, p.rage.blue); 
                     if (maxR >= 99 && Math.random() < 0.9) { 
                         choice = 5; 
                         if (p.type === 'Loki' && p.rage.blue > p.rage.red) { 
                             // LOKI BLUE ULT LOGIC
                             const enemies = players.filter(e => e.id !== idx && e.alive);
                             const healthyEnemies = enemies.filter(e => e.hp > p.hp);
                             if (healthyEnemies.length > 0) {
                                 // Found someone with more HP, target them
                                 const target = healthyEnemies[0];
                                 p.action.target = target.id;
                                 p.face(target.group.position);
                             } else {
                                 // I have most HP, don't swap! Use Magic instead
                                 choice = 1; 
                             }
                         }
                     } else { 
                         if (p.type === 'Loki') { if (p.rage.blue > p.rage.red && threats.length >= 2) choice = 2; else { const roll = Math.random(); if (roll < 0.4) choice = 1; else if (roll < 0.6) choice = 2; else if (roll < 0.75) choice = 3; else choice = 4; } } else { const isRed = p.rage.red >= p.rage.blue; choice = Math.random() < 0.6 ? (isRed ? 0 : 1) : (Math.random() < 0.9 ? (isRed ? 2 : 3) : 4); } 
                     } 
                     if (choice === 4 && p.fatigue >= 100) choice = (p.rage.red >= p.rage.blue) ? 0 : 1; 
                     if (threats.length === 0 && !players.some(pl => pl.alive && pl.id !== idx && pl.rage.blue >= 99)) if (choice === 4 || choice === 2 || choice === 3) choice = (p.rage.red >= p.rage.blue) ? 0 : 1; 
                     p.action.card = choice; p.action.selectionTime = Date.now(); 
                 }
                 if (idx === myPlayerIndex && isAutoPlay) { if (chosenT !== -1 && chosenT !== selectedTargetId) { selectedTargetId = chosenT; window.updateHPUI(); } if (choice !== selectedSlot) window.selectCard(choice); }
            }
        });
    }

    function startTurn() {
        if (gameState === 'ENDED') return; if (isMultiplayer && window.Online.isHost) window.Network.broadcast({ type: 'TURN_START' });
        gameState = 'WAITING'; timeLeft = TURN_TIME; selectedSlot = -1; selectedTargetId = -1;
        if (isTutorialMode) tutorialState = 'pick_card'; else tutorialState = 'none'; 
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected', 'disabled')); hideMove();
        const tEl = document.getElementById('timer'); if (isTutorialMode) { if(tEl) tEl.style.display = 'none'; } else { if (tEl) { tEl.innerText = timeLeft; tEl.style.display = "block"; } }
        document.getElementById('turn-hint').style.display = 'block';
        const tutHint = document.getElementById('tutorial-rage-hint'); if (tutHint && isTutorialMode) tutHint.innerText = TRANSLATIONS[currentLang].tutRageHint;
        const getPri = (myId) => { const o = (myId + 2) % 4, l = (myId + 1) % 4, r = (myId + 3) % 4; if (players[o]?.alive) return o; if (players[l]?.alive) return l; if (players[r]?.alive) return r; return getRandomTarget(myId); };
        players.forEach((p, i) => { p.fatigue = Math.max(0, p.fatigue - 35); p.showBrokenShield = p.fatigue >= 100; p.defendHitCount = 0; if (p.hexShield) p.hexShield.visible = false; p.updateLabel(); const dt = getPri(p.id); p.action = { card: -1, target: dt, selectionTime: 0 }; if (dt !== -1 && players[dt]) { p.face(players[dt].group.position); if (i === myPlayerIndex) { if (!isTutorialMode) selectedTargetId = dt; else selectedTargetId = -1; } } else if (i === myPlayerIndex) selectedTargetId = -1; if (!isTutorialMode && i === myPlayerIndex) { if (Math.max(p.rage.red, p.rage.blue) >= 99) window.selectCard(5); } });
        resetCamera(); window.updateHPUI(); if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer); cpuThinkTimer = setInterval(cpuThink, 800); 
        if (!isTutorialMode) timerInterval = setInterval(() => { timeLeft--; if (tEl) tEl.innerText = timeLeft; if (timeLeft <= 0) { if(tEl) tEl.style.display = "none"; if (!isMultiplayer || window.Online.isHost) endTurn(); } }, 1000);
    }

    window.selectCard = function(i) { 
        if (gameState !== 'WAITING') return; const p = players[myPlayerIndex]; if (!p || !p.alive) return;
        selectedSlot = i; document.querySelectorAll('.card').forEach((c, idx) => c.classList.toggle('selected', idx === i)); if(!isAutoPlay) SoundEngine.play('click'); 
        if (isTutorialMode) { 
            const tl = TRANSLATIONS[currentLang]; const hint = document.getElementById('tutorial-rage-hint'); 
            if (hint) { let name = (i === 5 ? tl.tutCardNames[5] : (i === 6 ? tl.tutCardNames[6] : (i === 2 ? (p.type === 'Loki' ? tl.cardNames.swap : tl.cardNames[2]) : tl.cardNames[i]))); let desc = (typeof tl.cardDescs[i] === 'object') ? tl.cardDescs[i][p.type] : tl.cardDescs[i]; hint.innerHTML = `<span style="color:#ffcc00; font-size:1.2rem;">${name}</span><br><span style="font-size:1rem; color:#fff;">${desc}</span>`; }
        }
        showCardDescription(i); p.action.card = i; p.action.selectionTime = Date.now();
        if (p.type === 'Loki' && i === 2 && players.filter(pl => pl.id !== p.id && pl.alive).length < 2) { showMove("éœ€2åä»¥ä¸Šå°æ‰‹"); p.action.card = -1; selectedSlot = -1; document.querySelectorAll('.card').forEach(c => c.classList.remove('selected')); return; }
        const isMagUlt = (i === 6 || (i === 5 && !((p.id === 0 ? playerRage.red : p.rage.red) >= 99) && !isTutorialMode));
        if (i === 0 || i === 1 || (i === 5 && isMagUlt === false)) { 
            if (p.action.target === myPlayerIndex || p.action.target === -1) { if (selectedTargetId !== -1 && selectedTargetId !== myPlayerIndex && players[selectedTargetId].alive) p.action.target = selectedTargetId; else { const o = (p.id + 2) % 4, l = (p.id + 1) % 4, r = (p.id + 3) % 4; p.action.target = players[o]?.alive ? o : (players[l]?.alive ? l : (players[r]?.alive ? r : -1)); } } if (p.action.target !== -1 && p.action.target !== myPlayerIndex) selectedTargetId = p.action.target; 
            if (isTutorialMode) tutorialState = 'pick_target'; 
        }
        if (i === 2 || i === 3 || i === 4 || isMagUlt || (isTutorialMode && i === 6)) { 
            // Fix for Loki Blue Ult auto-target in Tutorial/Normal
            if (isMagUlt && p.type === 'Loki') {
                const enemies = players.filter(e => e.id !== p.id && e.alive);
                if (enemies.length > 0) {
                     // Pick random if not selected or self
                     if (selectedTargetId === -1 || selectedTargetId === p.id) {
                         const rnd = enemies[Math.floor(Math.random() * enemies.length)];
                         p.action.target = rnd.id;
                         selectedTargetId = rnd.id;
                     } else {
                         p.action.target = selectedTargetId;
                     }
                }
            } else {
                p.action.target = myPlayerIndex; selectedTargetId = -1; 
            }
            
            if (isTutorialMode) { tutorialState = 'none'; if (tutorialTurnTimer) clearTimeout(tutorialTurnTimer); tutorialTurnTimer = setTimeout(() => endTurn(), 500); } 
        }
        if (isMultiplayer && !window.Online.isHost) window.Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
    };

    function handleInt(x, y) { 
        if (gameState !== 'WAITING') return; const p = players[myPlayerIndex]; if (!p || !p.alive) return;
        const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((x - rect.left) / rect.width) * 2 - 1; mouse.y = -((y - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); 
        const chars = players.filter(enemy => enemy && enemy.id !== myPlayerIndex && enemy.alive).map(enemy => enemy.group);
        const intersects = raycaster.intersectObjects(chars, true); 
        if (intersects.length > 0) { 
            let o = intersects[0].object; while(o && !o.userData.isCharacter) o = o.parent; 
            if (o && o.userData.playerId !== myPlayerIndex) { 
                selectedTargetId = o.userData.playerId; p.action.target = selectedTargetId; p.action.selectionTime = Date.now(); p.face(players[selectedTargetId].group.position); SoundEngine.init(); SoundEngine.play('click'); window.updateHPUI(); 
                if (isMultiplayer && !window.Online.isHost) window.Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
                if (isTutorialMode && p.action.card !== -1) { tutorialState = 'none'; if (tutorialTurnTimer) clearTimeout(tutorialTurnTimer); tutorialTurnTimer = setTimeout(() => endTurn(), 300); }
            } 
        } 
    }

    function startRoundTransition(winnerName) { const tEl = document.getElementById('timer'); if (tEl) tEl.style.display = 'none'; showMove(`${TRANSLATIONS[currentLang].roundWinner} ${winnerName}`); setTimeout(() => { showMove(TRANSLATIONS[currentLang].nextRoundIn); }, 2000); }
    window.startBattle = function(customConfigs = null) { document.getElementById('game-msg').style.display = 'none'; hideMove(); window.UI.show('game-ui'); initBattle(customConfigs); };
    window.startTutorial = function() { isTutorialMode = true; document.getElementById('game-msg').style.display = 'none'; hideMove(); window.UI.show('game-ui'); initBattle([ { id: 0, x: 0, y: 50, z: 140, name: (selectedPlayerType === 'Loki' ? "æ´›åŸº" : "å¥§ä¸") + " (YOU)", type: selectedPlayerType }, { id: 1, x: 0, y: 50, z: -140, name: "ç¨»è‰è±¬ (AI)", type: 'Odin' }, { id: 2, x: 140, y: 50, z: 0, name: "é¶å­A", type: 'Loki' }, { id: 3, x: -140, y: 50, z: 0, name: "é¶å­B", type: 'Odin' } ]); };

    function spawnPlayers(customConfigs) { 
        let configs = customConfigs || [ { id: 0, x: 0, y: 50, z: 140, name: selectedPlayerType, type: selectedPlayerType }, { id: 1, x: 0, y: 50, z: -140, name: "æ´›åŸº", type: 'Loki' }, { id: 2, x: 140, y: 50, z: 0, name: "å¥§ä¸A", type: 'Odin' }, { id: 3, x: -140, y: 50, z: 0, name: "å¥§ä¸B", type: 'Odin' } ];
        if (!customConfigs) { myPlayerIndex = 0; isMultiplayer = false; if (gameState === 'IDLE' || Object.keys(matchScores).length === 0) { matchScores = {}; configs.forEach(p => matchScores[p.id] = 0); } }
        players = configs.map(cfg => new Odin(cfg)); window.updateText(); window.updateHPUI();
    }
    
    function initWorld() { scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 200, 2500); scene.add(new THREE.AmbientLight(0xffffff, 0.5)); const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(200, 400, 100); sun.castShadow = true; sun.shadow.mapSize.width = sun.shadow.mapSize.height = 2048; scene.add(sun); const arena = new THREE.Mesh(new THREE.BoxGeometry(375, 15, 375), new THREE.MeshPhongMaterial({ color: 0x88bb88 })); arena.position.y = -15; arena.receiveShadow = true; scene.add(arena); for(let i=0; i<12; i++) { const h = 700 + Math.random()*400, a = (i/12)*Math.PI*2, m = new THREE.Mesh(new THREE.BoxGeometry(300, h, 300), new THREE.MeshPhongMaterial({ color: 0xcc99aa })); m.position.set(Math.cos(a)*1200, h/2 - 1200, Math.sin(a)*1200); scene.add(m); const cap = new THREE.Mesh(new THREE.BoxGeometry(305, 70, 305), new THREE.MeshPhongMaterial({ color: 0xffffff })); cap.position.set(m.position.x, m.position.y + h/2, m.position.z); scene.add(cap); } }
    
    function initBattle(customConfigs) { 
        const v = document.getElementById('viewport'), oc = v.querySelector('canvas'); if (oc) v.removeChild(oc); 
        scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000); 
        renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.setPixelRatio(window.devicePixelRatio); v.appendChild(renderer.domElement); 
        raycaster = new THREE.Raycaster(); clock = new THREE.Clock(); initWorld(); spawnPlayers(customConfigs); adjustCameraForResponsive(true); animate(); 
        window.addEventListener('resize', () => { if(camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); adjustCameraForResponsive(); } }); 
        window.addEventListener('mousedown', (e) => { SoundEngine.init(); handleInt(e.clientX, e.clientY); }); 
        window.addEventListener('touchstart', (e) => { SoundEngine.init(); if(e.touches[0]) handleInt(e.touches[0].clientX, e.touches[0].clientY); }); 
        if (!isMultiplayer || window.Online.isHost) startTurn(); else document.getElementById('turn-hint').innerText = TRANSLATIONS[currentLang].waitingOthers; 
    }
    
    function animate() { 
        animationId = requestAnimationFrame(animate); const dt = clock.getDelta(); 
        for(let i=activeLightnings.length-1; i>=0; i--) if(!activeLightnings[i].update()) activeLightnings.splice(i,1); 
        for(let i=activeParticles.length-1; i>=0; i--) if(!activeParticles[i].update(dt)) activeParticles.splice(i,1); 
        for(let i=activeProjectiles.length-1; i>=0; i--) if(!activeProjectiles[i].update(dt)) activeProjectiles.splice(i,1); 
        
        // --- TUTORIAL POINTER LOGIC ---
        if (isTutorialMode && tutorialState !== 'none') {
            const ptr = document.getElementById('tutorial-pointer');
            if (ptr) {
                if (tutorialState === 'pick_card') {
                    const now = Date.now();
                    // 1. Determine available card IDs
                    let availableCards = ['card-0', 'card-1', 'slot-2-btn', 'card-3', 'defend-card'];
                    const p = players[myPlayerIndex];
                    if (p) {
                        const s1 = document.getElementById('super-card');
                        if (s1 && s1.style.display !== 'none') availableCards.push('super-card');
                        const s2 = document.getElementById('super-card-2');
                        if (s2 && s2.style.display !== 'none') availableCards.push('super-card-2');
                    }
                    
                    // 2. Update index every 300ms
                    if (now - lastTutorialUpdate > 300) {
                        tutorialCardIndex = (tutorialCardIndex + 1) % availableCards.length;
                        lastTutorialUpdate = now;
                    }
                    
                    // 3. Position Pointer
                    const currentId = availableCards[tutorialCardIndex];
                    const btn = document.getElementById(currentId); 
                    if (btn) {
                        const rect = btn.getBoundingClientRect();
                        ptr.innerText = "ğŸ‘†";
                        ptr.style.animation = "bounce-up 1s infinite";
                        ptr.style.left = (rect.left + rect.width/2 - 25) + 'px';
                        ptr.style.top = (rect.bottom + 10) + 'px';
                        ptr.style.display = 'block';
                    }
                } else if (tutorialState === 'pick_target') {
                    const t = players[1]; 
                    if (t && t.alive) {
                        const pos = t.group.position.clone().add(new THREE.Vector3(0, 60, 0));
                        const v = pos.project(camera);
                        const x = (v.x * .5 + .5) * window.innerWidth;
                        const y = (-(v.y * .5) + .5) * window.innerHeight;
                        ptr.innerText = "ğŸ‘‡";
                        ptr.style.animation = "bounce-down 1s infinite";
                        ptr.style.left = (x - 25) + 'px';
                        ptr.style.top = (y - 80) + 'px';
                        ptr.style.display = 'block';
                    }
                }
            }
        } else {
            const ptr = document.getElementById('tutorial-pointer');
            if (ptr) ptr.style.display = 'none';
        }
        // ------------------------------

        if (renderer && scene && camera) { players.forEach(p => { if(p && p.alive) { p.group.position.y = 50 + Math.sin(Date.now()*0.003 + p.id)*4; p.uiSprite.quaternion.copy(camera.quaternion); if (p.targetQuaternion) p.group.quaternion.slerp(p.targetQuaternion, 5 * dt); if(p.hexShield && p.hexShield.visible) p.hexShield.rotation.z += 0.05; if(p.type === 'Loki' && p.ball) { p.ball.rotation.y += 0.05 * p.ballRotationMultiplier; p.ball.rotation.x += 0.02 * p.ballRotationMultiplier; } if (Math.max(p.rage.red, p.rage.blue) >= 99) { if (!p.aura.active || p.aura.isRed !== (p.rage.red >= p.rage.blue)) p.aura.activate(p.rage.red >= p.rage.blue); } else if (p.aura.active) p.aura.deactivate(); p.aura.update(dt); if (p.brokenShieldIcon.visible) { const s = 8 + Math.sin(Date.now() * 0.005) * 1.5; p.brokenShieldIcon.scale.set(s, s, 1); p.brokenShieldIcon.material.opacity = 0.6 + Math.sin(Date.now() * 0.005) * 0.2; } 
        if (p.id === selectedTargetId && p.id !== myPlayerIndex && p.alive) { p.selectionSprite.visible = true; const sv = Math.sin(Date.now() * 0.005) * 2.0; p.selectionSprite.scale.set(15 + sv, 15 + sv, 1); p.selectionSprite.material.rotation += 0.02; } else p.selectionSprite.visible = false; 
        const maxR = Math.max(p.rage.red, p.rage.blue); if (p.alive && maxR >= 99) { const isR = p.rage.red >= p.rage.blue; p.ultraRedSprite.visible = isR; p.ultraBlueSprite.visible = !isR; const s = 10 + Math.sin(Date.now() * 0.01) * 1; (isR?p.ultraRedSprite:p.ultraBlueSprite).scale.set(s, 2.5 + Math.sin(Date.now() * 0.01)*0.2, 1); } else { p.ultraRedSprite.visible = p.ultraBlueSprite.visible = false; }
        if (p.alive) { if (p.smirkSprite.visible) { const s = 15 + Math.sin(Date.now() * 0.01) * 3; p.smirkSprite.scale.set(s, s, 1); p.smirkSprite.rotation.z = Math.sin(Date.now() * 0.01) * 0.2; } if (p.sweatSprite.visible) { p.sweatSprite.scale.set(15, 15, 1); p.sweatSprite.position.y = 8 - Math.abs(Math.sin(Date.now() * 0.005)) * 1; } }
        } }); renderer.render(scene, camera); } 
    }

    window.resetGame = function() { if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer); if (animationId) cancelAnimationFrame(animationId); document.getElementById('game-msg').style.display = 'none'; document.getElementById('turn-hint').style.display = 'none'; currentDemoId++; players.length = 0; playerRage = { red: 0, blue: 0 }; gameState = 'IDLE'; matchScores = {}; isTutorialMode = false; tutorialState = 'none'; document.getElementById('scoreboard').style.display = 'none'; window.UI.showMenu(); if(window.Online.peer) window.Online.peer.destroy(); window.Online.peer = null; window.Online.playerMap = []; window.Online.connections = []; window.Online.hostConn = null; };
    window.askOracle = async function() { SoundEngine.init(); const btn = document.getElementById('oracle-btn-card'); if (gameState !== 'WAITING' || btn.classList.contains('loading')) return; btn.classList.add('loading'); const p = players[myPlayerIndex]; try { const r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, { method: 'POST', body: JSON.stringify({ contents: [{ parts: [{ text: `Stats: HP:${p.hp}/500` }] }], systemInstruction: { parts: [{ text: "è±¬è±¬å…ˆçŸ¥ï¼Œçµ¦ç°¡çŸ­å»ºè­°ã€‚" }] } }) }); const res = await r.json(); const txt = res.candidates?.[0]?.content?.parts?.[0]?.text; if (txt) showMove(`âœ¨è±¬è±¬å…ˆçŸ¥: ${txt.trim()}`); } catch(e){} btn.classList.remove('loading'); };
    function showMsg(t, isFinal = false) { const el = document.getElementById('game-msg'); const btnText = isFinal ? TRANSLATIONS[currentLang].finalMenu : TRANSLATIONS[currentLang].restart; const btnAction = isFinal ? "window.resetGame()" : "window.restartRound()"; let btnHtml = `<button class="btn-gold" style="margin-top:10px;" onclick="${btnAction}">${btnText}</button>`; if (isMultiplayer && !window.Online.isHost && !isFinal) btnHtml = `<div style="font-size:0.9rem; color:#aaa; margin-top:10px;">${TRANSLATIONS[currentLang].waitingHost}</div>`; el.innerHTML = `${isFinal ? `<div class="final-victory-text">${t}</div>` : `<span>${t}</span>`}<br>${btnHtml}`; el.style.display = 'flex'; }
    window.restartRound = function() { if (isMultiplayer && !window.Online.isHost) return; if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer); document.getElementById('game-msg').style.display = 'none'; hideMove(); if (scene) { while(scene.children.length > 0){ const o = scene.children[0]; if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose(); scene.remove(o); } } players.length = 0; activeLightnings.length = 0; activeParticles.length = 0; activeProjectiles.length = 0; playerRage = { red: 0, blue: 0 }; if (isMultiplayer && window.Online.isHost) window.Network.hostStartGame(); else window.startBattle(); };
</script>
</body>
</html>