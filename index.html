<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è±¬ç¥é»ƒæ˜ Pignarok Arena (Ver 22.9)</title>
    <!-- å¼•å…¥ PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- åŸºç¤è¨­å®š --- */
        :root {
            --ui-max-width: 500px;
            --primary-gold: #ff99cc;
            --bg-overlay: rgba(0, 0, 0, 0.4);
            --accent-blue: #55ccff;
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: 'Cinzel', serif, "Microsoft JhengHei", "Helvetica Neue", sans-serif;
            background: #000; color: white;
            touch-action: none; width: 100vw; height: 100vh;
            -webkit-user-select: none; user-select: none;
        }
        
        #viewport {
            position: relative; width: 100%; height: 100%;
            background: #87CEEB; overflow: hidden;
        }

        #viewport canvas { display: block; width: 100% !important; height: 100% !important; outline: none; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle, rgba(40, 20, 80, 0.95) 0%, rgba(10, 5, 20, 1) 100%);
            z-index: 2000; transition: opacity 0.5s ease; padding: 20px; box-sizing: border-box;
            opacity: 0; pointer-events: none; /* é è¨­éš±è— */
        }
        
        .overlay-screen.active {
            opacity: 1; pointer-events: auto;
        }

        /* ä¸»ç•«é¢èƒŒæ™¯è±¬ (Menu Hero Pig) */
        .menu-bg-pig {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            width: 80%;
            max-width: 500px;
            height: auto;
            max-height: 60vh; 
            opacity: 0.25; 
            z-index: 0; 
            pointer-events: none;
            object-fit: contain;
        }

        h1 { 
            font-size: clamp(2.5rem, 8vw, 4.5rem); margin-bottom: 5px; color: var(--primary-gold); 
            text-shadow: 0 0 20px rgba(255, 153, 204, 0.6); letter-spacing: 5px; text-align: center; 
            z-index: 2;
            position: relative; 
        }
        .sub-title { 
            font-size: 1.2rem; color: #fff; margin-bottom: 5px; letter-spacing: 2px; opacity: 0.8; 
            z-index: 2; 
            position: relative;
        }
        
        .version-text {
            font-size: 0.8rem;
            color: #d4af37; 
            margin-bottom: 30px;
            letter-spacing: 1px;
            opacity: 0.9;
            font-family: monospace;
            z-index: 2;
            position: relative;
        }

        .studio-footer {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            font-size: 0.75rem;
            color: #666;
            font-family: 'Cinzel', serif;
            letter-spacing: 3px;
            opacity: 0.7;
        }

        h2 { font-size: 1.4rem; color: #fff; margin-bottom: 20px; border-bottom: 2px solid var(--primary-gold); padding-bottom: 8px; }

        input.input-box, select.input-box {
            background: rgba(255, 255, 255, 0.1); border: 2px solid var(--primary-gold);
            color: white; padding: 12px; font-size: 1.2rem; margin: 10px 0;
            border-radius: 8px; text-align: center; width: 80%; max-width: 300px;
            font-family: inherit; outline: none;
        }
        select.input-box option { background: #333; color: white; }
        input.input-box::placeholder { color: #aaa; }

        .room-code-display {
            font-size: 3rem; color: var(--accent-blue); letter-spacing: 10px;
            margin: 20px 0; padding: 15px 40px; border: 3px dashed rgba(255, 255, 255, 0.3);
            background: rgba(0,0,0,0.3); border-radius: 10px;
        }

        .player-list {
            list-style: none; padding: 0; width: 100%; max-width: 400px; margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden;
        }
        .player-list li {
            background: rgba(255,255,255,0.05); padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
        }
        .tag-host { color: #f1c40f; font-size: 0.8rem; border: 1px solid #f1c40f; padding: 2px 6px; border-radius: 4px; }
        .tag-me { color: #2ecc71; font-size: 0.8rem; }

        @keyframes breathe {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }
        .breathing-text {
            animation: breathe 2.5s infinite ease-in-out;
            color: #88ccff;
            font-size: 0.9rem;
            margin-top: 10px;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 1px;
        }

        .mini-char-select {
            display: flex; gap: 10px; margin: 15px 0; width: 80%; max-width: 300px;
        }
        .mini-card {
            flex: 1; padding: 10px; border: 1px solid #888; border-radius: 8px;
            cursor: pointer; transition: 0.2s; background: rgba(0,0,0,0.3);
            display: flex; flex-direction: column; align-items: center; opacity: 0.6;
        }
        .mini-card.active {
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2);
            opacity: 1; transform: scale(1.05);
        }
        .mini-icon { font-size: 1.5rem; margin-bottom: 5px; }

        #turn-hint {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 1rem; font-weight: bold; text-shadow: 0 0 10px #000;
            background: var(--bg-overlay); padding: 5px 15px; border-radius: 20px;
            display: none; z-index: 50; pointer-events: none;
            white-space: nowrap; border: 1px solid rgba(255, 255, 255, 0.2);
        }
        @media (min-width: 768px) { #turn-hint { top: 100px; font-size: 1.2rem; } }

        @keyframes hint-flash { 0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); } 50% { opacity: 0.3; transform: translateX(-50%) scale(0.95); } }
        .flashing { animation: hint-flash 1s infinite ease-in-out; }

        .btn-gold {
            padding: 12px 30px; font-size: 1.1rem; background: rgba(255, 153, 204, 0.2);
            border: 2px solid var(--primary-gold); color: var(--primary-gold); cursor: pointer; border-radius: 50px;
            transition: all 0.3s; font-family: 'Cinzel', serif; text-transform: uppercase;
            max-width: 300px; width: 100%; margin-bottom: 15px;
            z-index: 5;
        }
        .btn-gold:hover { background: var(--primary-gold); color: #1a0d0d; transform: scale(1.05); }
        .btn-gold:disabled { border-color: #555; color: #888; background: transparent; cursor: not-allowed; transform: none; }

        .btn-back { border-color: #aaa; color: #ccc; font-size: 0.9rem; padding: 8px 20px; margin-top: 10px; width: auto; }

        .lang-container {
            display: flex; gap: 15px; margin-bottom: 30px;
            z-index: 5;
        }
        .btn-lang {
            padding: 8px 20px; font-size: 0.9rem; background: transparent;
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            transition: all 0.3s;
        }
        .btn-lang.active { background: var(--primary-gold); color: #000; border-color: var(--primary-gold); }
        .btn-lang:hover { transform: scale(1.1); }

        .selection-container { 
            display: flex; gap: 15px; margin-bottom: 30px; width: 100%; max-width: 600px;
            flex-direction: row; 
        }
        @media (max-width: 350px) { .selection-container { flex-direction: column; } }

        .char-card {
            flex: 1; background: rgba(255,255,255,0.05); border: 2px solid transparent;
            border-radius: 12px; padding: 15px; cursor: pointer; transition: 0.3s;
            display: flex; flex-direction: column; align-items: center; text-align: center;
        }
        .char-card.active { border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2); transform: translateY(-5px); }
        .char-portrait-icon { font-size: 3rem; margin-bottom: 5px; }

        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        
        #top-announcer {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            width: 100%; max-width: var(--ui-max-width);
            text-align: center; pointer-events: none; z-index: 100;
        }
        #timer { color: #fff; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1); }
        #move-display {
            color: var(--primary-gold); font-size: clamp(1rem, 3.5vw, 1.3rem); font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1);
            margin-top: 5px; opacity: 0; transition: opacity 0.3s;
            background: rgba(0,0,0,0.8); padding: 12px 30px; border-radius: 50px;
            display: inline-block; border: 3px solid var(--primary-gold);
            white-space: normal; width: auto;
        }

        #status-log {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: var(--ui-max-width); height: 42px; background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 153, 204, 0.4); border-radius: 8px; padding: 5px; font-size: 0.8rem; overflow-y: auto;
            pointer-events: auto; color: #eee; backdrop-filter: blur(3px); z-index: 30; text-align: left;
        }
        
        #card-description {
            position: absolute; bottom: 160px; 
            left: 0; width: 100%;
            text-align: center; color: #ffeb3b; font-size: 0.85rem; font-weight: bold;
            text-shadow: 0 0 5px #000; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            background: linear-gradient(to right, transparent, rgba(0,0,0,0.7), transparent);
            padding: 5px 0; z-index: 25;
        }

        #bottom-ui-container {
            position: absolute; bottom: 30px; 
            left: 0; width: 100%;
            display: flex; justify-content: center;
            padding: 10px 0 20px 0; 
            background: linear-gradient(to top, rgba(0,0,0,1) 30%, rgba(0,0,0,0.6) 80%, transparent);
            pointer-events: auto; z-index: 20;
        }

        #card-area { 
            display: flex; flex-direction: row; gap: 3px; 
            width: 98%; max-width: var(--ui-max-width); 
            justify-content: space-evenly; align-items: flex-end; 
        }

        #player-hp-card {
            flex: 1.2; height: 95px; min-width: 50px;
            background: rgba(80, 0, 40, 0.7); border: 1.5px solid var(--primary-gold); border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 4px 2px; color: #fff; backdrop-filter: blur(10px);
            font-size: 0.58rem; font-weight: bold; line-height: 1.3; text-align: center; box-sizing: border-box;
        }

        .name-text { font-size: 0.62rem; color: var(--primary-gold); margin-bottom: 2px; width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .hp-text { font-size: 0.58rem; color: #ffccdd; }
        .fatigue-text { color: #ffaa00; font-size: 0.52rem; }
        .rage-text { font-size: 0.52rem; color: #ff8888; }

        .card {
            flex: 1; height: 95px; min-width: 40px; 
            background: rgba(255, 255, 255, 0.1); border: 1.2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; cursor: pointer; transition: 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; color: #fff; font-weight: bold; backdrop-filter: blur(5px); 
            font-size: 0.55rem; 
            padding: 2px; box-sizing: border-box; user-select: none;
        }
        .card:active { transform: scale(0.92); }
        .card.selected { 
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.3); 
            transform: scale(1.15) translateY(-10px); box-shadow: 0 0 20px rgba(255, 153, 204, 0.6); z-index: 100;
        }
        .card.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .card.disabled-tut { opacity: 0.3; pointer-events: none; filter: grayscale(1); border-color: #555; }
        .card.demoing { border-color: #55ccff; background: rgba(0, 100, 200, 0.4); transform: scale(1.05); }

        .card:hover { background: rgba(255, 255, 255, 0.2); }

        @keyframes card-breathing-red { 0%, 100% { box-shadow: 0 0 5px #ff5555; } 50% { box-shadow: 0 0 20px #ff0000; } }
        @keyframes card-breathing-blue { 0%, 100% { box-shadow: 0 0 5px #55ccff; } 50% { box-shadow: 0 0 20px #0088ff; } }
        
        .card.super { color: #000; border-color: #fff; font-weight: 800; }
        .card.super-red { animation: card-breathing-red 1.5s infinite; background: linear-gradient(135deg, #ff9999, #fff); }
        .card.super-blue { animation: card-breathing-blue 1.5s infinite; background: linear-gradient(135deg, #99ccff, #fff); }

        .circle-btn {
            position: absolute; width: 45px; height: 45px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid var(--primary-gold);
            color: #fff; font-size: 0.8rem; font-weight: bold;
            cursor: pointer; z-index: 200; display: flex; justify-content: center; align-items: center;
            pointer-events: auto; transition: all 0.2s;
            top: 20px; top: max(20px, env(safe-area-inset-top));
        }
        .circle-btn:hover { transform: scale(1.1); background: var(--primary-gold); color: #000; }

        .home-btn { left: 20px; left: max(20px, env(safe-area-inset-left)); font-size: 1.5rem; padding-bottom: 3px; }

        #game-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1rem; 
            color: #fff; display: none; background: rgba(0,0,0,0.95);
            padding: 15px 25px; 
            border-radius: 15px; 
            border: 2px solid var(--primary-gold); 
            z-index: 3000;
            text-align: center; width: 80%; 
            max-width: 280px; 
            backdrop-filter: blur(10px);
            flex-direction: column; align-items: center; 
            gap: 10px; 
        }

        #tutorial-ui {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: none; flex-direction: column; align-items: center;
            background: linear-gradient(to top, rgba(0,0,0,1) 40%, rgba(0,0,0,0.8) 90%, transparent);
            padding-bottom: 20px; pointer-events: auto; z-index: 25;
        }
        #tutorial-desc {
            color: #fff; font-size: 1rem; text-align: center; margin-bottom: 10px;
            padding: 10px 20px; background: rgba(0,0,0,0.5); border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2); width: 90%; max-width: var(--ui-max-width);
        }
        .tutorial-controls {
            display: flex; gap: 3px; width: 98%; max-width: var(--ui-max-width);
            justify-content: center; margin-bottom: 10px;
        }
        .back-btn-container { position: absolute; top: 20px; right: 20px; z-index: 200; }
        .btn-small {
            padding: 8px 15px; font-size: 0.9rem; background: rgba(0,0,0,0.6);
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            font-family: 'Cinzel', serif;
        }

        .damage-popup {
            position: absolute;
            color: #ff0000; 
            font-family: "Arial Black", "Arial", sans-serif;
            font-weight: 900;
            font-size: 2.2rem;
            letter-spacing: -2px;
            text-shadow: 
                2px 2px 0 #000, 
               -1px -1px 0 #000,  
                1px -1px 0 #000,
               -1px 1px 0 #000,
                1px 1px 0 #000,
                3px 3px 5px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 4000;
            user-select: none;
            opacity: 0;
            transform: scale(0.5);
        }
        
        @keyframes damage-pop {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-30px) scale(1.3); opacity: 1; }
            40% { transform: translateY(-40px) scale(1.0); opacity: 1; }
            80% { transform: translateY(-60px) scale(1.0); opacity: 1; }
            100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
        }

        @media (min-width: 1024px) {
            #status-log { bottom: 150px; width: 100%; font-size: 1rem; height: 50px; }
            .card { font-size: 0.8rem; }
            .name-text, .hp-text, .fatigue-text, .rage-text { font-size: 0.75rem; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<div id="viewport">
    
    <div id="main-menu" class="overlay-screen active">
        <img src="pignarok_bg.jpg" class="menu-bg-pig" alt="Pig Background">
        <h1 id="menu-title">è±¬ç¥é»ƒæ˜</h1>
        <div class="sub-title">PIGNAROK ARENA</div>
        <div class="version-text">ç‰ˆæœ¬ 22.9</div>
        <div class="lang-container">
            <button id="lang-zh" class="btn-lang active" onclick="window.setLang('zh-TW')">ä¸­æ–‡</button>
            <button id="lang-en" class="btn-lang" onclick="window.setLang('en-US')">ENG</button>
        </div>
        <button id="btn-create" class="btn-gold" onclick="UI.showCreate()">å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)</button>
        <button id="btn-join" class="btn-gold" onclick="UI.showJoin()">åŠ å…¥ç¶²çµ¡å°æˆ°</button>
        <button id="btn-tutorial" class="btn-gold" onclick="window.startTutorialSelection()">è§’è‰²æ•™å­¸</button>
        <div class="studio-footer">JASDEV STUDIO 2025</div>
    </div>

    <div id="screen-create" class="overlay-screen">
        <h2 id="create-title">å‰µå»ºéŠæˆ²æˆ¿é–“</h2>
        <p id="create-name-label">è«‹è¼¸å…¥ä½ çš„æš±ç¨±</p>
        <input type="text" id="host-name" class="input-box" placeholder="åç¨± (16å­—å…§)" maxlength="16">
        <p style="margin-top:10px; font-size:0.9rem; color:#aaa;">è³½åˆ¶ (Match Format)</p>
        <select id="match-format" class="input-box" style="width:80%; max-width:300px;">
            <option value="2">3 å±€ 2 å‹ (Best of 3)</option>
            <option value="3">5 å±€ 3 å‹ (Best of 5)</option>
            <option value="5">7 å±€ 5 å‹ (Best of 7)</option>
        </select>
        <p id="create-char-label" style="margin-top:20px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-host-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div>Odin</div>
            </div>
            <div id="mini-host-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div>Loki</div>
            </div>
        </div>
        <button id="btn-do-create" class="btn-gold" onclick="Network.createGame()">ç”Ÿæˆæˆ¿é–“</button>
        <button id="btn-create-back" class="btn-gold btn-back" onclick="UI.showMenu()">è¿”å›</button>
    </div>

    <div id="screen-join" class="overlay-screen">
        <h2 id="join-title">åŠ å…¥ç¶²çµ¡å°æˆ°</h2>
        <input type="text" id="join-name" class="input-box" placeholder="ä½ çš„æš±ç¨± (16å­—å…§)" maxlength="16">
        <input type="number" id="join-code" class="input-box" placeholder="4ä½æ•¸æˆ¿è™Ÿ" maxlength="4">
        <p id="join-char-label" style="margin-top:20px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-join-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div>Odin</div>
            </div>
            <div id="mini-join-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div>Loki</div>
            </div>
        </div>
        <p id="join-status" style="color:#55ccff; font-size:0.9rem; min-height:20px;"></p>
        <button class="btn-gold" id="btn-connect" onclick="Network.joinGame()">é–‹å§‹é€£ç·š</button>
        <button id="btn-join-back" class="btn-gold btn-back" onclick="UI.showMenu()">è¿”å›</button>
    </div>

    <div id="screen-lobby" class="overlay-screen">
        <h2 id="lobby-title">æº–å‚™å¤§å»³</h2>
        <div class="room-code-display" id="lobby-code">----</div>
        <p id="lobby-share-hint">è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)</p>
        <div id="lobby-hint" class="breathing-text">(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)</div>
        <ul class="player-list" id="lobby-list"></ul>
        <div id="host-controls" style="display:none; width:100%; text-align:center;">
            <button class="btn-gold" id="btn-start-net" onclick="Network.hostStartGame()" disabled>é–‹å§‹éŠæˆ²</button>
        </div>
        <div id="client-msg" style="display:none; color:#aaa; margin-top:20px;">ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...</div>
        <button id="btn-leave-room" class="btn-gold btn-back" onclick="window.resetGame()">é›¢é–‹æˆ¿é–“</button>
    </div>

    <div id="turn-hint" class="flashing">è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹</div>

    <div id="char-select" class="overlay-screen" style="display:none;">
        <h2 id="char-select-title">é¸æ“‡ä½ çš„è±¬è±¬æˆ°å£«</h2>
        <div class="selection-container">
            <div id="select-odin" class="char-card active" onclick="window.pickChar('Odin')">
                <div class="char-portrait-icon">âš¡ğŸ·</div>
                <div id="char-name-odin" class="char-name">å¥§ä¸è±¬</div>
                <div id="char-desc-odin" style="font-size:0.7rem; color:#ccc; margin-top:5px;">é›·éœ†èˆ‡æ¦®è€€</div>
            </div>
            <div id="select-loki" class="char-card" onclick="window.pickChar('Loki')">
                <div class="char-portrait-icon">ğŸƒğŸ·</div>
                <div id="char-name-loki" class="char-name">æ´›åŸºè±¬</div>
                <div id="char-desc-loki" style="font-size:0.7rem; color:#ccc; margin-top:5px;">è©­è¨ˆèˆ‡é®®è‚‰</div>
            </div>
        </div>
        <button id="btn-start-battle" class="btn-gold" onclick="window.confirmSelection()">é–‹å§‹æ±ºé¬¥</button>
        <button id="btn-back-menu" class="btn-gold btn-back" onclick="window.resetGame()">è¿”å›</button>
    </div>

    <div id="game-msg"></div>
    <div id="dmg-container" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:4000; overflow:hidden;"></div>

    <div id="game-ui">
        <button class="circle-btn home-btn" onclick="window.resetGame()" title="å›ä¸»é¸å–®">ğŸ </button>
        <div id="scoreboard" style="display:none;"></div>
        <div id="top-announcer">
            <div id="timer">10</div>
            <div id="move-display">æº–å‚™ä¸­...</div>
        </div>
        <div id="card-description"></div> 
        <div id="bottom-ui-container">
            <div id="card-area">
                <div id="player-hp-card">
                    <div id="player-name-display" class="name-text">å¥§ä¸è±¬</div>
                    <div id="hp-line" class="hp-text">HP: 500/500</div>
                    <div id="fatigue-line" class="fatigue-text">ç–²å‹: 0%</div>
                    <div id="rage-line" class="rage-text">æ€’æ°£: 0%</div>
                </div>
                <div id="card-0" class="card" onclick="window.selectCard(0)">ç‰©æ”»âš”ï¸</div>
                <div id="card-1" class="card" onclick="window.selectCard(1)">é­”æ³•ğŸª„</div>
                <div id="slot-2-btn" class="card" onclick="window.selectCard(2)">åæ“ŠğŸ›¡ï¸</div>
                <div id="card-3" class="card" onclick="window.selectCard(3)">åå°„ğŸ’</div>
                <div id="defend-card" class="card" onclick="window.selectCard(4)">é˜²ç¦¦ğŸ§±</div>
                <div id="super-card" class="card super" style="display:none;" onclick="window.selectCard(5)">å¥§ç¾©ğŸ”¥</div>
                <div id="oracle-btn-card" onclick="window.askOracle()">âœ¨</div>
            </div>
        </div>
    </div>

    <div id="tutorial-ui">
        <div class="back-btn-container">
            <button id="btn-back-tut" class="btn-small" onclick="window.quitTutorial()">å›ä¸»é¸å–®</button>
        </div>
        <div id="tutorial-desc">é»æ“Šä¸‹æ–¹åœ–ç¤ºè§€çœ‹æŠ€èƒ½æ¼”ç¤º</div>
        <div class="tutorial-controls">
            <div id="tut-card-0" class="card" onclick="window.demoAction(0)">ç‰©æ”»âš”ï¸</div>
            <div id="tut-card-1" class="card" onclick="window.demoAction(1)">é­”æ³•ğŸª„</div>
            <div id="tut-card-2" class="card" onclick="window.demoAction(2)">åæ“ŠğŸ›¡ï¸</div>
            <div id="tut-card-3" class="card" onclick="window.demoAction(3)">åå°„ğŸ’</div>
            <div id="tut-card-4" class="card" onclick="window.demoAction(4)">é˜²ç¦¦ğŸ§±</div>
            <div id="tut-card-5" class="card super super-red" onclick="window.demoAction(5)">ç‰©å¥§ğŸ”¥</div>
            <div id="tut-card-6" class="card super super-blue" onclick="window.demoAction(6)">é­”å¥§âš¡</div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const APP_ID_PREFIX = "pig-ragnarok-v1-"; 
    const apiKey = ""; 
    const MAX_HP_ODIN = 500; 
    const MAX_HP_LOKI = 400;
    const TURN_TIME = 15; 
    let BASE_CAM_Y = 280; let BASE_CAM_Z = 600;
    let DEFAULT_CAM_POS = new THREE.Vector3(0, BASE_CAM_Y, BASE_CAM_Z);
    const DEFAULT_LOOK_AT = new THREE.Vector3(0, 40, -20);
    let targetWins = 2; 
    
    // --- TRANSLATION SYSTEM ---
    let currentLang = 'zh-TW';
    const TRANSLATIONS = {
        'zh-TW': {
            title: "è±¬ç¥é»ƒæ˜", singlePlayer: "å–®äººéŠæˆ²", tutorial: "è§’è‰²æ•™å­¸",
            createGameBtn: "å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)", joinGameBtn: "åŠ å…¥ç¶²çµ¡å°æˆ°",
            lobbyHint: "(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)",
            createTitle: "å‰µå»ºéŠæˆ²æˆ¿é–“", enterName: "è«‹è¼¸å…¥ä½ çš„æš±ç¨±", namePlaceholder: "åç¨± (16å­—å…§)",
            chooseChar: "é¸æ“‡ä½ çš„è§’è‰²", doCreateBtn: "ç”Ÿæˆæˆ¿é–“", backBtn: "è¿”å›",
            joinTitle: "åŠ å…¥ç¶²çµ¡å°æˆ°", codePlaceholder: "4ä½æ•¸æˆ¿è™Ÿ", doConnectBtn: "é–‹å§‹é€£ç·š",
            lobbyTitle: "æº–å‚™å¤§å»³", lobbyShare: "è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)", leaveRoom: "é›¢é–‹æˆ¿é–“",
            waitingHost: "ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...", startGame: "é–‹å§‹éŠæˆ²",
            selectCharTitle: "é¸æ“‡ä½ çš„è±¬è±¬æˆ°å£«", selectPracticeChar: "é¸æ“‡è¦ç·´ç¿’çš„è§’è‰²",
            startBattle: "é–‹å§‹æ±ºé¬¥", startPractice: "é–‹å§‹ç‰¹è¨“",
            back: "è¿”å›", backMenu: "å›ä¸»é¸å–®",
            odinName: "å¥§ä¸è±¬", odinDesc: "é›·éœ†èˆ‡æ¦®è€€",
            lokiName: "æ´›åŸºè±¬", lokiDesc: "è©­è¨ˆèˆ‡é®®è‚‰",
            charOdin: "å¥§æ±€", charLoki: "æ´›åŸº",
            turnHint: "è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹", ready: "æº–å‚™ä¸­...",
            moveNames: ["ç‰©ç†æ”»æ“Š", "é­”æ³•æ”»æ“Š", "åæ“Š", "é­”æ³•åå°„", "é˜²ç¦¦", "çµ‚æ¥µå¥§ç¾©"],
            cardNames: { 0: "ç‰©æ”»âš”ï¸", 1: "é­”æ³•ğŸª„", 2: "åæ“ŠğŸ›¡ï¸", 3: "åå°„ğŸ’", 4: "é˜²ç¦¦ğŸ§±", 5: "å¥§ç¾©ğŸ”¥", swap: "ç©ºé–“ğŸŒ€" },
            tutCardNames: { 5: "ç‰©å¥§ğŸ”¥", 6: "é­”å¥§âš¡" },
            victory: "å‹åˆ©ï¼", gameOver: "å›åˆçµæŸ", restart: "é‡æ–°é–‹å§‹",
            finalVictory: "è±¬æ—åŒ¹æ–¯èª”ç”Ÿäº†æ–°çš„ç‹ï¼", finalMenu: "å›åˆ°ä¸»é¸å–®",
            swapSkill: "ç©ºé–“èª¿æ›", counterSkill: "é˜²ç¦¦åæ“Š",
            targetLocked: "(ç›®æ¨™é–å®šä¸­)", dead: "èŠ­æ¯”Qå•¦", fatigue: "ç–²å‹", rage: "æ€’æ°£",
            defendFatigue: "é˜²ç¦¦ç–²å‹ä¸­", defend: "é˜²ç¦¦", tired: "åŠ›ç›¡ğŸ§±",
            tutDesc: "é»æ“Šä¸‹æ–¹åœ–ç¤ºè§€çœ‹æŠ€èƒ½æ¼”ç¤º", tutEnd: "æ¼”ç¤ºå®Œç•¢ã€‚è«‹é¸æ“‡ä¸‹ä¸€å€‹æŠ€èƒ½ã€‚",
            tut0_odin: "ã€å²¡æ ¼å°¼çˆ¾æ–¬ã€‘Odin æ®èˆç¥æ§é€²è¡Œè¿‘æˆ°æ”»æ“Šï¼Œé€ æˆç‰©ç†å‚·å®³ä¸¦ç´¯ç©ç´…è‰²æ€’æ°£ã€‚",
            tut0_loki: "ã€æ»¾çƒæ”»æ“Šã€‘Loki å°‡è‡ªå·±è®Šæˆçƒæ’å‘æ•µäººï¼Œé€ æˆç‰©ç†å‚·å®³ä¸¦ç´¯ç©ç´…è‰²æ€’æ°£ã€‚",
            tut1_odin: "ã€é›·éœ†è¬éˆã€‘å¬å–šé–ƒé›»æ”»æ“Šæ•µäººï¼Œé€ æˆé­”æ³•å‚·å®³ï¼Œç´¯ç©è—è‰²æ€’æ°£ã€‚",
            tut1_loki: "ã€é®®è‚‰æŠ•æ“²ã€‘ä¸Ÿå‡ºä¸€å¡Šå·¨å¤§çš„è‚‰ï¼Œå°æ•µäººé€ æˆé­”æ³•å‚·å®³ï¼Œç´¯ç©è—è‰²æ€’æ°£ã€‚è‚‰å¡Šè½åœ°æœƒçˆ†ç‚¸ï¼",
            tut2_odin: "ã€é˜²ç¦¦åæ“Šã€‘é€²å…¥é˜²ç¦¦å§¿æ…‹ï¼Œè‹¥å—åˆ°ã€Œç‰©ç†æ”»æ“Šã€å°‡è‡ªå‹•åæ“Šã€‚",
            tut2_loki: "ã€ç©ºé–“èª¿æ›ã€‘(ç‰¹æ®Š) ç•¶å—åˆ°ç‰©ç†æ”»æ“Šæ™‚ï¼Œå°‡è‡ªå·±èˆ‡å¦ä¸€å€‹æ•µäººäº¤æ›ä½ç½®ï¼(éœ€æœ‰å¤šå€‹ç›®æ¨™)",
            tut3_odin: "ã€é­”æ³•åå°„ã€‘è‹¥å—åˆ°é­”æ³•æ”»æ“Šï¼Œä½¿ç”¨ç¥åŠ›åå½ˆå‚·å®³ã€‚",
            tut3_loki: "ã€é­”æ³•åå°„ã€‘è‹¥å—åˆ°é­”æ³•æ”»æ“Šï¼Œå°‡å‚·å®³åå½ˆçµ¦å°æ‰‹ã€‚",
            tut4: "ã€çµ•å°é˜²ç¦¦ã€‘å¤§å¹…é™ä½å‚·å®³ï¼Œä½†å¢åŠ ç–²å‹å€¼ã€‚ç–²å‹éé«˜ä¸‹å›åˆç„¡æ³•é˜²ç¦¦ï¼",
            tut5_odin: "ã€è«¸ç¥é»ƒæ˜ã€‘(ç‰©ç†å¥§ç¾©) æ€’æ°£å…¨æ»¿(ç´…)æ™‚ç™¼å‹•ï¼Œæ¯€æ»…æ€§é€£æ“Šï¼",
            tut5_loki: "ã€è©­è¨ˆãƒ»è‚‰å½ˆæˆ°è»Šã€‘(ç‰©ç†å¥§ç¾©) æ€’æ°£å…¨æ»¿(ç´…)æ™‚ç™¼å‹•ï¼Œå°å–®ä¸€ç›®æ¨™é€²è¡Œ3æ¬¡ä¾†å›è¡æ’ï¼",
            tut6_odin: "ã€é›·ç¥ä¹‹æ€’ã€‘(é­”æ³•å¥§ç¾©) æ€’æ°£å…¨æ»¿(è—)æ™‚ç™¼å‹•ï¼Œå¬å–šæ¯€æ»…æ€§çš„é›·æš´ï¼",
            tut6_loki: "ã€è©­è¨ˆãƒ»å¤©é™è‚‰é›¨ã€‘(é­”æ³•å¥§ç¾©) æ€’æ°£å…¨æ»¿(è—)æ™‚ç™¼å‹•ï¼Œå¬å–šå·¨å‹è‚‰å¡Šè½Ÿç‚¸å ´åœ°ï¼",
            cardDescs: {
                0: "é€ æˆç‰©ç†å‚·å®³ï¼Œå¢åŠ ç´…è‰²æ€’æ°£",
                1: "é€ æˆé­”æ³•å‚·å®³ï¼Œå¢åŠ è—è‰²æ€’æ°£",
                2: { "Odin": "å—åˆ°ç‰©ç†æ”»æ“Šæ™‚è‡ªå‹•åæ“Š", "Loki": "å—åˆ°ç‰©ç†æ”»æ“Šæ™‚èˆ‡æ•µäººäº¤æ›ä½ç½®" },
                3: "åå½ˆå—åˆ°çš„é­”æ³•å‚·å®³",
                4: "å¤§å¹…æ¸›å‚·ï¼Œä½†å¢åŠ ç–²å‹å€¼",
                5: { "Odin": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£ï¼Œé€ æˆæ¯€æ»…æ€§é€£æ“Š", "Loki": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£ï¼Œå°å–®ä¸€ç›®æ¨™é€£çºŒè¡æ’" }
            },
            logBlock: "æ ¼æª”ï¼", logCounter: "çš„åæ“Šåœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼",
            logReflect: "çš„åå°„åœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼", logHit: "çš„æ”»æ“Šï¼",
            playerSuffix: " (æˆ‘)", cpuPrefix: "(CPU) ",
            tutorialName: "æ•™å­¸", dummyName: "å‡äºº", civilian: "è·¯äºº",
            ragnarok: "è«¸ç¥çš„é»ƒæ˜å·²ç¶“é™è‡¨...", pigKing: "è±¬è±¬ä¹‹ç‹èª•ç”Ÿäº†ï¼",
            lockingTargets: "é–å®šç›®æ¨™ï¼",
            waitingOthers: "ç­‰å¾…å…¶ä»–ç©å®¶...",
            connError: "é€£ç·šéŒ¯èª¤", incomplete: "è¼¸å…¥ä¸å®Œæ•´", hostLeft: "æˆ¿ä¸»å·²æ–·ç·šï¼ŒéŠæˆ²çµæŸ",
            winSuffix: "å‹",
            roundWinner: "å›åˆå‹åˆ©è€…ï¼š", nextRoundIn: "ç­‰å¾…ç©å®¶é€£ç·šåŒæ­¥ä¸­...",
            currentRound: "ç•¶å‰å±€åˆ†",
            dmgLog: "é€ æˆ {dmg} å‚·å®³ï¼"
        },
        'en-US': {
            title: "PIGNAROK", singlePlayer: "Single Player", tutorial: "Tutorial",
            createGameBtn: "Host Game (Online supported)", joinGameBtn: "Join Arena",
            lobbyHint: "(CPU will fill empty slots if < 4 players)",
            createTitle: "Create Game Room", enterName: "Enter your nickname", namePlaceholder: "Name (Max 16 chars)",
            chooseChar: "Choose Your Character", doCreateBtn: "Create Room", backBtn: "Back",
            joinTitle: "Join Network Arena", codePlaceholder: "4-Digit Room Code", doConnectBtn: "Connect",
            lobbyTitle: "Lobby", lobbyShare: "Share Room Code (Max 4 Players)", leaveRoom: "Leave Room",
            waitingHost: "Waiting for host to start...", startGame: "Start Game",
            selectCharTitle: "Select Your Warrior", selectPracticeChar: "Select Character",
            startBattle: "Start Battle", startPractice: "Start Training",
            back: "Back", backMenu: "Main Menu",
            odinName: "Odin", odinDesc: "Thunder & Glory",
            lokiName: "Loki", lokiDesc: "Tricks & Meat",
            charOdin: "Odin", charLoki: "Loki",
            turnHint: "Select a card below and tap an enemy", ready: "Ready...",
            moveNames: ["Melee", "Magic", "Counter", "Reflect", "Defend", "Ultimate"],
            cardNames: { 0: "Meleeâš”ï¸", 1: "MagicğŸª„", 2: "CountğŸ›¡ï¸", 3: "ReflğŸ’", 4: "DefğŸ§±", 5: "UltğŸ”¥", swap: "SwapğŸŒ€" },
            tutCardNames: { 5: "Phys UltğŸ”¥", 6: "Mag Ultâš¡" },
            victory: "VICTORY!", gameOver: "GAME OVER", restart: "Play Again", finalVictory: "The New Emperor!", finalMenu: "Main Menu",
            swapSkill: "Spatial Swap", counterSkill: "Counter",
            targetLocked: "(Target Locked)", dead: "Barbecued", fatigue: "Fatigue", rage: "Rage",
            defendFatigue: "Fatigued", defend: "Defend", tired: "TiredğŸ§±",
            tutDesc: "Tap icons below to see skill demos", tutEnd: "Demo finished. Select next skill.",
            tut0_odin: "[Gungnir Slash] Melee attack. Deals physical dmg, builds Red Rage.",
            tut0_loki: "[Ball Attack] Rolls into enemy. Deals physical dmg, builds Red Rage.",
            tut1_odin: "[Thunderstrike] Summons lightning. Deals magic dmg, builds Blue Rage.",
            tut1_loki: "[Meat Throw] Throws giant meat. Magic dmg, Blue Rage. Explodes on impact!",
            tut2_odin: "[Counter] Defensive stance. Auto-counters Melee attacks.",
            tut2_loki: "[Swap] (Special) Swaps position with another enemy when hit by Melee! (Needs multiple targets)",
            tut3_odin: "[Reflect] Reflects Magic damage back to attacker.",
            tut3_loki: "[Reflect] Bounces Magic damage back to attacker.",
            tut4: "[Defend] Reduces dmg significantly but adds Fatigue. Cannot defend if Fatigued!",
            tut5_odin: "[Ragnarok] (Phys Ult) Requires Max Red Rage. Devastating combo!",
            tut5_loki: "[Meat Chariot] (Phys Ult) Requires Max Red Rage. Rushes target 3 times!",
            tut6_odin: "[Thor's Wrath] (Magic Ult) Requires Max Blue Rage. Summon storms!",
            tut6_loki: "[Meat Rain] (Magic Ult) Requires Max Blue Rage. Bombards the field!",
            cardDescs: {
                0: "Deals Physical DMG, builds Red Rage",
                1: "Deals Magic DMG, builds Blue Rage",
                2: { "Odin": "Counters Physical attacks automatically", "Loki": "Swaps position when hit by Physical attack" },
                3: "Reflects Magic damage back",
                4: "Reduces damage significantly, adds Fatigue",
                5: { "Odin": "Consumes Max Rage for devastating combo", "Loki": "Consumes Max Rage to rush target repeatedly" }
            },
            logBlock: "Blocked", logCounter: "'s counter failed against Ultimate!",
            logReflect: "'s reflect failed against Ultimate!", logHit: "'s attack!",
            playerSuffix: " (Me)", cpuPrefix: "(CPU) ",
            tutorialName: "Teacher", dummyName: "Dummy", civilian: "Civilian",
            ragnarok: "Ragnarok has come...", pigKing: "The Pig King is born!",
            lockingTargets: "Locking Targets!",
            waitingOthers: "Waiting for others...",
            connError: "Connection Error", incomplete: "Input incomplete", hostLeft: "Host disconnected, game over",
            winSuffix: " Wins",
            roundWinner: "Round Winner: ", nextRoundIn: "Waiting for player sync...",
            currentRound: "Current Scores",
            dmgLog: "hit for {dmg} damage!"
        }
    };
    let CARD_NAMES = []; 

    let scene, camera, renderer, clock, raycaster;
    let players = [], gameState = 'IDLE', timeLeft = TURN_TIME, selectedSlot = -1, selectedTargetId = -1;
    let timerInterval, cpuThinkTimer, playerRage = { red: 0, blue: 0 };
    let selectedPlayerType = 'Odin';
    let isTutorialMode = false; let isTutorialSelection = false;
    let currentDemoId = 0; 
    const mouse = new THREE.Vector2();
    let animationId = null; 
    let myPlayerIndex = 0; 
    let isMultiplayer = false;
    
    let matchScores = {}; 

    const Online = {
        isHost: false,
        myName: "Player",
        roomCode: "",
        peer: null,
        myPeerId: "",
        connections: [], 
        hostConn: null, 
        playerMap: [], 
        hasActed: false, 
        matchConfig: { targetWins: 2 }
    };

    let activeLightnings = [], activeParticles = [], activeProjectiles = [];
    const SHARED_BOX_GEO = new THREE.BoxGeometry(1.2, 1.2, 1.2);

    const SoundEngine = { ctx: null, init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); }, play(type) { this.init(); const now = this.ctx.currentTime; const masterGain = this.ctx.createGain(); masterGain.connect(this.ctx.destination); masterGain.gain.setValueAtTime(0.4, now); const osc = this.ctx.createOscillator(); const env = this.ctx.createGain(); osc.connect(env); env.connect(masterGain); let dur = 0.3; switch(type) { case 'click': osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); env.gain.setValueAtTime(0.2, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.1); dur=0.1; break; case 'slash': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(450, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.2); env.gain.setValueAtTime(0.2, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'magic': osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.4); env.gain.setValueAtTime(0.12, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.4); dur=0.4; break; case 'hit': osc.type = 'sine'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now+0.15); env.gain.setValueAtTime(0.4, now); env.gain.linearRampToValueAtTime(0, now+0.15); dur=0.15; break; case 'counter': osc.type = 'square'; osc.frequency.setValueAtTime(1100, now); env.gain.setValueAtTime(0.1, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'super': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(90, now); env.gain.setValueAtTime(0.3, now); env.gain.exponentialRampToValueAtTime(0.001, now+1.2); dur=1.2; break; case 'bonk': osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); env.gain.setValueAtTime(0.8, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.2); dur=0.2; break; case 'ding': osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(2400, now + 0.05); env.gain.setValueAtTime(0.5, now); env.gain.exponentialRampToValueAtTime(0.001, now + 0.3); dur = 0.3; break; } osc.start(now); osc.stop(now+dur); setTimeout(() => { if(osc) osc.disconnect(); if(env) env.disconnect(); if(masterGain) masterGain.disconnect(); }, 2000); } };

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function move(obj, target, ms) { return new Promise(res => { const start = obj.position.clone(), t = performance.now(); function up() { let p = Math.min(1, (performance.now() - t) / ms); obj.position.lerpVectors(start, target, p); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    function adjustCameraForResponsive(snap = false) { 
        if (!camera || !renderer) return; 
        const aspect = window.innerWidth / window.innerHeight; 
        let targetY = BASE_CAM_Y; let targetZ = BASE_CAM_Z; 
        
        // Portrait mode adjustments (wider view, further back)
        if (aspect > 1.2) { 
            targetY = 240; targetZ = 550; 
        } else if (aspect < 0.6) { 
            targetZ = 850; // Increased Z for vertical screens
            targetY = 320; 
        } else {
            targetZ = 650;
            targetY = 280;
        }
        
        let rotY = 0;
        if (myPlayerIndex === 1) rotY = Math.PI;
        else if (myPlayerIndex === 2) rotY = Math.PI/2;
        else if (myPlayerIndex === 3) rotY = -Math.PI/2;

        const basePos = new THREE.Vector3(0, targetY, targetZ);
        basePos.applyAxisAngle(new THREE.Vector3(0,1,0), rotY);

        DEFAULT_CAM_POS.copy(basePos);
        
        if (snap) {
            camera.position.copy(DEFAULT_CAM_POS);
            camera.lookAt(DEFAULT_LOOK_AT);
        } else if (gameState === 'WAITING' || gameState === 'IDLE' || gameState === 'TUTORIAL_IDLE') { 
            camera.position.lerp(DEFAULT_CAM_POS, 0.1); 
            camera.lookAt(DEFAULT_LOOK_AT); 
        } 
    }
    
    function resetCamera() { 
        if (camera) { 
            adjustCameraForResponsive(); 
            camera.position.copy(DEFAULT_CAM_POS); 
            camera.lookAt(DEFAULT_LOOK_AT); 
        } 
    }

    function showMove(text) {
        const md = document.getElementById('move-display');
        md.innerText = text;
        md.style.opacity = "1";
        md.classList.add('announce-anim');
    }

    function hideMove() {
        const md = document.getElementById('move-display');
        md.style.opacity = "0";
        md.classList.remove('announce-anim');
    }

    function spawnDamageNumber(target, amount) {
        if (!target) return;
        const txt = TRANSLATIONS[currentLang];
        const div = document.createElement('div');
        div.className = 'damage-popup';
        if (typeof amount === 'number') {
            div.innerText = "-" + amount;
            div.style.color = "#ff0000"; 
        } else {
            div.innerText = amount;
            div.style.color = "#ffff00"; 
        }
        const pos = target.group.position.clone().add(new THREE.Vector3(0, 40, 0));
        const vector = pos.project(camera);
        const x = (vector.x * .5 + .5) * window.innerWidth;
        const y = (-(vector.y * .5) + .5) * window.innerHeight;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.style.animation = 'damage-pop 0.8s ease-out forwards';
        const container = document.getElementById('dmg-container');
        if(container) container.appendChild(div);
        setTimeout(() => { if (div.parentNode) div.parentNode.removeChild(div); }, 800);
    }

    window.setLang = function(lang) {
        currentLang = lang;
        document.getElementById('lang-zh').classList.toggle('active', lang === 'zh-TW');
        document.getElementById('lang-en').classList.toggle('active', lang === 'en-US');
        updateText();
    };

    function updateText() {
        const t = TRANSLATIONS[currentLang];
        document.getElementById('menu-title').innerText = t.title;
        document.getElementById('btn-create').innerText = t.createGameBtn;
        document.getElementById('btn-join').innerText = t.joinGameBtn;
        document.getElementById('lobby-hint').innerText = t.lobbyHint;
        document.getElementById('create-title').innerText = t.createTitle;
        document.getElementById('create-name-label').innerText = t.enterName;
        document.getElementById('host-name').placeholder = t.namePlaceholder;
        document.getElementById('btn-do-create').innerText = t.doCreateBtn;
        document.getElementById('btn-create-back').innerText = t.backBtn;
        document.getElementById('join-title').innerText = t.joinTitle;
        document.getElementById('join-name').placeholder = t.namePlaceholder;
        document.getElementById('join-code').placeholder = t.codePlaceholder;
        document.getElementById('btn-connect').innerText = t.doConnectBtn;
        document.getElementById('btn-join-back').innerText = t.backBtn;
        document.getElementById('lobby-title').innerText = t.lobbyTitle;
        document.getElementById('btn-leave-room').innerText = t.leaveRoom;
        document.getElementById('btn-tutorial').innerText = t.tutorial;
        document.getElementById('char-select-title').innerText = isTutorialSelection ? t.selectPracticeChar : t.selectCharTitle;
        document.getElementById('btn-start-battle').innerText = isTutorialSelection ? t.startPractice : t.startBattle;
        document.getElementById('btn-back-menu').innerText = t.back;
        document.getElementById('turn-hint').innerText = t.turnHint;
        document.getElementById('card-0').innerText = t.cardNames[0];
        document.getElementById('card-1').innerText = t.cardNames[1];
        document.getElementById('card-3').innerText = t.cardNames[3];
        document.getElementById('defend-card').innerText = t.cardNames[4];
        document.getElementById('super-card').innerText = t.cardNames[5];
        if (gameState === 'TUTORIAL_IDLE') { document.getElementById('tutorial-desc').innerText = t.tutDesc; }
        CARD_NAMES = [...t.moveNames]; 
        if (players.length > 0) {
            const p = players[myPlayerIndex];
            if(p) {
                const slot2 = document.getElementById('slot-2-btn');
                if (p.type === 'Loki') {
                    slot2.innerText = t.cardNames.swap; 
                    CARD_NAMES[2] = t.swapSkill;
                } else {
                    slot2.innerText = t.cardNames[2];
                    CARD_NAMES[2] = t.counterSkill;
                }
                const defBtn = document.getElementById('defend-card');
                if (p.fatigue >= 100) defBtn.innerText = t.tired; else defBtn.innerText = t.cardNames[4];
                players.forEach(pl => pl.refreshLabel());
                document.getElementById('player-name-display').innerText = p.getDisplayName();
            }
        }
    }

    const UI = {
        screens: ['main-menu', 'screen-create', 'screen-join', 'screen-lobby', 'char-select', 'game-ui', 'tutorial-ui'],
        show(id) {
            this.screens.forEach(s => {
                const el = document.getElementById(s);
                if(el) { el.classList.remove('active'); el.style.display = 'none'; }
            });
            const t = document.getElementById(id);
            if(t) { 
                t.style.display = 'flex'; 
                setTimeout(()=>t.classList.add('active'), 10); 
                if(id === 'game-ui') t.style.display = 'block'; 
            }
        },
        showMenu() { this.show('main-menu'); },
        showCreate() { 
            selectedPlayerType = 'Odin';
            document.getElementById('mini-host-odin').className = "mini-card active";
            document.getElementById('mini-host-loki').className = "mini-card";
            this.show('screen-create'); 
        },
        showJoin() { 
            selectedPlayerType = 'Odin';
            document.getElementById('mini-join-odin').className = "mini-card active";
            document.getElementById('mini-join-loki').className = "mini-card";
            document.getElementById('join-status').innerText = "";
            document.getElementById('btn-connect').disabled = false;
            this.show('screen-join'); 
        },
        updateLobby(roomCode, playersList) {
            this.show('screen-lobby');
            document.getElementById('lobby-code').innerText = roomCode;
            const list = document.getElementById('lobby-list');
            list.innerHTML = "";
            playersList.forEach(p => {
                const li = document.createElement('li');
                let html = `<span>${p.name} <small style="color:#aaa">(${p.type})</small></span> <div>`;
                if (p.isHost) html += `<span class="tag-host">HOST</span> `;
                if (p.peerId === Online.myPeerId) html += `<span class="tag-me">YOU</span>`;
                html += `</div>`;
                li.innerHTML = html;
                list.appendChild(li);
            });
            if (Online.isHost) {
                document.getElementById('host-controls').style.display = 'block';
                document.getElementById('client-msg').style.display = 'none';
                document.getElementById('btn-start-net').disabled = false; 
            } else {
                document.getElementById('host-controls').style.display = 'none';
                document.getElementById('client-msg').style.display = 'block';
            }
        },
        updateScoreboard() {
            const sb = document.getElementById('scoreboard');
            if (isTutorialMode) { sb.style.display = 'none'; return; }
            sb.innerHTML = `<h3 style="margin:0 0 10px 0; color:#ff99cc; border-bottom:1px solid #555;">${TRANSLATIONS[currentLang].currentRound}</h3>`;
            players.forEach(p => {
                const wins = matchScores[p.id] || 0;
                const crowns = "ğŸ‘‘".repeat(wins);
                const row = document.createElement('div');
                row.className = 'score-row';
                row.innerHTML = `${p.getDisplayName()} <span class="score-num">${crowns}</span>`;
                sb.appendChild(row);
            });
        }
    };

    window.selectMiniChar = function(type) {
        selectedPlayerType = type;
        SoundEngine.init(); SoundEngine.play('click');
        const setUI = (prefix) => {
            document.getElementById(prefix + '-odin').className = type === 'Odin' ? "mini-card active" : "mini-card";
            document.getElementById(prefix + '-loki').className = type === 'Loki' ? "mini-card active" : "mini-card";
        };
        setUI('mini-host'); setUI('mini-join');
    };

    const Network = {
        createGame() {
            const name = document.getElementById('host-name').value.trim();
            const format = document.getElementById('match-format').value;
            if(!name) return;
            Online.isHost = true; Online.myName = name;
            Online.roomCode = Math.floor(1000 + Math.random() * 9000).toString();
            Online.matchConfig.targetWins = parseInt(format) || 2;
            targetWins = Online.matchConfig.targetWins;
            Online.peer = new Peer(APP_ID_PREFIX + Online.roomCode);
            Online.peer.on('open', (id) => {
                Online.myPeerId = id;
                Online.playerMap = [{ name: Online.myName, isHost: true, peerId: id, isCpu: false, type: selectedPlayerType }];
                UI.updateLobby(Online.roomCode, Online.playerMap);
            });
            Online.peer.on('connection', (conn) => {
                if(Online.playerMap.length >= 4) { conn.on('open', () => { conn.send({type:'ERROR', msg:'Full'}); setTimeout(()=>conn.close(), 500); }); return; }
                Online.connections.push(conn);
                conn.on('data', (data) => Network.handleHostData(conn, data));
                conn.on('close', () => {
                    const pIdx = Online.playerMap.findIndex(x => x.peerId === conn.peer);
                    if (pIdx !== -1) {
                        const p = Online.playerMap[pIdx];
                        if (gameState === 'IDLE') {
                            Online.playerMap.splice(pIdx, 1);
                            Online.connections = Online.connections.filter(c => c !== conn);
                            Network.broadcast({type: 'LOBBY_UPDATE', players: Online.playerMap});
                            UI.updateLobby(Online.roomCode, Online.playerMap);
                        } else {
                            p.isCpu = true; p.name += " (CPU)";
                            Network.broadcast({type: 'LOBBY_UPDATE', players: Online.playerMap});
                        }
                    }
                });
            });
        },
        joinGame() {
            const name = document.getElementById('join-name').value.trim();
            const code = document.getElementById('join-code').value.trim();
            if(!name || code.length!==4) return;
            Online.isHost = false; Online.myName = name; Online.roomCode = code;
            document.getElementById('btn-connect').disabled = true;
            Online.peer = new Peer();
            Online.peer.on('open', (id) => {
                Online.myPeerId = id;
                const conn = Online.peer.connect(APP_ID_PREFIX + code);
                conn.on('open', () => {
                    Online.hostConn = conn;
                    conn.send({type: 'JOIN_REQUEST', name: name, characterType: selectedPlayerType});
                });
                conn.on('data', (data) => Network.handleClientData(data));
            });
        },
        handleHostData(conn, data) {
            if(data.type === 'JOIN_REQUEST') {
                const pType = data.characterType || 'Odin';
                const newP = { name: data.name, isHost: false, peerId: conn.peer, isCpu: false, type: pType };
                Online.playerMap.push(newP);
                Network.broadcast({type: 'LOBBY_UPDATE', players: Online.playerMap});
            } else if (data.type === 'ACTION_SUBMIT') {
                const senderIdx = Online.playerMap.findIndex(p => p.peerId === conn.peer);
                if(senderIdx !== -1 && players[senderIdx]) players[senderIdx].action = data.action;
            }
        },
        handleClientData(data) {
            if(data.type === 'LOBBY_UPDATE') {
                Online.playerMap = data.players;
                UI.updateLobby(Online.roomCode, Online.playerMap);
            } else if (data.type === 'GAME_START') {
                myPlayerIndex = data.myIndex; isMultiplayer = true;
                if (data.scores) matchScores = data.scores;
                if (data.targetWins) targetWins = data.targetWins;
                window.startBattle(data.configs);
            } else if (data.type === 'TURN_START') {
                startTurn();
            } else if (data.type === 'TURN_RESOLVE') {
                data.actions.forEach((act, idx) => { if(players[idx]) players[idx].action = act; });
                resolveActions();
            } else if (data.type === 'GAME_OVER') {
                if (data.isFinal) showMsg(data.msg, true);
                else if (data.autoRestart) {
                    if (data.scores) { matchScores = data.scores; players.forEach(p => p.refreshLabel()); }
                    startRoundTransition(data.winnerName);
                }
            }
        },
        broadcast(msg) {
            Online.connections.forEach(c => { if(c.open) c.send(msg); });
            if(msg.type === 'LOBBY_UPDATE') UI.updateLobby(Online.roomCode, Online.playerMap);
        },
        sendHost(msg) { if(Online.hostConn && Online.hostConn.open) Online.hostConn.send(msg); },
        hostStartGame() {
            while(Online.playerMap.length < 4) {
                const isLoki = Math.random() > 0.5;
                Online.playerMap.push({ name: `BOT-${Online.playerMap.length}`, isHost: false, peerId: 'cpu-'+Math.random(), isCpu: true, type: isLoki ? 'Loki' : 'Odin' });
            }
            const configs = [
                { id: 0, x: 0, y: 50, z: 140, name: Online.playerMap[0].name, type: Online.playerMap[0].type }, 
                { id: 1, x: 0, y: 50, z: -140, name: Online.playerMap[1].name, type: Online.playerMap[1].type },
                { id: 2, x: 140, y: 50, z: 0, name: Online.playerMap[2].name, type: Online.playerMap[2].type },
                { id: 3, x: -140, y: 50, z: 0, name: Online.playerMap[3].name, type: Online.playerMap[3].type }
            ];
            if (Object.keys(matchScores).length === 0 || gameState === 'IDLE') {
                matchScores = {}; configs.forEach(p => matchScores[p.id] = 0);
            }
            Online.playerMap.forEach((p, idx) => {
                if(p.isHost) { myPlayerIndex = 0; isMultiplayer = true; window.startBattle(configs); } 
                else if (!p.isCpu) {
                    const conn = Online.connections.find(c => c.peer === p.peerId);
                    if(conn) conn.send({ type: 'GAME_START', configs: configs, myIndex: idx, scores: matchScores, targetWins: targetWins });
                }
            });
        }
    };

    class Odin {
        constructor(cfg) {
            this.id = cfg.id; this.name = cfg.name; this.type = cfg.type || 'Odin';
            this.maxHP = (this.type === 'Loki' ? MAX_HP_LOKI : MAX_HP_ODIN);
            this.hp = this.maxHP; this.alive = true; this.rage = { red: 0, blue: 0 }; 
            this.fatigue = 0; this.defendHitCount = 0; this.showBrokenShield = false; 
            this.action = { card: -1, target: -1, selectionTime: 0 }; this.targetQuaternion = null;
            this.group = new THREE.Group(); this.group.position.set(cfg.x, cfg.y, cfg.z);
            this.group.userData = { isCharacter: true, playerId: cfg.id }; this.group.scale.set(8, 8, 8);
            this.aura = new SuperAura(this.group); this.ballRotationMultiplier = 1.0; 

            const hitGeo = new THREE.BoxGeometry(14, 25, 14); 
            const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false, colorWrite: false }); 
            this.hitBox = new THREE.Mesh(hitGeo, hitMat); this.hitBox.position.y = 5; this.group.add(this.hitBox);
            
            const uiData = createUnitUISprite(); this.uiSprite = uiData.sprite; this.uiCtx = uiData.ctx; this.uiTexture = uiData.texture;
            this.uiSprite.position.y = 8.5; this.group.add(this.uiSprite);
            
            const shieldTex = createBrokenShieldTexture(); const shieldMat = new THREE.SpriteMaterial({ map: shieldTex, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false });
            this.brokenShieldIcon = new THREE.Sprite(shieldMat); this.brokenShieldIcon.scale.set(8, 8, 1); this.brokenShieldIcon.position.set(0, 14, 0); 
            this.brokenShieldIcon.renderOrder = 998; this.brokenShieldIcon.visible = false; this.group.add(this.brokenShieldIcon);

            this.labelSprite = createTextSprite(this.getDisplayName()); this.labelSprite.position.y = -3.5; this.labelSprite.scale.set(10, 2.5, 1);
            this.labelSprite.material.depthTest = false; // Always on top
            this.group.add(this.labelSprite);
            this.modelContainer = new THREE.Group(); this.group.add(this.modelContainer);
            
            const bodyColor = (this.type === 'Loki' ? 0x0a4a0a : 0xffcc00);
            this.body = new THREE.Mesh(new THREE.BoxGeometry(2.1, 2, 2.5), new THREE.MeshPhongMaterial({ color: bodyColor }));
            this.body.position.y = 1; this.body.castShadow = true; this.modelContainer.add(this.body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.8, 1.6), new THREE.MeshPhongMaterial({ color: 0xffdbac }));
            head.position.set(0, 2.5, 0.5); head.castShadow = true; this.modelContainer.add(head);
            this.snout = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.6), new THREE.MeshPhongMaterial({ color: 0xffaaaa }));
            this.snout.position.set(0, 2.3, 1.35); this.snout.castShadow = true; this.modelContainer.add(this.snout);
            const nL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), new THREE.MeshBasicMaterial({color:0x000000})), nR = nL.clone();
            nL.position.set(-0.25, 0.1, 0.35); nR.position.set(0.25, 0.1, 0.35); this.snout.add(nL, nR);
            const earL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.2), new THREE.MeshPhongMaterial({color: 0xffaaaa})), earR = earL.clone();
            earL.position.set(-1.0, 3.2, 0.5); earL.rotation.z = 0.6; earR.position.set(1.0, 3.2, 0.5); earR.rotation.z = -0.6;
            this.modelContainer.add(earL, earR);

            if (this.type === 'Loki') {
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d'); const cols = ['#ff3333', '#33ff33', '#ffffff', '#3333ff']; 
                for(let i=0; i<4; i++) for(let j=0; j<4; j++) { ctx.fillStyle = cols[(i + j) % 4]; ctx.fillRect(i * 64, j * 64, 64, 64); ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(i * 64, j * 64, 64, 64); }
                const ballTex = new THREE.CanvasTexture(canvas); ballTex.wrapS = ballTex.wrapT = THREE.RepeatWrapping; ballTex.repeat.set(2, 2);
                this.ball = new THREE.Mesh(new THREE.SphereGeometry(1.4, 16, 12), new THREE.MeshPhongMaterial({ map: ballTex }));
                this.ball.position.y = -0.4; this.ball.castShadow = true; this.modelContainer.add(this.ball);
                this.modelContainer.position.y = 1.4;
            }

            this.weaponGroup = new THREE.Group();
            if (this.type === 'Odin') {
                const shape = new THREE.Shape();
                shape.moveTo(0, 0); shape.lineTo(0.5, 2); shape.lineTo(-0.2, 1.8); shape.lineTo(0.4, 3.5);
                shape.lineTo(-0.3, 3.2); shape.lineTo(0.6, 6); shape.lineTo(-0.1, 3.8); shape.lineTo(0.5, 4.2);
                shape.lineTo(-0.1, 2.2); shape.lineTo(0.4, 2.5); shape.lineTo(0, 0);
                this.weaponMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.3, bevelEnabled: false }), new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffd700, emissiveIntensity: 2 }));
                this.weaponMesh.position.set(-0.2, -1, 0); this.weaponMesh.castShadow = true; this.weaponGroup.add(this.weaponMesh); 
            }
            this.weaponGroup.position.set(1.5, 1.2, 0.5); this.weaponGroup.rotation.x = -Math.PI/4; this.modelContainer.add(this.weaponGroup);
            this.hexShield = new THREE.Group();
            const hexColor = (this.type === 'Loki' ? 0xff0000 : 0x00ffff);
            const hexStar = new THREE.Mesh(this.createStarGeometry(), new THREE.MeshBasicMaterial({ color: hexColor, transparent: true, opacity: 0.6, side: THREE.DoubleSide }));
            this.hexShield.add(hexStar); 
            for (let i = 0; i < 6; i++) {
                const rune = this.createRuneLine(), angle = (i / 6) * Math.PI * 2;
                rune.position.set(Math.cos(angle) * 3.5, Math.sin(angle) * 3.5, 0.1); rune.rotation.z = angle; this.hexShield.add(rune);
            }
            const centralRune = this.createAlgizRune(); centralRune.scale.set(2, 2, 2); this.hexShield.add(centralRune);
            this.hexShield.position.set(0, 3, 3); this.hexShield.visible = false; this.group.add(this.hexShield);
            this.meatBlock = createMeatModelShared(); this.meatBlock.visible = false; this.group.add(this.meatBlock);
            this.selectionRing = new THREE.Mesh(new THREE.TorusGeometry(5, 0.4, 16, 64), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.9, depthWrite: false }));
            this.selectionRing.rotation.x = Math.PI/2; this.selectionRing.position.y = -1.5; this.selectionRing.visible = false; this.group.add(this.selectionRing);
            this.targetLabel = createTextSprite(TRANSLATIONS[currentLang].targetLocked); this.targetLabel.scale.set(6, 1.5, 1); this.targetLabel.position.y = -6; this.targetLabel.visible = false; this.group.add(this.targetLabel);
            scene.add(this.group); this.face(new THREE.Vector3(0,cfg.y,0)); this.updateLabel();
        }
        getDisplayName() {
             const t = TRANSLATIONS[currentLang];
             if (isTutorialMode) return (this.id === 0) ? t.tutorialName : (this.id === 2 ? t.civilian : t.dummyName);
             let baseName = this.name;
             if (this.name.startsWith("BOT-")) baseName = `CPU${this.id}`;
             const wins = matchScores[this.id] || 0;
             const crowns = "ğŸ‘‘".repeat(wins);
             return wins > 0 ? `${baseName} ${crowns}` : baseName;
        }
        refreshLabel() { if(this.labelSprite) { this.labelSprite.material.map.dispose(); this.labelSprite.material.map = createTextSprite(this.getDisplayName()).material.map; } if(this.brokenShieldIcon) { this.brokenShieldIcon.material.map.dispose(); this.brokenShieldIcon.material.map = createBrokenShieldTexture(); } if(this.targetLabel) { this.targetLabel.material.map.dispose(); this.targetLabel.material.map = createTextSprite(TRANSLATIONS[currentLang].targetLocked).material.map; } }
        createStarGeometry() { const s = new THREE.Shape(); const o=5.5, n=2.8; for(let i=0; i<12; i++){ const a=(i/12)*Math.PI*2, r=(i%2===0)?o:n; if(i===0) s.moveTo(Math.cos(a)*r, Math.sin(a)*r); else s.lineTo(Math.cos(a)*r, Math.sin(a)*r); } s.closePath(); return new THREE.ShapeGeometry(s); }
        createRuneLine() { const pts = [new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0.5, 0, 0), new THREE.Vector3(0, 0.5, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffffff })); }
        createAlgizRune() { const pts = [new THREE.Vector3(0, -0.8, 0), new THREE.Vector3(0, 0.8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-0.6, 0.6, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0.6, 0.6, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })); }
        updateLabel() { if (!this.uiCtx) return; const ctx = this.uiCtx; ctx.clearRect(0, 0, 512, 256); const t = TRANSLATIONS[currentLang]; if (!this.alive) { ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(50, 40, 412, 160); ctx.font = 'bold 80px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#ff99cc'; ctx.fillText(t.dead, 256, 150); this.uiTexture.needsUpdate = true; return; } const r = this.rage, u = Math.floor(Math.max(r.red, r.blue)); ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(50, 40, 412, 160); ctx.font = 'bold 36px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = 'white'; ctx.fillText(`HP: ${this.hp}/${this.maxHP}  ${t.rage}: ${u}%`, 256, 85); ctx.fillStyle = '#1a1a1a'; ctx.fillRect(80, 110, 352, 20); ctx.fillStyle = '#2ecc71'; ctx.fillRect(80, 110, 352 * (this.hp/this.maxHP), 20); ctx.fillStyle = '#1a1a1a'; ctx.fillRect(80, 145, 352, 15); ctx.fillStyle = (r.red > r.blue) ? '#ff5555' : (r.blue > r.red ? '#55ccff' : '#ffaa00'); ctx.fillRect(80, 145, 352 * (u/100), 15); this.uiTexture.needsUpdate = true; }
        face(pos) { if (!this.alive) return; const lp = pos.clone(); lp.y = this.group.position.y; const dummy = new THREE.Object3D(); dummy.position.copy(this.group.position); dummy.lookAt(lp); this.targetQuaternion = dummy.quaternion.clone(); }
        takeDamage(amt, type = 0, sourcePos = null) { this.hp = Math.max(0, this.hp - Math.floor(amt)); SoundEngine.play('hit'); const pColor = (type === 0) ? 0xffaa00 : (type === 1 ? 0x00ffff : 0xff0044); for(let i=0; i<15; i++) activeParticles.push(new HitParticle(this.group.position.clone().add(new THREE.Vector3(0, 10, 0)), pColor)); if (sourcePos) applyKnockback(this, sourcePos); if (this.hp <= 0 && this.alive) { this.alive = false; this.modelContainer.visible = false; this.meatBlock.visible = true; } this.updateLabel(); updateHPUI(); }
    }

    function calcDamage(a, t, type, isSuper = false, skipFatigue = false) { 
        if (!t || !t.alive) return; 
        const txt = TRANSLATIONS[currentLang]; 
        let dmg = (a.type === 'Loki') ? (type === 0 ? (isSuper ? 70 : 45) : (isSuper ? t.maxHP*0.5 : 65)) : (type === 0 ? (isSuper ? 60 : 40) : (isSuper ? t.maxHP*0.5 : 50)); 
        if (isSuper) createExplosion(t.group.position.clone().add(new THREE.Vector3(0, 15, 0)), 2.5); 
        else { 
            if (type === 0 && t.action.card === 2) { 
                if (t.type === 'Loki') return; 
                loseRage(a, true); let counterDmg = 65; a.takeDamage(counterDmg, 0, t.group.position); 
                spawnDamageNumber(a, counterDmg); showMove(`[${t.getDisplayName()}] åæ“Šï¼ -> ${a.getDisplayName()} ${counterDmg} Dmg!`);
                if (t.type === 'Odin') gainRage(t, true, 20); return; 
            } 
            if (type === 1 && t.action.card === 3) { 
                loseRage(a, false); let reflectDmg = Math.floor(dmg*0.8); a.takeDamage(reflectDmg, 2, t.group.position); 
                spawnDamageNumber(a, reflectDmg); showMove(`[${t.getDisplayName()}] åå°„ï¼ -> ${a.getDisplayName()} ${reflectDmg} Dmg!`);
                gainRage(t, false, 20); return; 
            } 
        } 
        if (t.action.card === 4) { 
            if (!skipFatigue) { 
                t.defendHitCount++; let fatigueAdd = 0; 
                if (t.defendHitCount === 2) fatigueAdd = 20; else if (t.defendHitCount > 2) fatigueAdd = 10; 
                if (isSuper) fatigueAdd += 15; if (fatigueAdd > 0) t.fatigue = Math.min(150, t.fatigue + fatigueAdd); 
            } 
            t.blockedInTurn = true; SoundEngine.play('ding'); spawnDamageNumber(t, txt.logBlock); 
            showMove(`[${t.getDisplayName()}] ${txt.logBlock}!`); updateHPUI(); return; 
        } 
        loseRage(t, type === 0); t.takeDamage(dmg, type, a.group.position); spawnDamageNumber(t, dmg);
        let skillName = isSuper ? "å¥§ç¾©" : (type === 0 ? "ç‰©ç†æ”»æ“Š" : "é­”æ³•æ”»æ“Š");
        showMove(`${a.getDisplayName()} å° ${t.getDisplayName()} ä½¿ç”¨ ${skillName}, é€ æˆ ${dmg} å‚·å®³!`);
        if (!isSuper) gainRage(a, type === 0, 35); 
    }

    async function resolveActions() { 
        const pMap = { 4: 0, 3: 0, 5: 1, 0: 2, 1: 2, 2: 3 }; 
        const q = players.filter(p => p && p.alive).sort((a, b) => (pMap[a.action.card]??5) - (pMap[b.action.card]??5)); 
        let localDemoId = currentDemoId; 
        if (!isTutorialMode) { showMove(TRANSLATIONS[currentLang].lockingTargets); await sleep(1200); hideMove(); await sleep(300); }
        for (let p of q) { 
            if (localDemoId !== currentDemoId) return; if (!p || !p.alive) continue; 
            const t = players.find(x => x && x.id === p.action.target);
            const cid = p.action.card; 
            let skillText = ""; let targetName = t ? t.getDisplayName() : "";
            if (cid === 4) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[4]}!`;
            else if (cid === 3) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[3]}!`;
            else if (cid === 2) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[2]}!`;
            else if (cid === 5) {
                const isR = (p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99);
                skillText = isR ? `[${p.getDisplayName()}] ${TRANSLATIONS[currentLang].tutCardNames[5]} @ ${targetName}!` : `[${p.getDisplayName()}] ${TRANSLATIONS[currentLang].tutCardNames[6]}!`;
            }
            else if (cid >= 0) skillText = `[${p.getDisplayName()}] ${CARD_NAMES[cid]} @ ${targetName}!`;
            if (cid === 4 || cid === 2 || cid === 3) { showMove(skillText); SoundEngine.play('click'); await sleep(1000); } 
            else if (cid >= 0) await cinematicIntro(p, skillText);
            if (localDemoId !== currentDemoId) return; 
            if (!t || !t.alive) { 
                if (cid >= 0 && cid !== 4 && cid !== 2 && cid !== 3 && cid !== 5) { showMove("ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ"); await sleep(1000); hideMove(); }
                const isMagicUlt = (cid === 5 && !((p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99)));
                if (cid !== 4 && cid !== 2 && cid !== 3 && !isMagicUlt) { updateHPUI(); await sleep(300); resetCamera(); continue; }
            } 
            if (cid === 4) { p.fatigue = Math.min(150, p.fatigue + 75); updateHPUI(); } 
            if (p.id === t.id) {
                let nearest = null; let minDst = 99999;
                players.forEach(o => { if (o.id !== p.id && o.alive) { const d = p.group.position.distanceTo(o.group.position); if (d < minDst) { minDst = d; nearest = o; } } });
                if (nearest) p.face(nearest.group.position); else p.face(new THREE.Vector3(0, 50, 0));
            } else { if (t && t.alive && cid !== 3) t.face(p.group.position); }
            if (cid === 4) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 2) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 3) { 
                p.hexShield.visible = true; SoundEngine.play('counter'); 
                const anyEnemy = players.find(x => x.id !== p.id && x.alive);
                if(anyEnemy) p.face(anyEnemy.group.position); else p.face(new THREE.Vector3(0,0,0));
                await focusOnAction(p, null, 400); await sleep(400); 
            } 
            else if (cid === 5) { 
                const isR = (p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99); 
                if (isR) { if (t?.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); await performPhysicalSuper(p, t); } } 
                else { p.face(new THREE.Vector3(0,0,0)); await performLightningStorm(p); }
                p.rage.red = 0; p.rage.blue = 0; if (p.id === 0) { playerRage.red = 0; playerRage.blue = 0; }
                updateHPUI(); 
            } 
            else if (cid >= 0 && cid < 2) { if (t && t.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); } await performAttack(p, t, cid); } 
            if (localDemoId !== currentDemoId) return; 
            hideMove(); updateHPUI(); await sleep(300); resetCamera(); await sleep(1500); 
        } 
        if (isTutorialMode) { 
            if (localDemoId === currentDemoId) { 
                gameState = 'TUTORIAL_IDLE'; document.getElementById('tutorial-desc').innerText = TRANSLATIONS[currentLang].tutEnd; 
                players.forEach(p => { p.hp = p.maxHP; p.fatigue = 0; p.showBrokenShield = false; p.updateLabel(); }); 
                document.querySelectorAll('.tutorial-controls .card').forEach(c => { c.classList.remove('disabled-tut', 'demoing'); c.innerText = c.getAttribute('data-original-text') || c.innerText; });
                if (players[0]) { players[0].rage.red = 0; players[0].rage.blue = 0; }
                playerRage.red = 0; playerRage.blue = 0; updateHPUI(); 
            } 
        } else { 
            const survivors = players.filter(p => p.alive);
            if (survivors.length <= 1) {
                let winner = survivors.length > 0 ? survivors[0] : null; const t = TRANSLATIONS[currentLang];
                if (winner) { matchScores[winner.id] = (matchScores[winner.id] || 0) + 1; players.forEach(p => p.refreshLabel()); }
                if (winner && matchScores[winner.id] >= targetWins) {
                    showMsg(`${t.finalVictory}<br>${winner.getDisplayName()}`, true);
                    if (isMultiplayer && Online.isHost) Network.broadcast({ type: 'GAME_OVER', msg: t.finalVictory, isFinal: true, winnerName: winner.getDisplayName(), scores: matchScores });
                } else {
                    const wName = winner ? winner.getDisplayName() : "Draw";
                    if (isMultiplayer && Online.isHost) {
                        Network.broadcast({ type: 'GAME_OVER', isFinal: false, autoRestart: true, winnerName: wName, scores: matchScores });
                        setTimeout(() => { if(gameState !== 'IDLE') Network.hostStartGame(); }, 5000);
                    } else if (!isMultiplayer) { startRoundTransition(wName); setTimeout(() => window.restartRound(), 5000); }
                }
            } else if (Online.isHost || !isMultiplayer) startTurn();
        } 
    }
    
    function endTurn() { 
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer);
        gameState = 'ANIMATING'; document.getElementById('turn-hint').style.display = 'none';
        let myP = players[myPlayerIndex];
        if (myP.action.card === -1) myP.action = { card: (myP.fatigue >= 100 ? 0 : 4), target: getRandomTarget(myP.id), selectionTime: Date.now() };
        players.forEach((p, i) => {
            if (!p.alive) return;
            if (isMultiplayer) { if (Online.playerMap[i] && (Online.playerMap[i].isCpu || i === myPlayerIndex)) {} else if (p.action.card === -1) p.action = { card: (p.fatigue >= 100 ? 0 : 4), target: getRandomTarget(p.id), selectionTime: Date.now() }; }
            if (!isMultiplayer || (Online.playerMap[i] && Online.playerMap[i].isCpu)) { if (i !== myPlayerIndex) { if (p.action.card === -1) p.action = { card: 0, target: getRandomTarget(p.id), selectionTime: Date.now() }; if (players[p.action.target]) p.face(players[p.action.target].group.position); } }
        });
        if (isMultiplayer && Online.isHost) Network.broadcast({ type: 'TURN_RESOLVE', actions: players.map(p => p.action) });
        resolveActions(); 
    }
    
    function cpuThink() {
        if (gameState !== 'WAITING' || timeLeft < (TURN_TIME - 6)) return;
        players.forEach((p, idx) => {
            if (!p.alive) return;
            if ((isMultiplayer && Online.playerMap[idx] && Online.playerMap[idx].isCpu) || (!isMultiplayer && idx !== 0)) {
                 const threats = players.filter(enemy => enemy.alive && enemy.id !== idx && enemy.action.target === idx);
                 let chosenTargetId = p.action.target;
                 const fatiguedTargets = players.filter(o => o.id !== idx && o.alive && o.fatigue >= 100);
                 if (chosenTargetId === -1 || Math.random() < 0.4 || threats.length > 0) {
                     if (fatiguedTargets.length > 0 && Math.random() < 0.85) chosenTargetId = fatiguedTargets[Math.floor(Math.random() * fatiguedTargets.length)].id;
                     else if (threats.length > 0 && Math.random() < 0.7) chosenTargetId = threats[Math.floor(Math.random() * threats.length)].id;
                     else { const validTargets = players.filter(o => o.id !== idx && o.alive); if (validTargets.length > 0) chosenTargetId = validTargets[Math.floor(Math.random() * validTargets.length)].id; }
                 }
                 if (chosenTargetId !== -1) { p.action.target = chosenTargetId; if (players[chosenTargetId]) p.face(players[chosenTargetId].group.position); }
                 if (p.action.card === -1 || Math.random() < 0.3) {
                    const r = p.rage; const maxRage = Math.max(r.red, r.blue); let choice = 0;
                    if (maxRage >= 99 && Math.random() < 0.9) choice = 5;
                    else { const isRed = r.red >= r.blue; const hasRage = maxRage > 20; if (hasRage) { const roll = Math.random(); if (isRed) choice = roll < 0.6 ? 0 : (roll < 0.9 ? 2 : 4); else choice = roll < 0.6 ? 1 : (roll < 0.9 ? 3 : 4); } else { const roll = Math.random(); choice = roll < 0.4 ? 0 : (roll < 0.8 ? 1 : 4); } }
                    if (choice === 4 && p.fatigue >= 100) choice = (r.red >= r.blue) ? 0 : 1;
                    p.action.card = choice;
                 }
            }
        });
    }

    function startTurn() {
        if (gameState === 'ENDED') return; if (isMultiplayer && Online.isHost) Network.broadcast({ type: 'TURN_START' });
        gameState = 'WAITING'; timeLeft = TURN_TIME; selectedSlot = -1; selectedTargetId = -1;
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected', 'disabled')); hideMove();
        const tEl = document.getElementById('timer'); if (tEl) { tEl.innerText = timeLeft; tEl.style.display = "block"; }
        document.getElementById('turn-hint').style.display = 'block';
        players.forEach((p, i) => { p.fatigue = Math.max(0, p.fatigue - 35); p.showBrokenShield = p.fatigue >= 100; p.defendHitCount = 0; p.blockedInTurn = false; p.action = { card: -1, target: -1 }; p.updateLabel(); });
        resetCamera(); updateHPUI(); 
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer); 
        if (!isMultiplayer || Online.isHost) cpuThinkTimer = setInterval(cpuThink, 800); 
        timerInterval = setInterval(() => { timeLeft--; if (tEl) tEl.innerText = timeLeft; if (timeLeft <= 0) { if(tEl) tEl.style.display = "none"; if (!isMultiplayer || Online.isHost) endTurn(); } }, 1000);
    }

    window.selectCard = function(i) { 
        if (gameState !== 'WAITING') return; const p = players[myPlayerIndex]; if (!p || !p.alive) return;
        selectedSlot = i; document.querySelectorAll('.card').forEach((c, idx) => c.classList.toggle('selected', idx === i)); SoundEngine.play('click'); 
        showCardDescription(i); p.action.card = i;
        const isMagicUlt = (i === 5 && !((p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99)));
        if (i === 2 || i === 3 || i === 4 || isMagicUlt) { p.action.target = myPlayerIndex; if (isMultiplayer && !Online.isHost) Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action }); }
        if (i !== 2 && i !== 3 && i !== 4 && !isMagicUlt && isMultiplayer && !Online.isHost) Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
    };

    function handleInt(x, y) { 
        if (gameState !== 'WAITING' || selectedSlot === -1) return; const p = players[myPlayerIndex]; if (!p || !p.alive) return;
        const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((x - rect.left) / rect.width) * 2 - 1; mouse.y = -((y - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); 
        const chars = players.filter(pl => pl && pl.id !== myPlayerIndex && pl.alive).map(pl => pl.group); const intersects = raycaster.intersectObjects(chars, true); 
        if (intersects.length > 0) { 
            let o = intersects[0].object; while(o && !o.userData.isCharacter) o = o.parent; 
            if (o && o.userData.playerId !== myPlayerIndex) { 
                selectedTargetId = o.userData.playerId; p.action.target = selectedTargetId; p.face(players[selectedTargetId].group.position); 
                SoundEngine.init(); SoundEngine.play('click'); updateHPUI(); 
                if (isMultiplayer && !Online.isHost) Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
            } 
        } 
    }

    window.startBattle = function(customConfigs = null) { document.getElementById('game-msg').style.display = 'none'; hideMove(); UI.show('game-ui'); initBattle(customConfigs); };

    function spawnPlayers(customConfigs) { 
        let configs = customConfigs;
        if (!configs) {
            configs = [
                { id: 0, x: 0, y: 50, z: 140, name: (selectedPlayerType === 'Loki' ? "æ´›åŸº" : "å¥§ä¸"), type: selectedPlayerType },
                { id: 1, x: 0, y: 50, z: -140, name: "æ´›åŸº", type: 'Loki' },
                { id: 2, x: 140, y: 50, z: 0, name: "å¥§ä¸A", type: 'Odin' },
                { id: 3, x: -140, y: 50, z: 0, name: "å¥§ä¸B", type: 'Odin' }
            ];
            myPlayerIndex = 0; isMultiplayer = false; if (gameState === 'IDLE' || Object.keys(matchScores).length === 0) { matchScores = {}; configs.forEach(p => matchScores[p.id] = 0); }
        }
        players = configs.map(cfg => new Odin(cfg)); updateText(); updateHPUI();
    }
    
    function initWorld() { scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 200, 2500); scene.add(new THREE.AmbientLight(0xffffff, 0.5)); const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(200, 400, 100); sun.castShadow = true; sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048; scene.add(sun); const arena = new THREE.Mesh(new THREE.BoxGeometry(375, 15, 375), new THREE.MeshPhongMaterial({ color: 0x88bb88 })); arena.position.y = -15; arena.receiveShadow = true; scene.add(arena); for(let i=0; i<12; i++) { const h = 700 + Math.random()*400; const m = new THREE.Mesh(new THREE.BoxGeometry(300, h, 300), new THREE.MeshPhongMaterial({ color: 0xcc99aa })); const a = (i/12)*Math.PI*2; m.position.set(Math.cos(a)*1200, h/2 - 1200, Math.sin(a)*1200); scene.add(m); const cap = new THREE.Mesh(new THREE.BoxGeometry(305, 70, 305), new THREE.MeshPhongMaterial({ color: 0xffffff })); cap.position.set(m.position.x, m.position.y + h/2, m.position.z); scene.add(cap); } }
    
    function initBattle(customConfigs) { 
        const v = document.getElementById('viewport'); const oldCanvas = v.querySelector('canvas'); if (oldCanvas) v.removeChild(oldCanvas); 
        scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000); // FIXED: 45 -> 55 FOV
        renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.setPixelRatio(window.devicePixelRatio); v.appendChild(renderer.domElement); 
        raycaster = new THREE.Raycaster(); clock = new THREE.Clock(); initWorld(); spawnPlayers(customConfigs); adjustCameraForResponsive(true); animate(); 
        window.addEventListener('resize', () => { if(camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); adjustCameraForResponsive(); } }); 
        window.addEventListener('mousedown', (e) => { SoundEngine.init(); handleInt(e.clientX, e.clientY); }); 
        window.addEventListener('touchstart', (e) => { SoundEngine.init(); if(e.touches[0]) handleInt(e.touches[0].clientX, e.touches[0].clientY); }); 
        if (isTutorialMode) { gameState = 'TUTORIAL_IDLE'; UI.show('tutorial-ui'); } 
        else { if (!isMultiplayer || Online.isHost) startTurn(); else document.getElementById('turn-hint').innerText = TRANSLATIONS[currentLang].waitingOthers; } 
    }
    
    function animate() { 
        animationId = requestAnimationFrame(animate); const dt = clock.getDelta(); 
        for(let i=activeLightnings.length-1; i>=0; i--) if(!activeLightnings[i].update()) activeLightnings.splice(i,1); 
        for(let i=activeParticles.length-1; i>=0; i--) if(!activeParticles[i].update(dt)) activeParticles.splice(i,1); 
        for(let i=activeProjectiles.length-1; i>=0; i--) if(!activeProjectiles[i].update(dt)) activeProjectiles.splice(i,1); 
        if (renderer && scene && camera) { players.forEach(p => { if(p && p.alive) { p.group.position.y = 50 + Math.sin(Date.now()*0.003 + p.id)*4; p.uiSprite.quaternion.copy(camera.quaternion); if (p.targetQuaternion) p.group.quaternion.slerp(p.targetQuaternion, 5 * dt); if(p.hexShield && p.hexShield.visible) p.hexShield.rotation.z += 0.05; if(p.type === 'Loki' && p.ball) { p.ball.rotation.y += 0.05 * p.ballRotationMultiplier; p.ball.rotation.x += 0.02 * p.ballRotationMultiplier; } const r = p.rage, maxRage = Math.max(r.red, r.blue); if (maxRage >= 99) { if (!p.aura.active || p.aura.isRed !== (r.red >= r.blue)) p.aura.activate(r.red >= r.blue); } else if (p.aura.active) p.aura.deactivate(); p.aura.update(dt); if (p.brokenShieldIcon && p.brokenShieldIcon.visible) { const s = 8 + Math.sin(Date.now() * 0.005) * 1.5; p.brokenShieldIcon.scale.set(s, s, 1); p.brokenShieldIcon.material.opacity = 0.6 + Math.sin(Date.now() * 0.005) * 0.2; } if (p.id === selectedTargetId && p.id !== myPlayerIndex && p.selectionRing && p.targetLabel) { const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1; p.selectionRing.scale.set(pulse, pulse, 1); p.targetLabel.visible = true; } else if (p.targetLabel) p.targetLabel.visible = false; } }); renderer.render(scene, camera); } 
    }

    window.startTutorialSelection = function() { SoundEngine.init(); isTutorialSelection = true; UI.show('char-select'); updateText(); };
    window.pickChar = function(t) { selectedPlayerType = t; document.getElementById('select-odin').className = (t === 'Odin' ? 'char-card active' : 'char-card'); document.getElementById('select-loki').className = (t === 'Loki' ? 'char-card active' : 'char-card'); SoundEngine.play('click'); };
    window.confirmSelection = function() { if (isTutorialSelection) window.startTutorial(); else window.startBattle(); };
    window.startTutorial = function() { SoundEngine.init(); isTutorialMode = true; initBattle(); };
    window.quitTutorial = function() { SoundEngine.play('click'); isTutorialMode = false; window.resetGame(); };
    window.demoAction = async function(cardIndex) { 
        if (gameState === 'ANIMATING') return; if (!players || players.length < 2) return; 
        SoundEngine.init(); gameState = 'ANIMATING'; currentDemoId++; 
        const cards = document.querySelectorAll('.tutorial-controls .card');
        cards.forEach((c, idx) => { if(idx === cardIndex) { c.classList.add('demoing'); c.setAttribute('data-original-text', c.innerText); c.innerText = "Demo..."; } else c.classList.add('disabled-tut'); });
        const p0 = players[0], p1 = players[1]; 
        p0.action = { card: (cardIndex === 6 ? 5 : cardIndex), target: 1, selectionTime: Date.now() }; 
        p1.action = { card: 0, target: 0, selectionTime: Date.now() }; 
        if (cardIndex === 5) p0.rage.red = 100; else if (cardIndex === 6) p0.rage.blue = 100;
        if (p0.id === 0) { playerRage.red = p0.rage.red; playerRage.blue = p0.rage.blue; }
        updateHPUI(); updateText(); 
        const t = TRANSLATIONS[currentLang]; 
        switch(cardIndex) { case 0: document.getElementById('tutorial-desc').innerText = (p0.type==='Loki'?t.tut0_loki:t.tut0_odin); p1.action.card = -1; break; case 1: document.getElementById('tutorial-desc').innerText = (p0.type==='Loki'?t.tut1_loki:t.tut1_odin); p1.action.card = -1; break; case 2: document.getElementById('tutorial-desc').innerText = (p0.type==='Loki'?t.tut2_loki:t.tut2_odin); p1.action.card = 0; break; case 3: document.getElementById('tutorial-desc').innerText = (p0.type==='Loki'?t.tut3_loki:t.tut3_odin); p1.action.card = 1; break; case 4: document.getElementById('tutorial-desc').innerText = t.tut4; p1.action.card = 0; break; case 5: document.getElementById('tutorial-desc').innerText = (p0.type==='Loki'?t.tut5_loki:t.tut5_odin); p1.action.card = -1; break; case 6: document.getElementById('tutorial-desc').innerText = (p0.type==='Loki'?t.tut6_loki:t.tut6_odin); p1.action.card = -1; break; } 
        await resolveActions(); 
        if(isTutorialMode && currentDemoId === currentDemoId) { 
            gameState = 'TUTORIAL_IDLE'; document.getElementById('tutorial-desc').innerText = t.tutEnd; 
            players.forEach(p => { p.hp = p.maxHP; p.fatigue = 0; p.showBrokenShield = false; p.updateLabel(); }); 
            cards.forEach(c => { c.classList.remove('disabled-tut', 'demoing'); c.innerText = c.getAttribute('data-original-text') || c.innerText; });
            p0.rage.red = 0; p0.rage.blue = 0; playerRage.red = 0; playerRage.blue = 0; updateHPUI(); 
        } 
    };
    
    window.resetGame = function() { 
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer); if (animationId) cancelAnimationFrame(animationId); 
        document.getElementById('game-msg').style.display = 'none'; document.getElementById('turn-hint').style.display = 'none'; 
        currentDemoId++; players.length = 0; playerRage = { red: 0, blue: 0 }; gameState = 'IDLE'; matchScores = {}; 
        document.getElementById('scoreboard').style.display = 'none'; UI.showMenu();
        if(Online.peer) Online.peer.destroy(); Online.peer = null; Online.playerMap = []; Online.connections = []; Online.hostConn = null;
    };
    
    window.askOracle = async function() { 
        SoundEngine.init(); const btn = document.getElementById('oracle-btn-card'); if (gameState !== 'WAITING' || btn.classList.contains('loading')) return; 
        btn.classList.add('loading'); const p = players[myPlayerIndex]; 
        try { const r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, { method: 'POST', body: JSON.stringify({ contents: [{ parts: [{ text: `Stats: HP:${p.hp}/500` }] }], systemInstruction: { parts: [{ text: "è±¬è±¬å…ˆçŸ¥ï¼Œçµ¦ç°¡çŸ­å»ºè­°ã€‚" }] } }) }); const res = await r.json(); const txt = res.candidates?.[0]?.content?.parts?.[0]?.text; if (txt) showMove(`âœ¨è±¬è±¬å…ˆçŸ¥: ${txt.trim()}`); } catch(e){} 
        btn.classList.remove('loading'); 
    };

    function showMsg(t, isFinal = false) { 
        const el = document.getElementById('game-msg'); const btnText = isFinal ? TRANSLATIONS[currentLang].finalMenu : TRANSLATIONS[currentLang].restart; const btnAction = isFinal ? "window.resetGame()" : "window.restartRound()";
        let btnHtml = `<button class="btn-gold" style="margin-top:10px;" onclick="${btnAction}">${btnText}</button>`;
        if (isMultiplayer && !Online.isHost && !isFinal) btnHtml = `<div style="font-size:0.9rem; color:#aaa; margin-top:10px;">${TRANSLATIONS[currentLang].waitingHost}</div>`;
        el.innerHTML = `<span>${t}</span><br>${btnHtml}`; el.style.display = 'flex'; 
    }

    function startRoundTransition(winnerName) {
        const timerEl = document.getElementById('timer'); if (timerEl) timerEl.style.display = 'none';
        const t = TRANSLATIONS[currentLang]; showMove(`${t.roundWinner} ${winnerName}`);
        setTimeout(() => { showMove(t.nextRoundIn); }, 2000);
    }

    window.restartRound = function() {
        if (isMultiplayer && !Online.isHost) return;
        if (timerInterval) clearInterval(timerInterval); if (cpuThinkTimer) clearInterval(cpuThinkTimer);
        document.getElementById('game-msg').style.display = 'none'; hideMove();
        if (scene) { while(scene.children.length > 0){ const o = scene.children[0]; if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose(); scene.remove(o); } }
        players.length = 0; activeLightnings.length = 0; activeParticles.length = 0; activeProjectiles.length = 0; playerRage = { red: 0, blue: 0 }; 
        if (isMultiplayer && Online.isHost) Network.hostStartGame(); else window.startBattle(); 
    };
</script>
</body>
</html>