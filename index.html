<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è±¬ç¥é»ƒæ˜ Pignarok Arena (Ver 22.4)</title>
    <!-- å¼•å…¥ PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- åŸºç¤è¨­å®š --- */
        :root {
            --ui-max-width: 500px;
            --primary-gold: #ff99cc;
            --bg-overlay: rgba(0, 0, 0, 0.4);
            --accent-blue: #55ccff;
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            font-family: 'Cinzel', serif, "Microsoft JhengHei", "Helvetica Neue", sans-serif;
            background: #000; color: white;
            touch-action: none; width: 100vw; height: 100vh;
            -webkit-user-select: none; user-select: none;
        }
        
        #viewport {
            position: relative; width: 100%; height: 100%;
            background: #87CEEB; overflow: hidden;
        }

        #viewport canvas { display: block; width: 100% !important; height: 100% !important; outline: none; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle, rgba(40, 20, 80, 0.95) 0%, rgba(10, 5, 20, 1) 100%);
            z-index: 2000; transition: opacity 0.5s ease; padding: 20px; box-sizing: border-box;
            opacity: 0; pointer-events: none; /* é è¨­éš±è— */
        }
        
        .overlay-screen.active {
            opacity: 1; pointer-events: auto;
        }

        /* ä¸»ç•«é¢èƒŒæ™¯è±¬ (Menu Hero Pig) */
        .menu-bg-pig {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 450px;
            opacity: 0.3; /* èƒŒæ™¯åœ–é€æ˜åº¦ */
            z-index: -1;
            pointer-events: none;
            /* ç§»é™¤ä¹‹å‰çš„å¼·åˆ¶æ¿¾é¡ï¼Œé æœŸä½¿ç”¨è€…æœƒä¸Šå‚³å»èƒŒåœ–æˆ–é»‘åº•åœ– */
            object-fit: contain;
        }

        h1 { 
            font-size: clamp(2.5rem, 8vw, 4.5rem); margin-bottom: 5px; color: var(--primary-gold); 
            text-shadow: 0 0 20px rgba(255, 153, 204, 0.6); letter-spacing: 5px; text-align: center; 
            z-index: 2;
        }
        .sub-title { font-size: 1.2rem; color: #fff; margin-bottom: 5px; letter-spacing: 2px; opacity: 0.8; z-index: 2; }
        
        .version-text {
            font-size: 0.8rem;
            color: #d4af37; /* é‡‘è‰² */
            margin-bottom: 30px;
            letter-spacing: 1px;
            opacity: 0.9;
            font-family: monospace;
            z-index: 2;
        }

        .studio-footer {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            font-size: 0.75rem;
            color: #666;
            font-family: 'Cinzel', serif;
            letter-spacing: 3px;
            opacity: 0.7;
        }

        h2 { font-size: 1.4rem; color: #fff; margin-bottom: 20px; border-bottom: 2px solid var(--primary-gold); padding-bottom: 8px; }

        /* è¼¸å…¥æ¡†æ¨£å¼ */
        input.input-box, select.input-box {
            background: rgba(255, 255, 255, 0.1); border: 2px solid var(--primary-gold);
            color: white; padding: 12px; font-size: 1.2rem; margin: 10px 0;
            border-radius: 8px; text-align: center; width: 80%; max-width: 300px;
            font-family: inherit; outline: none;
        }
        select.input-box option { background: #333; color: white; }
        input.input-box::placeholder { color: #aaa; }

        /* æˆ¿é–“è™Ÿç¢¼é¡¯ç¤º */
        .room-code-display {
            font-size: 3rem; color: var(--accent-blue); letter-spacing: 10px;
            margin: 20px 0; padding: 15px 40px; border: 3px dashed rgba(255, 255, 255, 0.3);
            background: rgba(0,0,0,0.3); border-radius: 10px;
        }

        .player-list {
            list-style: none; padding: 0; width: 100%; max-width: 400px; margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden;
        }
        .player-list li {
            background: rgba(255,255,255,0.05); padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
        }
        .tag-host { color: #f1c40f; font-size: 0.8rem; border: 1px solid #f1c40f; padding: 2px 6px; border-radius: 4px; }
        .tag-me { color: #2ecc71; font-size: 0.8rem; }

        /* å‘¼å¸ç‡ˆæ–‡å­—æ•ˆæœ */
        @keyframes breathe {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }
        .breathing-text {
            animation: breathe 2.5s infinite ease-in-out;
            color: #88ccff;
            font-size: 0.9rem;
            margin-top: 10px;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 1px;
        }

        /* è¿·ä½ è§’è‰²é¸æ“‡å™¨ */
        .mini-char-select {
            display: flex; gap: 10px; margin: 15px 0; width: 80%; max-width: 300px;
        }
        .mini-card {
            flex: 1; padding: 10px; border: 1px solid #888; border-radius: 8px;
            cursor: pointer; transition: 0.2s; background: rgba(0,0,0,0.3);
            display: flex; flex-direction: column; align-items: center; opacity: 0.6;
        }
        .mini-card.active {
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2);
            opacity: 1; transform: scale(1.05);
        }
        .mini-icon { font-size: 1.5rem; margin-bottom: 5px; }

        #turn-hint {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 1rem; font-weight: bold; text-shadow: 0 0 10px #000;
            background: var(--bg-overlay); padding: 5px 15px; border-radius: 20px;
            display: none; z-index: 50; pointer-events: none;
            white-space: nowrap; border: 1px solid rgba(255, 255, 255, 0.2);
        }
        @media (min-width: 768px) { #turn-hint { top: 100px; font-size: 1.2rem; } }

        @keyframes hint-flash { 0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); } 50% { opacity: 0.3; transform: translateX(-50%) scale(0.95); } }
        .flashing { animation: hint-flash 1s infinite ease-in-out; }

        .btn-gold {
            padding: 12px 30px; font-size: 1.1rem; background: rgba(255, 153, 204, 0.2);
            border: 2px solid var(--primary-gold); color: var(--primary-gold); cursor: pointer; border-radius: 50px;
            transition: all 0.3s; font-family: 'Cinzel', serif; text-transform: uppercase;
            max-width: 300px; width: 100%; margin-bottom: 15px;
            z-index: 5;
        }
        .btn-gold:hover { background: var(--primary-gold); color: #1a0d0d; transform: scale(1.05); }
        .btn-gold:disabled { border-color: #555; color: #888; background: transparent; cursor: not-allowed; transform: none; }

        .btn-back { border-color: #aaa; color: #ccc; font-size: 0.9rem; padding: 8px 20px; margin-top: 10px; width: auto; }

        .lang-container {
            display: flex; gap: 15px; margin-bottom: 30px;
            z-index: 5;
        }
        .btn-lang {
            padding: 8px 20px; font-size: 0.9rem; background: transparent;
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            transition: all 0.3s;
        }
        .btn-lang.active { background: var(--primary-gold); color: #000; border-color: var(--primary-gold); }
        .btn-lang:hover { transform: scale(1.1); }

        .selection-container { 
            display: flex; gap: 15px; margin-bottom: 30px; width: 100%; max-width: 600px;
            flex-direction: row; 
        }
        @media (max-width: 350px) { .selection-container { flex-direction: column; } }

        .char-card {
            flex: 1; background: rgba(255,255,255,0.05); border: 2px solid transparent;
            border-radius: 12px; padding: 15px; cursor: pointer; transition: 0.3s;
            display: flex; flex-direction: column; align-items: center; text-align: center;
        }
        .char-card.active { border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.2); transform: translateY(-5px); }
        .char-portrait-icon { font-size: 3rem; margin-bottom: 5px; }

        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        
        #top-announcer {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            width: 100%; max-width: var(--ui-max-width);
            text-align: center; pointer-events: none; z-index: 100;
        }
        #timer { color: #fff; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1); }
        #move-display {
            color: var(--primary-gold); font-size: clamp(1rem, 3.5vw, 1.3rem); font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,1);
            margin-top: 5px; opacity: 0; transition: opacity 0.3s;
            background: rgba(0,0,0,0.8); padding: 12px 30px; border-radius: 50px;
            display: inline-block; border: 3px solid var(--primary-gold);
            white-space: normal; width: auto;
        }

        #status-log {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: var(--ui-max-width); height: 42px; background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 153, 204, 0.4); border-radius: 8px; padding: 5px; font-size: 0.8rem; overflow-y: auto;
            pointer-events: auto; color: #eee; backdrop-filter: blur(3px); z-index: 30; text-align: left;
        }
        
        #card-description {
            position: absolute; bottom: 160px; /* Moved up 45px from 115px */
            left: 0; width: 100%;
            text-align: center; color: #ffeb3b; font-size: 0.85rem; font-weight: bold;
            text-shadow: 0 0 5px #000; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            background: linear-gradient(to right, transparent, rgba(0,0,0,0.7), transparent);
            padding: 5px 0; z-index: 25;
        }

        #bottom-ui-container {
            position: absolute; bottom: 30px; /* Moved up 30px from 0 */
            left: 0; width: 100%;
            display: flex; justify-content: center;
            padding: 10px 0 20px 0; 
            background: linear-gradient(to top, rgba(0,0,0,1) 30%, rgba(0,0,0,0.6) 80%, transparent);
            pointer-events: auto; z-index: 20;
        }

        #card-area { 
            display: flex; flex-direction: row; gap: 3px; 
            width: 98%; max-width: var(--ui-max-width); 
            justify-content: space-evenly; align-items: flex-end; 
        }

        #player-hp-card {
            flex: 1.2; height: 95px; min-width: 50px;
            background: rgba(80, 0, 40, 0.7); border: 1.5px solid var(--primary-gold); border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 4px 2px; color: #fff; backdrop-filter: blur(10px);
            font-size: 0.58rem; font-weight: bold; line-height: 1.3; text-align: center; box-sizing: border-box;
        }

        .name-text { font-size: 0.62rem; color: var(--primary-gold); margin-bottom: 2px; width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .hp-text { font-size: 0.58rem; color: #ffccdd; }
        .fatigue-text { color: #ffaa00; font-size: 0.52rem; }
        .rage-text { font-size: 0.52rem; color: #ff8888; }

        .card {
            flex: 1; height: 95px; min-width: 40px; 
            background: rgba(255, 255, 255, 0.1); border: 1.2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; cursor: pointer; transition: 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; color: #fff; font-weight: bold; backdrop-filter: blur(5px); 
            font-size: 0.55rem; 
            padding: 2px; box-sizing: border-box; user-select: none;
        }
        .card:active { transform: scale(0.92); }
        .card.selected { 
            border-color: var(--primary-gold); background: rgba(255, 153, 204, 0.3); 
            transform: scale(1.15) translateY(-10px); box-shadow: 0 0 20px rgba(255, 153, 204, 0.6); z-index: 100;
        }
        .card.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .card.disabled-tut { opacity: 0.3; pointer-events: none; filter: grayscale(1); border-color: #555; }
        .card.demoing { border-color: #55ccff; background: rgba(0, 100, 200, 0.4); transform: scale(1.05); }

        .card:hover { background: rgba(255, 255, 255, 0.2); }

        @keyframes card-breathing-red { 0%, 100% { box-shadow: 0 0 5px #ff5555; } 50% { box-shadow: 0 0 20px #ff0000; } }
        @keyframes card-breathing-blue { 0%, 100% { box-shadow: 0 0 5px #55ccff; } 50% { box-shadow: 0 0 20px #0088ff; } }
        
        .card.super { color: #000; border-color: #fff; font-weight: 800; }
        .card.super-red { animation: card-breathing-red 1.5s infinite; background: linear-gradient(135deg, #ff9999, #fff); }
        .card.super-blue { animation: card-breathing-blue 1.5s infinite; background: linear-gradient(135deg, #99ccff, #fff); }

        .circle-btn {
            position: absolute; width: 45px; height: 45px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid var(--primary-gold);
            color: #fff; font-size: 0.8rem; font-weight: bold;
            cursor: pointer; z-index: 200; display: flex; justify-content: center; align-items: center;
            pointer-events: auto; transition: all 0.2s;
            top: 20px; top: max(20px, env(safe-area-inset-top));
        }
        .circle-btn:hover { transform: scale(1.1); background: var(--primary-gold); color: #000; }

        .home-btn { left: 20px; left: max(20px, env(safe-area-inset-left)); font-size: 1.5rem; padding-bottom: 3px; }

        #game-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.2rem; color: #fff; display: none; background: rgba(0,0,0,0.95);
            padding: 25px 40px; border-radius: 20px; border: 3px solid var(--primary-gold); z-index: 3000;
            text-align: center; width: 80%; max-width: 400px; backdrop-filter: blur(10px);
            flex-direction: column; align-items: center; gap: 15px;
        }

        #tutorial-ui {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: none; flex-direction: column; align-items: center;
            background: linear-gradient(to top, rgba(0,0,0,1) 40%, rgba(0,0,0,0.8) 90%, transparent);
            padding-bottom: 20px; pointer-events: auto; z-index: 25;
        }
        #tutorial-desc {
            color: #fff; font-size: 1rem; text-align: center; margin-bottom: 10px;
            padding: 10px 20px; background: rgba(0,0,0,0.5); border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2); width: 90%; max-width: var(--ui-max-width);
        }
        .tutorial-controls {
            display: flex; gap: 3px; width: 98%; max-width: var(--ui-max-width);
            justify-content: center; margin-bottom: 10px;
        }
        .back-btn-container { position: absolute; top: 20px; right: 20px; z-index: 200; }
        .btn-small {
            padding: 8px 15px; font-size: 0.9rem; background: rgba(0,0,0,0.6);
            border: 1px solid #fff; color: #fff; cursor: pointer; border-radius: 20px;
            font-family: 'Cinzel', serif;
        }

        /* Ragnarok Online Style Damage Numbers */
        .damage-popup {
            position: absolute;
            color: #ffff00;
            font-family: "Arial Black", "Arial", sans-serif;
            font-weight: 900;
            font-size: 2.2rem;
            letter-spacing: -2px;
            /* Heavy black outline effect */
            text-shadow: 
                2px 2px 0 #000, 
               -1px -1px 0 #000,  
                1px -1px 0 #000,
               -1px 1px 0 #000,
                1px 1px 0 #000,
                3px 3px 5px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 4000;
            user-select: none;
            opacity: 0;
            transform: scale(0.5);
        }
        
        @keyframes damage-pop {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-30px) scale(1.3); opacity: 1; }
            40% { transform: translateY(-40px) scale(1.0); opacity: 1; }
            80% { transform: translateY(-60px) scale(1.0); opacity: 1; }
            100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
        }

        @media (min-width: 1024px) {
            #status-log { bottom: 150px; width: 100%; font-size: 1rem; height: 50px; }
            .card { font-size: 0.8rem; }
            .name-text, .hp-text, .fatigue-text, .rage-text { font-size: 0.75rem; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
</head>
<body>

<div id="viewport">
    
    <!-- 1. ä¸»é¸å–® -->
    <div id="main-menu" class="overlay-screen active">
        <!-- è±¬è±¬èƒŒæ™¯åœ– -->
        <img src="pignarok_bg.png" class="menu-bg-pig" alt="Pig Background">
        
        <h1 id="menu-title">è±¬ç¥é»ƒæ˜</h1>
        <div class="sub-title">PIGNAROK ARENA</div>
        
        <div class="version-text">ç‰ˆæœ¬ 22.4</div>
        
        <div class="lang-container">
            <button id="lang-zh" class="btn-lang active" onclick="window.setLang('zh-TW')">ä¸­æ–‡</button>
            <button id="lang-en" class="btn-lang" onclick="window.setLang('en-US')">ENG</button>
        </div>

        <button id="btn-create" class="btn-gold" style="border-color:#ff99cc; color:#ff99cc; background:rgba(255,153,204,0.2);" onclick="UI.showCreate()">å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)</button>
        <button id="btn-join" class="btn-gold" style="border-color:#ff99cc; color:#ff99cc; background:rgba(255,153,204,0.2);" onclick="UI.showJoin()">åŠ å…¥ç¶²çµ¡å°æˆ°</button>
        <button id="btn-tutorial" class="btn-gold" style="border-color:#55ccff; color:#55ccff; background:rgba(0,100,200,0.2);" onclick="window.startTutorialSelection()">è§’è‰²æ•™å­¸</button>
    
        <div class="studio-footer">JASDEV STUDIO 2025</div>
    </div>

    <!-- 2. å‰µå»ºæˆ¿é–“ (Host) -->
    <div id="screen-create" class="overlay-screen">
        <h2 id="create-title">å‰µå»ºéŠæˆ²æˆ¿é–“</h2>
        <p id="create-name-label">è«‹è¼¸å…¥ä½ çš„æš±ç¨±</p>
        <input type="text" id="host-name" class="input-box" placeholder="åç¨± (16å­—å…§)" maxlength="16">
        
        <!-- è³½åˆ¶é¸æ“‡ -->
        <p style="margin-top:10px; font-size:0.9rem; color:#aaa;">è³½åˆ¶ (Match Format)</p>
        <select id="match-format" class="input-box" style="width:80%; max-width:300px;">
            <option value="2">3 å±€ 2 å‹ (Best of 3)</option>
            <option value="3">5 å±€ 3 å‹ (Best of 5)</option>
            <option value="5">7 å±€ 5 å‹ (Best of 7)</option>
        </select>

        <p id="create-char-label" style="margin-top:20px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-host-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div>Odin</div>
            </div>
            <div id="mini-host-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div>Loki</div>
            </div>
        </div>

        <button id="btn-do-create" class="btn-gold" onclick="Network.createGame()">ç”Ÿæˆæˆ¿é–“</button>
        <button id="btn-create-back" class="btn-gold btn-back" onclick="UI.showMenu()">è¿”å›</button>
    </div>

    <!-- 3. åŠ å…¥æˆ¿é–“ (Client) -->
    <div id="screen-join" class="overlay-screen">
        <h2 id="join-title">åŠ å…¥ç¶²çµ¡å°æˆ°</h2>
        <input type="text" id="join-name" class="input-box" placeholder="ä½ çš„æš±ç¨± (16å­—å…§)" maxlength="16">
        <input type="number" id="join-code" class="input-box" placeholder="4ä½æ•¸æˆ¿è™Ÿ" maxlength="4">
        
        <p id="join-char-label" style="margin-top:20px; font-size:0.9rem; color:#aaa;">é¸æ“‡ä½ çš„è§’è‰²</p>
        <div class="mini-char-select">
            <div id="mini-join-odin" class="mini-card active" onclick="window.selectMiniChar('Odin')">
                <div class="mini-icon">âš¡</div>
                <div>Odin</div>
            </div>
            <div id="mini-join-loki" class="mini-card" onclick="window.selectMiniChar('Loki')">
                <div class="mini-icon">ğŸƒ</div>
                <div>Loki</div>
            </div>
        </div>

        <p id="join-status" style="color:#55ccff; font-size:0.9rem; min-height:20px;"></p>
        <button class="btn-gold" id="btn-connect" onclick="Network.joinGame()">é–‹å§‹é€£ç·š</button>
        <button id="btn-join-back" class="btn-gold btn-back" onclick="UI.showMenu()">è¿”å›</button>
    </div>

    <!-- 4. ç­‰å¾…å¤§å»³ -->
    <div id="screen-lobby" class="overlay-screen">
        <h2 id="lobby-title">æº–å‚™å¤§å»³</h2>
        <div class="room-code-display" id="lobby-code">----</div>
        <p id="lobby-share-hint">è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)</p>
        <div id="lobby-hint" class="breathing-text">(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)</div>
        
        <ul class="player-list" id="lobby-list">
            <!-- JS ç”Ÿæˆ -->
        </ul>

        <div id="host-controls" style="display:none; width:100%; text-align:center;">
            <button class="btn-gold" id="btn-start-net" onclick="Network.hostStartGame()" disabled>é–‹å§‹éŠæˆ²</button>
        </div>
        <div id="client-msg" style="display:none; color:#aaa; margin-top:20px;">
            ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...
        </div>
        
        <button id="btn-leave-room" class="btn-gold btn-back" onclick="window.resetGame()">é›¢é–‹æˆ¿é–“</button>
    </div>

    <div id="turn-hint" class="flashing">è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹</div>

    <div id="char-select" class="overlay-screen" style="display:none;">
        <h2 id="char-select-title">é¸æ“‡ä½ çš„è±¬è±¬æˆ°å£«</h2>
        <div class="selection-container">
            <div id="select-odin" class="char-card active" onclick="window.pickChar('Odin')">
                <div class="char-portrait-icon">âš¡ğŸ·</div>
                <div id="char-name-odin" class="char-name">å¥§ä¸è±¬</div>
                <div id="char-desc-odin" style="font-size:0.7rem; color:#ccc; margin-top:5px;">é›·éœ†èˆ‡æ¦®è€€</div>
            </div>
            <div id="select-loki" class="char-card" onclick="window.pickChar('Loki')">
                <div class="char-portrait-icon">ğŸƒğŸ·</div>
                <div id="char-name-loki" class="char-name">æ´›åŸºè±¬</div>
                <div id="char-desc-loki" style="font-size:0.7rem; color:#ccc; margin-top:5px;">è©­è¨ˆèˆ‡é®®è‚‰</div>
            </div>
        </div>
        <button id="btn-start-battle" class="btn-gold" onclick="window.confirmSelection()">é–‹å§‹æ±ºé¬¥</button>
        <button id="btn-back-menu" class="btn-gold btn-back" onclick="window.resetGame()">è¿”å›</button>
    </div>

    <div id="game-msg"></div>

    <!-- å‚·å®³æ•¸å­—å®¹å™¨ (ç½®æ–¼æœ€ä¸Šå±¤) -->
    <div id="dmg-container" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:4000; overflow:hidden;"></div>

    <div id="game-ui">
        <button class="circle-btn home-btn" onclick="window.resetGame()" title="å›ä¸»é¸å–®">ğŸ </button>
        
        <div id="scoreboard" style="display:none;"></div> <!-- é è¨­éš±è— -->

        <div id="top-announcer">
            <div id="timer">10</div>
            <div id="move-display">æº–å‚™ä¸­...</div>
        </div>
        <div id="card-description"></div> 

        <div id="bottom-ui-container">
            <div id="card-area">
                <div id="player-hp-card">
                    <div id="player-name-display" class="name-text">å¥§ä¸è±¬</div>
                    <div id="hp-line" class="hp-text">HP: 500/500</div>
                    <div id="fatigue-line" class="fatigue-text">ç–²å‹: 0%</div>
                    <div id="rage-line" class="rage-text">æ€’æ°£: 0%</div>
                </div>
                <div id="card-0" class="card" onclick="window.selectCard(0)">ç‰©æ”»âš”ï¸</div>
                <div id="card-1" class="card" onclick="window.selectCard(1)">é­”æ³•ğŸª„</div>
                <div id="slot-2-btn" class="card" onclick="window.selectCard(2)">åæ“ŠğŸ›¡ï¸</div>
                <div id="card-3" class="card" onclick="window.selectCard(3)">åå°„ğŸ’</div>
                <div id="defend-card" class="card" onclick="window.selectCard(4)">é˜²ç¦¦ğŸ§±</div>
                <div id="super-card" class="card super" style="display:none;" onclick="window.selectCard(5)">å¥§ç¾©ğŸ”¥</div>
                <div id="oracle-btn-card" onclick="window.askOracle()">âœ¨</div>
            </div>
        </div>
    </div>

    <!-- æ•™å­¸æ¨¡å¼ UI -->
    <div id="tutorial-ui">
        <div class="back-btn-container">
            <button id="btn-back-tut" class="btn-small" onclick="window.quitTutorial()">å›ä¸»é¸å–®</button>
        </div>
        <div id="tutorial-desc">é»æ“Šä¸‹æ–¹åœ–ç¤ºè§€çœ‹æŠ€èƒ½æ¼”ç¤º</div>
        <div class="tutorial-controls">
            <div id="tut-card-0" class="card" onclick="window.demoAction(0)">ç‰©æ”»âš”ï¸</div>
            <div id="tut-card-1" class="card" onclick="window.demoAction(1)">é­”æ³•ğŸª„</div>
            <div id="tut-card-2" class="card" onclick="window.demoAction(2)">åæ“ŠğŸ›¡ï¸</div>
            <div id="tut-card-3" class="card" onclick="window.demoAction(3)">åå°„ğŸ’</div>
            <div id="tut-card-4" class="card" onclick="window.demoAction(4)">é˜²ç¦¦ğŸ§±</div>
            <div id="tut-card-5" class="card super super-red" onclick="window.demoAction(5)">ç‰©å¥§ğŸ”¥</div>
            <div id="tut-card-6" class="card super super-blue" onclick="window.demoAction(6)">é­”å¥§âš¡</div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
    const APP_ID_PREFIX = "pig-ragnarok-v1-"; 
    const apiKey = ""; 
    const MAX_HP_ODIN = 500; 
    const MAX_HP_LOKI = 400;
    const TURN_TIME = 15; // è¯ç¶²ç¨å¾®é•·ä¸€é»
    let BASE_CAM_Y = 280; let BASE_CAM_Z = 600;
    let DEFAULT_CAM_POS = new THREE.Vector3(0, BASE_CAM_Y, BASE_CAM_Z);
    const DEFAULT_LOOK_AT = new THREE.Vector3(0, 40, -20);
    let targetWins = 2; // é è¨­ 3 å±€ 2 å‹
    
    // --- TRANSLATION SYSTEM ---
    let currentLang = 'zh-TW';
    const TRANSLATIONS = {
        'zh-TW': {
            title: "è±¬ç¥é»ƒæ˜", singlePlayer: "å–®äººéŠæˆ²", tutorial: "è§’è‰²æ•™å­¸",
            createGameBtn: "å‰µå»ºæˆ°å ´ (æ”¯æ´é€£ç·š)", joinGameBtn: "åŠ å…¥ç¶²çµ¡å°æˆ°",
            lobbyHint: "(äººæ•¸ä¸è¶³ 4 äººæœƒåŠ å…¥é›»è…¦æ“ä½œè§’è‰²)",
            createTitle: "å‰µå»ºéŠæˆ²æˆ¿é–“", enterName: "è«‹è¼¸å…¥ä½ çš„æš±ç¨±", namePlaceholder: "åç¨± (16å­—å…§)",
            chooseChar: "é¸æ“‡ä½ çš„è§’è‰²", doCreateBtn: "ç”Ÿæˆæˆ¿é–“", backBtn: "è¿”å›",
            joinTitle: "åŠ å…¥ç¶²çµ¡å°æˆ°", codePlaceholder: "4ä½æ•¸æˆ¿è™Ÿ", doConnectBtn: "é–‹å§‹é€£ç·š",
            lobbyTitle: "æº–å‚™å¤§å»³", lobbyShare: "è«‹å°‡æˆ¿è™Ÿåˆ†äº«çµ¦æœ‹å‹ (æœ€å¤š4äºº)", leaveRoom: "é›¢é–‹æˆ¿é–“",
            waitingHost: "ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²...", startGame: "é–‹å§‹éŠæˆ²",
            selectCharTitle: "é¸æ“‡ä½ çš„è±¬è±¬æˆ°å£«", selectPracticeChar: "é¸æ“‡è¦ç·´ç¿’çš„è§’è‰²",
            startBattle: "é–‹å§‹æ±ºé¬¥", startPractice: "é–‹å§‹ç‰¹è¨“",
            back: "è¿”å›", backMenu: "å›ä¸»é¸å–®",
            odinName: "å¥§ä¸è±¬", odinDesc: "é›·éœ†èˆ‡æ¦®è€€",
            lokiName: "æ´›åŸºè±¬", lokiDesc: "è©­è¨ˆèˆ‡é®®è‚‰",
            charOdin: "å¥§æ±€", charLoki: "æ´›åŸº",
            turnHint: "è«‹é¸æ“‡ä¸‹æ–¹çš„å¡ç‰Œä¸¦é»é¸å°æ‰‹", ready: "æº–å‚™ä¸­...",
            moveNames: ["ç‰©ç†æ”»æ“Š", "é­”æ³•æ”»æ“Š", "åæ“Š", "é­”æ³•åå°„", "é˜²ç¦¦", "çµ‚æ¥µå¥§ç¾©"],
            cardNames: { 0: "ç‰©æ”»âš”ï¸", 1: "é­”æ³•ğŸª„", 2: "åæ“ŠğŸ›¡ï¸", 3: "åå°„ğŸ’", 4: "é˜²ç¦¦ğŸ§±", 5: "å¥§ç¾©ğŸ”¥", swap: "ç©ºé–“ğŸŒ€" },
            tutCardNames: { 5: "ç‰©å¥§ğŸ”¥", 6: "é­”å¥§âš¡" },
            victory: "å‹åˆ©ï¼", gameOver: "å›åˆçµæŸ", restart: "é‡æ–°é–‹å§‹",
            swapSkill: "ç©ºé–“èª¿æ›", counterSkill: "é˜²ç¦¦åæ“Š",
            targetLocked: "(ç›®æ¨™é–å®šä¸­)", dead: "èŠ­æ¯”Qå•¦", fatigue: "ç–²å‹", rage: "æ€’æ°£",
            defendFatigue: "é˜²ç¦¦ç–²å‹ä¸­", defend: "é˜²ç¦¦", tired: "åŠ›ç›¡ğŸ§±",
            tutDesc: "é»æ“Šä¸‹æ–¹åœ–ç¤ºè§€çœ‹æŠ€èƒ½æ¼”ç¤º", tutEnd: "æ¼”ç¤ºå®Œç•¢ã€‚è«‹é¸æ“‡ä¸‹ä¸€å€‹æŠ€èƒ½ã€‚",
            tut0_odin: "ã€å²¡æ ¼å°¼çˆ¾æ–¬ã€‘Odin æ®èˆç¥æ§é€²è¡Œè¿‘æˆ°æ”»æ“Šï¼Œé€ æˆç‰©ç†å‚·å®³ä¸¦ç´¯ç©ç´…è‰²æ€’æ°£ã€‚",
            tut0_loki: "ã€æ»¾çƒæ”»æ“Šã€‘Loki å°‡è‡ªå·±è®Šæˆçƒæ’å‘æ•µäººï¼Œé€ æˆç‰©ç†å‚·å®³ä¸¦ç´¯ç©ç´…è‰²æ€’æ°£ã€‚",
            tut1_odin: "ã€é›·éœ†è¬éˆã€‘å¬å–šé–ƒé›»æ”»æ“Šæ•µäººï¼Œé€ æˆé­”æ³•å‚·å®³ï¼Œç´¯ç©è—è‰²æ€’æ°£ã€‚",
            tut1_loki: "ã€é®®è‚‰æŠ•æ“²ã€‘ä¸Ÿå‡ºä¸€å¡Šå·¨å¤§çš„è‚‰ï¼Œå°æ•µäººé€ æˆé­”æ³•å‚·å®³ï¼Œç´¯ç©è—è‰²æ€’æ°£ã€‚è‚‰å¡Šè½åœ°æœƒçˆ†ç‚¸ï¼",
            tut2_odin: "ã€é˜²ç¦¦åæ“Šã€‘é€²å…¥é˜²ç¦¦å§¿æ…‹ï¼Œè‹¥å—åˆ°ã€Œç‰©ç†æ”»æ“Šã€å°‡è‡ªå‹•åæ“Šã€‚",
            tut2_loki: "ã€ç©ºé–“èª¿æ›ã€‘(ç‰¹æ®Š) ç•¶å—åˆ°ç‰©ç†æ”»æ“Šæ™‚ï¼Œå°‡è‡ªå·±èˆ‡å¦ä¸€å€‹æ•µäººäº¤æ›ä½ç½®ï¼(éœ€æœ‰å¤šå€‹ç›®æ¨™)",
            tut3_odin: "ã€é­”æ³•åå°„ã€‘è‹¥å—åˆ°é­”æ³•æ”»æ“Šï¼Œä½¿ç”¨ç¥åŠ›åå½ˆå‚·å®³ã€‚",
            tut3_loki: "ã€é­”æ³•åå°„ã€‘è‹¥å—åˆ°é­”æ³•æ”»æ“Šï¼Œå°‡å‚·å®³åå½ˆçµ¦å°æ‰‹ã€‚",
            tut4: "ã€çµ•å°é˜²ç¦¦ã€‘å¤§å¹…é™ä½å‚·å®³ï¼Œä½†å¢åŠ ç–²å‹å€¼ã€‚ç–²å‹éé«˜ä¸‹å›åˆç„¡æ³•é˜²ç¦¦ï¼",
            tut5_odin: "ã€è«¸ç¥é»ƒæ˜ã€‘(ç‰©ç†å¥§ç¾©) æ€’æ°£å…¨æ»¿(ç´…)æ™‚ç™¼å‹•ï¼Œæ¯€æ»…æ€§é€£æ“Šï¼",
            tut5_loki: "ã€è©­è¨ˆãƒ»è‚‰å½ˆæˆ°è»Šã€‘(ç‰©ç†å¥§ç¾©) æ€’æ°£å…¨æ»¿(ç´…)æ™‚ç™¼å‹•ï¼Œå°å–®ä¸€ç›®æ¨™é€²è¡Œ3æ¬¡ä¾†å›è¡æ’ï¼",
            tut6_odin: "ã€é›·ç¥ä¹‹æ€’ã€‘(é­”æ³•å¥§ç¾©) æ€’æ°£å…¨æ»¿(è—)æ™‚ç™¼å‹•ï¼Œå¬å–šæ¯€æ»…æ€§çš„é›·æš´ï¼",
            tut6_loki: "ã€è©­è¨ˆãƒ»å¤©é™è‚‰é›¨ã€‘(é­”æ³•å¥§ç¾©) æ€’æ°£å…¨æ»¿(è—)æ™‚ç™¼å‹•ï¼Œå¬å–šå·¨å‹è‚‰å¡Šè½Ÿç‚¸å ´åœ°ï¼",
            cardDescs: {
                0: "é€ æˆç‰©ç†å‚·å®³ï¼Œå¢åŠ ç´…è‰²æ€’æ°£",
                1: "é€ æˆé­”æ³•å‚·å®³ï¼Œå¢åŠ è—è‰²æ€’æ°£",
                2: { "Odin": "å—åˆ°ç‰©ç†æ”»æ“Šæ™‚è‡ªå‹•åæ“Š", "Loki": "å—åˆ°ç‰©ç†æ”»æ“Šæ™‚èˆ‡æ•µäººäº¤æ›ä½ç½®" },
                3: "åå½ˆå—åˆ°çš„é­”æ³•å‚·å®³",
                4: "å¤§å¹…æ¸›å‚·ï¼Œä½†å¢åŠ ç–²å‹å€¼",
                5: { "Odin": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£ï¼Œé€ æˆæ¯€æ»…æ€§é€£æ“Š", "Loki": "æ¶ˆè€—å…¨éƒ¨æ€’æ°£ï¼Œå°å–®ä¸€ç›®æ¨™é€£çºŒè¡æ’" }
            },
            logBlock: "æˆåŠŸé˜²ç¦¦", logCounter: "çš„åæ“Šåœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼",
            logReflect: "çš„åå°„åœ¨å¥§ç¾©é¢å‰å¤±æ•ˆäº†ï¼", logHit: "çš„æ”»æ“Šï¼",
            playerSuffix: " (æˆ‘)", cpuPrefix: "(CPU) ",
            tutorialName: "æ•™å­¸", dummyName: "å‡äºº", civilian: "è·¯äºº",
            ragnarok: "è«¸ç¥çš„é»ƒæ˜å·²ç¶“é™è‡¨...", pigKing: "è±¬è±¬ä¹‹ç‹èª•ç”Ÿäº†ï¼",
            lockingTargets: "é–å®šç›®æ¨™ï¼",
            waitingOthers: "ç­‰å¾…å…¶ä»–ç©å®¶...",
            connError: "é€£ç·šéŒ¯èª¤", incomplete: "è¼¸å…¥ä¸å®Œæ•´", hostLeft: "æˆ¿ä¸»å·²æ–·ç·šï¼ŒéŠæˆ²çµæŸ",
            winSuffix: "å‹",
            roundWinner: "å›åˆå‹åˆ©è€…ï¼š", nextRoundIn: "ä¸‹ä¸€å›åˆï¼š",
            currentRound: "ç•¶å‰å±€åˆ†",
            dmgLog: "é€ æˆ {dmg} å‚·å®³ï¼"
        },
        'en-US': {
            title: "PIGNAROK", singlePlayer: "Single Player", tutorial: "Tutorial",
            createGameBtn: "Host Game (Online supported)", joinGameBtn: "Join Arena",
            lobbyHint: "(CPU will fill empty slots if < 4 players)",
            createTitle: "Create Game Room", enterName: "Enter your nickname", namePlaceholder: "Name (Max 16 chars)",
            chooseChar: "Choose Your Character", doCreateBtn: "Create Room", backBtn: "Back",
            joinTitle: "Join Network Arena", codePlaceholder: "4-Digit Room Code", doConnectBtn: "Connect",
            lobbyTitle: "Lobby", lobbyShare: "Share Room Code (Max 4 Players)", leaveRoom: "Leave Room",
            waitingHost: "Waiting for host to start...", startGame: "Start Game",
            selectCharTitle: "Select Your Warrior", selectPracticeChar: "Select Character",
            startBattle: "Start Battle", startPractice: "Start Training",
            back: "Back", backMenu: "Main Menu",
            odinName: "Odin", odinDesc: "Thunder & Glory",
            lokiName: "Loki", lokiDesc: "Tricks & Meat",
            charOdin: "Odin", charLoki: "Loki",
            turnHint: "Select a card below and tap an enemy", ready: "Ready...",
            moveNames: ["Melee", "Magic", "Counter", "Reflect", "Defend", "Ultimate"],
            cardNames: { 0: "Meleeâš”ï¸", 1: "MagicğŸª„", 2: "CountğŸ›¡ï¸", 3: "ReflğŸ’", 4: "DefğŸ§±", 5: "UltğŸ”¥", swap: "SwapğŸŒ€" },
            tutCardNames: { 5: "Phys UltğŸ”¥", 6: "Mag Ultâš¡" },
            victory: "VICTORY!", gameOver: "GAME OVER", restart: "Play Again", finalVictory: "The New Emperor!", finalMenu: "Main Menu",
            swapSkill: "Spatial Swap", counterSkill: "Counter",
            targetLocked: "(Target Locked)", dead: "Barbecued", fatigue: "Fatigue", rage: "Rage",
            defendFatigue: "Fatigued", defend: "Defend", tired: "TiredğŸ§±",
            tutDesc: "Tap icons below to see skill demos", tutEnd: "Demo finished. Select next skill.",
            tut0_odin: "[Gungnir Slash] Melee attack. Deals physical dmg, builds Red Rage.",
            tut0_loki: "[Ball Attack] Rolls into enemy. Deals physical dmg, builds Red Rage.",
            tut1_odin: "[Thunderstrike] Summons lightning. Deals magic dmg, builds Blue Rage.",
            tut1_loki: "[Meat Throw] Throws giant meat. Magic dmg, Blue Rage. Explodes on impact!",
            tut2_odin: "[Counter] Defensive stance. Auto-counters Melee attacks.",
            tut2_loki: "[Swap] (Special) Swaps position with another enemy when hit by Melee! (Needs multiple targets)",
            tut3_odin: "[Reflect] Reflects Magic damage back to attacker.",
            tut3_loki: "[Reflect] Bounces Magic damage back to attacker.",
            tut4: "[Defend] Reduces dmg significantly but adds Fatigue. Cannot defend if Fatigued!",
            tut5_odin: "[Ragnarok] (Phys Ult) Requires Max Red Rage. Devastating combo!",
            tut5_loki: "[Meat Chariot] (Phys Ult) Requires Max Red Rage. Rushes target 3 times!",
            tut6_odin: "[Thor's Wrath] (Magic Ult) Requires Max Blue Rage. Summon storms!",
            tut6_loki: "[Meat Rain] (Magic Ult) Requires Max Blue Rage. Bombards the field!",
            cardDescs: {
                0: "Deals Physical DMG, builds Red Rage",
                1: "Deals Magic DMG, builds Blue Rage",
                2: { "Odin": "Counters Physical attacks automatically", "Loki": "Swaps position when hit by Physical attack" },
                3: "Reflects Magic damage back",
                4: "Reduces damage significantly, adds Fatigue",
                5: { "Odin": "Consumes Max Rage for devastating combo", "Loki": "Consumes Max Rage to rush target repeatedly" }
            },
            logBlock: "blocked", logCounter: "'s counter failed against Ultimate!",
            logReflect: "'s reflect failed against Ultimate!", logHit: "'s attack!",
            playerSuffix: " (Me)", cpuPrefix: "(CPU) ",
            tutorialName: "Teacher", dummyName: "Dummy", civilian: "Civilian",
            ragnarok: "Ragnarok has come...", pigKing: "The Pig King is born!",
            lockingTargets: "Locking Targets!",
            waitingOthers: "Waiting for others...",
            connError: "Connection Error", incomplete: "Input incomplete", hostLeft: "Host disconnected, game over",
            winSuffix: " Wins",
            roundWinner: "Round Winner: ", nextRoundIn: "Next Round: ",
            currentRound: "Current Scores",
            dmgLog: "hit for {dmg} damage!"
        }
    };
    let CARD_NAMES = []; 

    let scene, camera, renderer, clock, raycaster;
    let players = [], gameState = 'IDLE', timeLeft = TURN_TIME, selectedSlot = -1, selectedTargetId = -1;
    let timerInterval, cpuThinkTimer, playerRage = { red: 0, blue: 0 };
    let selectedPlayerType = 'Odin';
    let isTutorialMode = false; let isTutorialSelection = false;
    let currentDemoId = 0; 
    const mouse = new THREE.Vector2();
    let animationId = null; 
    let myPlayerIndex = 0; // 0 for SP, dynamic for MP
    let isMultiplayer = false;
    
    // Win Tracking
    let matchScores = {}; // { playerId: wins }

    // --- Online State ---
    const Online = {
        isHost: false,
        myName: "Player",
        roomCode: "",
        peer: null,
        myPeerId: "",
        connections: [], // Host stores all clients
        hostConn: null, // Client stores host
        playerMap: [], // [{id, name, isHost, peerId, isCpu, type}]
        hasActed: false, // Did I act this turn?
        matchConfig: { targetWins: 2 }
    };

    let activeLightnings = [], activeParticles = [], activeProjectiles = [];
    const SHARED_BOX_GEO = new THREE.BoxGeometry(1.2, 1.2, 1.2);

    const SoundEngine = { ctx: null, init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); }, play(type) { this.init(); const now = this.ctx.currentTime; const masterGain = this.ctx.createGain(); masterGain.connect(this.ctx.destination); masterGain.gain.setValueAtTime(0.4, now); const osc = this.ctx.createOscillator(); const env = this.ctx.createGain(); osc.connect(env); env.connect(masterGain); let dur = 0.3; switch(type) { case 'click': osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); env.gain.setValueAtTime(0.2, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.1); dur=0.1; break; case 'slash': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(450, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.2); env.gain.setValueAtTime(0.2, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'magic': osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.4); env.gain.setValueAtTime(0.12, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.4); dur=0.4; break; case 'hit': osc.type = 'sine'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now+0.15); env.gain.setValueAtTime(0.4, now); env.gain.linearRampToValueAtTime(0, now+0.15); dur=0.15; break; case 'counter': osc.type = 'square'; osc.frequency.setValueAtTime(1100, now); env.gain.setValueAtTime(0.1, now); env.gain.linearRampToValueAtTime(0, now+0.2); dur=0.2; break; case 'super': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(90, now); env.gain.setValueAtTime(0.3, now); env.gain.exponentialRampToValueAtTime(0.001, now+1.2); dur=1.2; break; case 'bonk': osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); env.gain.setValueAtTime(0.8, now); env.gain.exponentialRampToValueAtTime(0.001, now+0.2); dur=0.2; break; case 'ding': osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(2400, now + 0.05); env.gain.setValueAtTime(0.5, now); env.gain.exponentialRampToValueAtTime(0.001, now + 0.3); dur = 0.3; break; } osc.start(now); osc.stop(now+dur); setTimeout(() => { if(osc) osc.disconnect(); if(env) env.disconnect(); if(masterGain) masterGain.disconnect(); }, 2000); } };

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function move(obj, target, ms) { return new Promise(res => { const start = obj.position.clone(), t = performance.now(); function up() { let p = Math.min(1, (performance.now() - t) / ms); obj.position.lerpVectors(start, target, p); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    // --- Camera Logic ---
    function adjustCameraForResponsive(snap = false) { 
        if (!camera || !renderer) return; 
        const aspect = window.innerWidth / window.innerHeight; 
        let targetY = BASE_CAM_Y; let targetZ = BASE_CAM_Z; 
        if (aspect > 1.2) { targetY = 240; targetZ = 550; } else if (aspect < 0.6) { targetZ = 650; targetY = 320; } 
        
        // Multi-player Camera Rotation
        let rotY = 0;
        if (myPlayerIndex === 1) rotY = Math.PI;
        else if (myPlayerIndex === 2) rotY = Math.PI/2;
        else if (myPlayerIndex === 3) rotY = -Math.PI/2;

        const basePos = new THREE.Vector3(0, targetY, targetZ);
        basePos.applyAxisAngle(new THREE.Vector3(0,1,0), rotY);

        DEFAULT_CAM_POS.copy(basePos);
        
        if (snap) {
            camera.position.copy(DEFAULT_CAM_POS);
            camera.lookAt(DEFAULT_LOOK_AT);
        } else if (gameState === 'WAITING' || gameState === 'IDLE' || gameState === 'TUTORIAL_IDLE') { 
            camera.position.lerp(DEFAULT_CAM_POS, 0.1); 
            camera.lookAt(DEFAULT_LOOK_AT); 
        } 
    }
    
    function resetCamera() { 
        if (camera) { 
            adjustCameraForResponsive(); 
            camera.position.copy(DEFAULT_CAM_POS); 
            camera.lookAt(DEFAULT_LOOK_AT); 
        } 
    }

    function log(m) { /* Disabled */ }

    function showMove(text) {
        const md = document.getElementById('move-display');
        md.innerText = text;
        md.style.opacity = "1";
        md.classList.add('announce-anim');
    }

    function hideMove() {
        const md = document.getElementById('move-display');
        md.style.opacity = "0";
        md.classList.remove('announce-anim');
    }

    // New Function: Spawn Damage Number (RO Style)
    function spawnDamageNumber(target, amount) {
        if (!target) return;
        
        const div = document.createElement('div');
        div.className = 'damage-popup';
        div.innerText = amount;
        
        // Initial Position (will be updated in loop, but we set style once)
        // We use CSS animation for movement, but need start pos
        const pos = target.group.position.clone().add(new THREE.Vector3(0, 40, 0));
        const vector = pos.project(camera);
        const x = (vector.x * .5 + .5) * window.innerWidth;
        const y = (-(vector.y * .5) + .5) * window.innerHeight;
        
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
        div.style.animation = 'damage-pop 0.8s ease-out forwards';
        
        document.getElementById('dmg-container').appendChild(div);
        
        setTimeout(() => {
            if (div.parentNode) div.parentNode.removeChild(div);
        }, 800);
    }

    window.setLang = function(lang) {
        currentLang = lang;
        document.getElementById('lang-zh').classList.toggle('active', lang === 'zh-TW');
        document.getElementById('lang-en').classList.toggle('active', lang === 'en-US');
        updateText();
    };

    function updateText() {
        const t = TRANSLATIONS[currentLang];
        document.getElementById('menu-title').innerText = t.title;
        document.getElementById('btn-create').innerText = t.createGameBtn;
        document.getElementById('btn-join').innerText = t.joinGameBtn;
        document.getElementById('lobby-hint').innerText = t.lobbyHint;
        
        // Screen Titles and Labels
        document.getElementById('create-title').innerText = t.createTitle;
        document.getElementById('create-name-label').innerText = t.enterName;
        document.getElementById('host-name').placeholder = t.namePlaceholder;
        document.getElementById('create-char-label').innerText = t.chooseChar;
        document.getElementById('btn-do-create').innerText = t.doCreateBtn;
        document.getElementById('btn-create-back').innerText = t.backBtn;

        document.getElementById('join-title').innerText = t.joinTitle;
        document.getElementById('join-name').placeholder = t.namePlaceholder;
        document.getElementById('join-code').placeholder = t.codePlaceholder;
        document.getElementById('join-char-label').innerText = t.chooseChar;
        document.getElementById('btn-connect').innerText = t.doConnectBtn;
        document.getElementById('btn-join-back').innerText = t.backBtn;

        document.getElementById('lobby-title').innerText = t.lobbyTitle;
        document.getElementById('lobby-share-hint').innerText = t.lobbyShare;
        document.getElementById('btn-leave-room').innerText = t.leaveRoom;
        document.getElementById('client-msg').innerText = t.waitingHost;
        const startNetBtn = document.getElementById('btn-start-net');
        
        document.getElementById('btn-tutorial').innerText = t.tutorial;
        document.getElementById('char-select-title').innerText = isTutorialSelection ? t.selectPracticeChar : t.selectCharTitle;
        document.getElementById('char-name-odin').innerText = t.odinName;
        document.getElementById('char-desc-odin').innerText = t.odinDesc;
        document.getElementById('char-name-loki').innerText = t.lokiName;
        document.getElementById('char-desc-loki').innerText = t.lokiDesc;
        document.getElementById('btn-start-battle').innerText = isTutorialSelection ? t.startPractice : t.startBattle;
        document.getElementById('btn-back-menu').innerText = t.back;
        document.getElementById('btn-back-tut').innerText = t.backMenu;
        document.getElementById('turn-hint').innerText = t.turnHint;
        document.getElementById('card-0').innerText = t.cardNames[0];
        document.getElementById('card-1').innerText = t.cardNames[1];
        document.getElementById('card-3').innerText = t.cardNames[3];
        document.getElementById('defend-card').innerText = t.cardNames[4];
        document.getElementById('super-card').innerText = t.cardNames[5];
        
        // Update Tutorial Cards
        document.getElementById('tut-card-0').innerText = t.cardNames[0];
        document.getElementById('tut-card-1').innerText = t.cardNames[1];
        document.getElementById('tut-card-2').innerText = t.cardNames[2]; // Default to Counter
        document.getElementById('tut-card-3').innerText = t.cardNames[3];
        document.getElementById('tut-card-4').innerText = t.cardNames[4];
        document.getElementById('tut-card-5').innerText = t.tutCardNames[5];
        document.getElementById('tut-card-6').innerText = t.tutCardNames[6];

        if (gameState === 'TUTORIAL_IDLE') { document.getElementById('tutorial-desc').innerText = t.tutDesc; }
        CARD_NAMES = [...t.moveNames]; 

        if (players.length > 0) {
            const p = players[myPlayerIndex]; // Use Local Player
            if(p) {
                const slot2 = document.getElementById('slot-2-btn');
                const tutSlot2 = document.getElementById('tut-card-2');
                
                if (p.type === 'Loki') {
                    slot2.innerText = t.cardNames.swap; 
                    if(tutSlot2) tutSlot2.innerText = t.cardNames.swap;
                    CARD_NAMES[2] = t.swapSkill;
                } else {
                    slot2.innerText = t.cardNames[2];
                    if(tutSlot2) tutSlot2.innerText = t.cardNames[2];
                    CARD_NAMES[2] = t.counterSkill;
                }
                const defBtn = document.getElementById('defend-card');
                if (p.fatigue >= 100) defBtn.innerText = t.tired; else defBtn.innerText = t.cardNames[4];
                players.forEach(pl => pl.refreshLabel());
                
                document.getElementById('player-name-display').innerText = p.getDisplayName();
            }
        }
        if (selectedSlot !== -1 && players.length > 0) showCardDescription(selectedSlot);
    }

    // --- UI Control ---
    const UI = {
        screens: ['main-menu', 'screen-create', 'screen-join', 'screen-lobby', 'char-select', 'game-ui', 'tutorial-ui'],
        show(id) {
            this.screens.forEach(s => {
                const el = document.getElementById(s);
                if(el) { el.classList.remove('active'); el.style.display = 'none'; }
            });
            const t = document.getElementById(id);
            if(t) { 
                t.style.display = 'flex'; 
                // Delay adding active for transition
                setTimeout(()=>t.classList.add('active'), 10); 
                if(id === 'game-ui') t.style.display = 'block'; // Game UI is block
            }
        },
        showMenu() { this.show('main-menu'); },
        showCreate() { 
            // Reset mini selector
            selectedPlayerType = 'Odin';
            document.getElementById('mini-host-odin').className = "mini-card active";
            document.getElementById('mini-host-loki').className = "mini-card";
            this.show('screen-create'); 
        },
        showJoin() { 
            // Reset mini selector
            selectedPlayerType = 'Odin';
            document.getElementById('mini-join-odin').className = "mini-card active";
            document.getElementById('mini-join-loki').className = "mini-card";
            
            document.getElementById('join-status').innerText = "";
            document.getElementById('btn-connect').disabled = false;
            document.getElementById('btn-connect').innerText = TRANSLATIONS[currentLang].doConnectBtn;
            this.show('screen-join'); 
        },
        updateLobby(roomCode, playersList) {
            this.show('screen-lobby');
            document.getElementById('lobby-code').innerText = roomCode;
            const list = document.getElementById('lobby-list');
            list.innerHTML = "";
            playersList.forEach(p => {
                const li = document.createElement('li');
                let html = `<span>${p.name} <small style="color:#aaa">(${p.type})</small></span> <div>`;
                if (p.isHost) html += `<span class="tag-host">HOST</span> `;
                if (p.peerId === Online.myPeerId) html += `<span class="tag-me">YOU</span>`;
                html += `</div>`;
                li.innerHTML = html;
                list.appendChild(li);
            });
            
            if (Online.isHost) {
                document.getElementById('host-controls').style.display = 'block';
                document.getElementById('client-msg').style.display = 'none';
                const btn = document.getElementById('btn-start-net');
                btn.disabled = false; 
                btn.innerText = `${TRANSLATIONS[currentLang].startGame} (${playersList.length}/4)`;
            } else {
                document.getElementById('host-controls').style.display = 'none';
                document.getElementById('client-msg').style.display = 'block';
            }
        },
        updateScoreboard() {
            const sb = document.getElementById('scoreboard');
            if (isTutorialMode) { sb.style.display = 'none'; return; }
            // Do NOT display block here, only populate. It is shown at round end manually.
            sb.innerHTML = `<h3 style="margin:0 0 10px 0; color:#ff99cc; border-bottom:1px solid #555;">${TRANSLATIONS[currentLang].currentRound}</h3>`;
            players.forEach(p => {
                const wins = matchScores[p.id] || 0;
                const row = document.createElement('div');
                row.className = 'score-row';
                row.innerHTML = `${p.getDisplayName()} <span class="score-num">${wins} ${TRANSLATIONS[currentLang].winSuffix}</span>`;
                sb.appendChild(row);
            });
        }
    };

    window.selectMiniChar = function(type) {
        selectedPlayerType = type;
        SoundEngine.init(); SoundEngine.play('click');
        
        // Update both host and join visuals for simplicity
        const setUI = (prefix) => {
            document.getElementById(prefix + '-odin').className = type === 'Odin' ? "mini-card active" : "mini-card";
            document.getElementById(prefix + '-loki').className = type === 'Loki' ? "mini-card active" : "mini-card";
        };
        setUI('mini-host');
        setUI('mini-join');
    };

    // --- Network Module ---
    const Network = {
        createGame() {
            const name = document.getElementById('host-name').value.trim();
            const format = document.getElementById('match-format').value;
            if(!name) return alert(TRANSLATIONS[currentLang].incomplete);
            Online.isHost = true;
            Online.myName = name;
            Online.roomCode = Math.floor(1000 + Math.random() * 9000).toString();
            Online.matchConfig.targetWins = parseInt(format) || 2;
            targetWins = Online.matchConfig.targetWins;
            
            Online.peer = new Peer(APP_ID_PREFIX + Online.roomCode);
            Online.peer.on('open', (id) => {
                Online.myPeerId = id;
                // Add type here
                Online.playerMap = [{ name: Online.myName, isHost: true, peerId: id, isCpu: false, type: selectedPlayerType }];
                UI.updateLobby(Online.roomCode, Online.playerMap);
            });
            Online.peer.on('error', (err) => { alert(TRANSLATIONS[currentLang].connError); location.reload(); });
            Online.peer.on('connection', (conn) => {
                if(Online.playerMap.length >= 4) {
                    conn.on('open', () => { conn.send({type:'ERROR', msg:'Full'}); setTimeout(()=>conn.close(), 500); });
                    return;
                }
                Online.connections.push(conn);
                conn.on('data', (data) => Network.handleHostData(conn, data));
                
                conn.on('close', () => {
                    const pIdx = Online.playerMap.findIndex(x => x.peerId === conn.peer);
                    if (pIdx !== -1) {
                        const p = Online.playerMap[pIdx];
                        // å¦‚æœç‹€æ…‹æ˜¯ IDLE (å¤§å»³)ï¼Œå‰‡ç›´æ¥ç§»é™¤ç©å®¶
                        if (gameState === 'IDLE') {
                            Online.playerMap.splice(pIdx, 1);
                            Online.connections = Online.connections.filter(c => c !== conn);
                            Network.broadcast({type: 'LOBBY_UPDATE', players: Online.playerMap});
                            UI.updateLobby(Online.roomCode, Online.playerMap);
                        } else {
                            // éŠæˆ²ä¸­ï¼šåˆ‡æ›ç‚º CPU
                            p.isCpu = true;
                            p.name += " (CPU)";
                            Network.broadcast({type: 'LOBBY_UPDATE', players: Online.playerMap});
                            log(`${p.name} disconnected, AI takeover`);
                        }
                    }
                });
            });
        },
        joinGame() {
            const name = document.getElementById('join-name').value.trim();
            const code = document.getElementById('join-code').value.trim();
            if(!name || code.length!==4) return alert(TRANSLATIONS[currentLang].incomplete);
            
            Online.isHost = false;
            Online.myName = name;
            Online.roomCode = code;
            const btn = document.getElementById('btn-connect');
            btn.disabled = true; btn.innerText = "...";
            
            Online.peer = new Peer();
            
            Online.peer.on('open', (id) => {
                Online.myPeerId = id;
                const conn = Online.peer.connect(APP_ID_PREFIX + code);
                conn.on('open', () => {
                    Online.hostConn = conn;
                    // Send character type here
                    conn.send({type: 'JOIN_REQUEST', name: name, characterType: selectedPlayerType});
                });
                conn.on('data', (data) => Network.handleClientData(data));
                conn.on('close', () => { alert(TRANSLATIONS[currentLang].hostLeft); location.reload(); });
                conn.on('error', (err) => console.log(err));
            });
            Online.peer.on('error', (err) => { alert(TRANSLATIONS[currentLang].connError); location.reload(); });
        },
        handleHostData(conn, data) {
            if(data.type === 'JOIN_REQUEST') {
                // Read type from request
                const pType = data.characterType || 'Odin';
                const newP = { name: data.name, isHost: false, peerId: conn.peer, isCpu: false, type: pType };
                Online.playerMap.push(newP);
                Network.broadcast({type: 'LOBBY_UPDATE', players: Online.playerMap});
            } else if (data.type === 'ACTION_SUBMIT') {
                // Client submitted action
                const senderIdx = Online.playerMap.findIndex(p => p.peerId === conn.peer);
                if(senderIdx !== -1 && players[senderIdx]) {
                    players[senderIdx].action = data.action;
                }
            }
        },
        handleClientData(data) {
            if(data.type === 'LOBBY_UPDATE') {
                Online.playerMap = data.players;
                UI.updateLobby(Online.roomCode, Online.playerMap);
            } else if (data.type === 'GAME_START') {
                myPlayerIndex = data.myIndex;
                isMultiplayer = true;
                if (data.scores) matchScores = data.scores;
                if (data.targetWins) targetWins = data.targetWins;
                window.startBattle(data.configs); // Use host configs
            } else if (data.type === 'TURN_START') {
                startTurn(); // Just UI reset
            } else if (data.type === 'TURN_RESOLVE') {
                // Apply actions from host
                data.actions.forEach((act, idx) => {
                    if(players[idx]) players[idx].action = act;
                });
                resolveActions();
            } else if (data.type === 'GAME_OVER') {
                if (data.isFinal) {
                    showMsg(data.msg, true);
                } else if (data.autoRestart) {
                    showAutoRestartMsg(data.winnerName);
                } else {
                    showMsg(data.msg, false);
                }
            }
        },
        broadcast(msg) {
            Online.connections.forEach(c => { if(c.open) c.send(msg); });
            // Host also handles it locally if needed, but usually host calls functions directly
            if(msg.type === 'LOBBY_UPDATE') UI.updateLobby(Online.roomCode, Online.playerMap);
        },
        sendHost(msg) {
            if(Online.hostConn && Online.hostConn.open) Online.hostConn.send(msg);
        },
        hostStartGame() {
            // Fill slots with CPU
            while(Online.playerMap.length < 4) {
                const isLoki = Math.random() > 0.5;
                Online.playerMap.push({ 
                    name: `BOT-${Online.playerMap.length}`, 
                    isHost: false, 
                    peerId: 'cpu-'+Math.random(), 
                    isCpu: true,
                    type: isLoki ? 'Loki' : 'Odin' // Randomize CPU
                });
            }
            
            // Assign roles based on Online.playerMap
            const configs = [
                { id: 0, x: 0, y: 50, z: 120, name: Online.playerMap[0].name, type: Online.playerMap[0].type }, // Host
                { id: 1, x: 0, y: 50, z: -110, name: Online.playerMap[1].name, type: Online.playerMap[1].type },
                { id: 2, x: 110, y: 50, z: 0, name: Online.playerMap[2].name, type: Online.playerMap[2].type },
                { id: 3, x: -110, y: 50, z: 0, name: Online.playerMap[3].name, type: Online.playerMap[3].type }
            ];

            // Reset scores on fresh start
            if (Object.keys(matchScores).length === 0 || gameState === 'IDLE') {
                matchScores = {};
                configs.forEach(p => matchScores[p.id] = 0);
            }

            // Notify everyone
            Online.playerMap.forEach((p, idx) => {
                if(p.isHost) {
                    myPlayerIndex = 0;
                    isMultiplayer = true;
                    window.startBattle(configs);
                } else if (!p.isCpu) {
                    // Send specific index to each client
                    const conn = Online.connections.find(c => c.peer === p.peerId);
                    if(conn) conn.send({ type: 'GAME_START', configs: configs, myIndex: idx, scores: matchScores, targetWins: targetWins });
                }
            });
        }
    };

    // (Helper functions for Three.js objects etc. remain same as stable version)
    // ... [Previous Helper Functions like createUnitUISprite, etc. are implicitly here] ...

    function showCardDescription(index) {
        const descEl = document.getElementById('card-description');
        const t = TRANSLATIONS[currentLang];
        const p = players[myPlayerIndex]; // Use local player
        let desc = "";
        if (!p) return;
        if (index === 2 || index === 5) desc = t.cardDescs[index][p.type];
        else desc = t.cardDescs[index];
        descEl.innerText = desc;
        descEl.style.opacity = 1;
    }

    function hideCardDescription() {
        document.getElementById('card-description').style.opacity = 0;
    }

    function updateHPUI() {
        const t = TRANSLATIONS[currentLang];
        const p = players[myPlayerIndex]; if (!p) return; // UI reflects MY player

        if (!isTutorialMode) {
            const hpLine = document.getElementById('hp-line'), fatLine = document.getElementById('fatigue-line');
            const rageLine = document.getElementById('rage-line'), defBtn = document.getElementById('defend-card'), superBtn = document.getElementById('super-card');
            if(hpLine) hpLine.innerText = `HP: ${p.hp}/${p.maxHP}`;
            if(fatLine) { fatLine.innerText = `${t.fatigue}: ${p.fatigue}%`; fatLine.style.color = p.fatigue >= 100 ? "#ff0000" : "#ffaa00"; }
            
            const curRage = Math.floor(Math.max(p.rage.red, p.rage.blue));
            if(rageLine) { rageLine.innerText = `${t.rage}: ${curRage}%`; rageLine.style.color = p.rage.red > p.rage.blue ? "#ff5555" : (p.rage.blue > p.rage.red ? "#55ccff" : "#ffaa00"); }
            if (defBtn) { if (p.fatigue >= 100) { defBtn.classList.add('disabled'); defBtn.innerText = t.tired; } else { defBtn.classList.remove('disabled'); defBtn.innerText = t.cardNames[4]; } }
            
            if (superBtn) {
                superBtn.className = "card super"; 
                if (curRage >= 99) {
                    superBtn.style.display = 'flex';
                    if (p.rage.blue > p.rage.red) { superBtn.classList.add('super-blue'); superBtn.innerText = t.cardNames[5]; }
                    else { superBtn.classList.add('super-red'); superBtn.innerText = t.cardNames[5]; }
                } else { superBtn.style.display = 'none'; }
            }
        }

        players.forEach(pl => { 
            if (pl.selectionRing) pl.selectionRing.visible = (selectedTargetId === pl.id); 
            if (pl.updateLabel) pl.updateLabel(); 
            if (pl.brokenShieldIcon) { pl.brokenShieldIcon.visible = pl.showBrokenShield; }
        });
        
        UI.updateScoreboard();
    }

    function gainRage(p, isRed, amt) { 
        // Modified to use object property primarily
        if (isRed) { p.rage.blue = 0; p.rage.red = Math.min(100, p.rage.red + amt); } 
        else { p.rage.red = 0; p.rage.blue = Math.min(100, p.rage.blue + amt); } 
        
        // Sync global if P0 (for legacy compatibility)
        if (p.id === 0) { playerRage.red = p.rage.red; playerRage.blue = p.rage.blue; }
        
        updateHPUI(); 
        if(p.updateLabel) p.updateLabel(); 
    }
    
    function loseRage(p, isRed) { 
        if (isRed) p.rage.red = Math.max(0, p.rage.red - 30); 
        else p.rage.blue = Math.max(0, p.rage.blue - 30); 
        
        if (p.id === 0) { playerRage.red = p.rage.red; playerRage.blue = p.rage.blue; }
    }

    // ... [Keep focusOnAction, cinematicIntro, createExplosion, etc. unchanged] ...
    
    // --- INTEGRATING HELPER CLASSES FROM ORIGINAL ---
    class HitParticle { constructor(pos, color) { const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true }); this.mesh = new THREE.Mesh(SHARED_BOX_GEO, mat); this.mesh.position.copy(pos); const a = Math.random() * Math.PI * 2, s = 5 + Math.random() * 5; this.velocity = new THREE.Vector3(Math.cos(a) * s, 4 + Math.random() * 6, Math.sin(a) * s); this.life = 1.0; scene.add(this.mesh); } update(dt) { this.mesh.position.add(this.velocity.clone().multiplyScalar(dt)); this.velocity.y -= 15 * dt; this.life -= dt * 1.5; this.mesh.material.opacity = this.life; if (this.life <= 0) { if(this.mesh.parent) scene.remove(this.mesh); if(this.mesh.material) this.mesh.material.dispose(); return false; } return true; } }
    class OptimizedLightningBolt { constructor(s, e, c=0x00ffff) { this.s=s.clone(); this.e=e.clone(); this.c=c; this.l=6; this.g=new THREE.Group(); scene.add(this.g); this.m=new THREE.MeshBasicMaterial({color:c,transparent:true}); this.gen(); } gen() { while(this.g.children.length>0){this.g.remove(this.g.children[0]);} const pts=[]; for(let i=0;i<=8;i++){ let p=new THREE.Vector3().lerpVectors(this.s,this.e,i/8); if(i>0&&i<8){ p.addScalar((Math.random()-0.5)*20); } pts.push(p); } for(let i=0;i<pts.length-1;i++){ const d=pts[i].distanceTo(pts[i+1]); const m=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,d),this.m); m.position.lerpVectors(pts[i],pts[i+1],0.5); m.lookAt(pts[i+1]); this.g.add(m); } this.m.color.setHex(Math.random()>0.4?0xffffff:this.c); } update() { this.l--; if(this.l>0){this.gen();return true;} else{scene.remove(this.g); return false;} } }
    class SuperAura { constructor(p) { this.active=false; this.g=new THREE.Group(); this.g.position.y=2.5; p.add(this.g); this.core=new THREE.Mesh(new THREE.IcosahedronGeometry(3,1),new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.3,blending:2})); this.g.add(this.core); this.spikes=new THREE.Mesh(new THREE.IcosahedronGeometry(3.5,0),new THREE.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.4,blending:2})); this.g.add(this.spikes); this.g.visible=false; this.t=0; } activate(r) { this.active=true; this.g.visible=true; const c=r?0xff3300:0x0088ff; this.spikes.material.color.setHex(c); this.core.material.color.setHex(r?0xffffaa:0xaaffff); } deactivate() { this.active=false; this.g.visible=false; } update(dt) { if(!this.active)return; this.t+=dt*15; const s=1+Math.sin(this.t)*0.05; this.spikes.scale.set(s,s,s); this.spikes.rotation.y+=dt*3; } }
    class MeatDrop { constructor(t,s=1, isSuper=false){this.m=createMeatModelShared(s);this.m.position.set(t.x,t.y+400,t.z);this.ty=t.y;this.v=0;this.e=false;this.isSuper=isSuper;scene.add(this.m);} update(dt){if(this.e)return false;this.v+=900*dt;this.m.position.y-=this.v*dt;this.m.rotation.y+=dt*5;if(this.m.position.y<=this.ty){this.m.position.y=this.ty;this.expl();return false;}return true;} expl(){if(this.e)return;this.e=true;const scale=this.isSuper?3.0:1.0;createExplosion(this.m.position,scale);if(this.m.parent)scene.remove(this.m);} }
    class ParabolicMeatProjectile { constructor(s,e){this.s=s.clone();this.e=e.clone();this.m=createMeatModelShared(7.0);scene.add(this.m);this.p=0;} update(dt){if(this.p>=1){if(this.m.parent)scene.remove(this.m);createExplosion(this.m.position, 3.0); return false;}this.p+=dt/0.8;const c=new THREE.Vector3().lerpVectors(this.s,this.e,this.p);c.y+=Math.sin(this.p*Math.PI)*150;this.m.position.copy(c);this.m.rotation.x+=dt*10;return true;} }
    
    function createUnitUISprite() { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 256; const texture = new THREE.CanvasTexture(canvas); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false })); sprite.scale.set(12, 6, 1); sprite.renderOrder = 999; return { sprite, canvas, ctx, texture }; }
    function createBrokenShieldTexture() { const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.moveTo(30, 30); ctx.lineTo(226, 30); ctx.quadraticCurveTo(226, 150, 128, 240); ctx.quadraticCurveTo(30, 150, 30, 30); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#880000'; ctx.beginPath(); ctx.moveTo(50, 50); ctx.lineTo(206, 50); ctx.quadraticCurveTo(206, 140, 128, 220); ctx.quadraticCurveTo(50, 140, 50, 50); ctx.closePath(); ctx.fill(); ctx.globalCompositeOperation = 'destination-out'; ctx.lineWidth = 30; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(140, 10); ctx.lineTo(100, 90); ctx.lineTo(160, 140); ctx.lineTo(110, 250); ctx.stroke(); ctx.globalCompositeOperation = 'source-over'; ctx.font = 'bold 36px "Microsoft JhengHei", sans-serif'; ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 4; if(currentLang === 'zh-TW') { ctx.fillText('é˜²ç¦¦', 128, 110); ctx.fillText('ç–²å‹ä¸­', 128, 150); } else { ctx.font = 'bold 28px "Arial", sans-serif'; ctx.fillText('FATIGUED', 128, 130); } return new THREE.CanvasTexture(canvas); }
    function createTextSprite(text) { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 512; canvas.height = 128; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(20, 20, 472, 88); ctx.font = 'bold 50px "Microsoft JhengHei", Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#ff99cc'; ctx.fillText(text, 256, 85); const texture = new THREE.CanvasTexture(canvas); return new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true })); }
    function createShockwave(pos, color) { const m = new THREE.Mesh(new THREE.RingGeometry(1, 2, 64), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1, side: THREE.DoubleSide })); m.position.copy(pos); m.rotation.x = Math.PI / 2; const expand = () => { m.scale.x += 4; m.scale.y += 4; m.material.opacity -= 0.05; if(m.material.opacity > 0) requestAnimationFrame(expand); else if(m.parent) scene.remove(m); }; expand(); return m; }
    function createExplosion(pos, scale=1.0) { const g = new THREE.Group(); const shock = createShockwave(pos, 0xffaa00); g.add(shock); g.position.copy(pos); shock.position.set(0,0,0); const count = Math.floor(40 * scale); for(let i=0; i<count; i++) { activeParticles.push(new HitParticle(pos.clone(), i % 2 === 0 ? 0xff4400 : 0xffff00)); } g.scale.set(scale, scale, scale); SoundEngine.play('super'); scene.add(g); return g; }
    function applyKnockback(char, sourcePos) { if(!sourcePos) return; const dir = char.group.position.clone().sub(sourcePos).normalize(); dir.y = 0; const originalPos = char.group.position.clone(); const backPos = originalPos.clone().add(dir.multiplyScalar(25)); move(char.group, backPos, 100).then(() => { sleep(50).then(() => move(char.group, originalPos, 200)); }); }
    function createMagnetModel() { const group = new THREE.Group(); const redMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }), blueMat = new THREE.MeshPhongMaterial({ color: 0x0000ff }), silverMat = new THREE.MeshPhongMaterial({ color: 0xcccccc }); const bar1 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), redMat); bar1.position.set(-3, 3, 0); group.add(bar1); const bar2 = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), blueMat); bar2.position.set(3, 3, 0); group.add(bar2); const connector = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 2), silverMat); connector.position.set(0, 0, 0); group.add(connector); group.scale.set(2,2,2); return group; }
    function createMeatModelShared(scale = 1) { const g = new THREE.Group(); const meat = new THREE.Mesh(new THREE.BoxGeometry(3.5 * scale, 2.5 * scale, 2.5 * scale), new THREE.MeshPhongMaterial({ color: 0xaa2222 })); meat.position.y = 1 * scale; meat.castShadow = true; g.add(meat); const bone = new THREE.Mesh(new THREE.BoxGeometry(6 * scale, 0.6 * scale, 0.6 * scale), new THREE.MeshPhongMaterial({ color: 0xeeeeee })); bone.position.y = 1 * scale; bone.castShadow = true; g.add(bone); const cutMat = new THREE.MeshBasicMaterial({ color: 0xffaaaa }); const cL = new THREE.Mesh(new THREE.PlaneGeometry(2.3 * scale, 2.3 * scale), cutMat), cR = cL.clone(); cL.position.set(-1.76 * scale, 1 * scale, 0); cL.rotation.y = Math.PI/2; cR.position.set(1.76 * scale, 1 * scale, 0); cR.rotation.y = Math.PI/2; g.add(cL, cR); return g; }
    function getRandomTarget(sid) { const os = players.filter(p => p.id !== sid && p.alive); return os.length ? os[Math.floor(Math.random()*os.length)].id : -1; }

    // --- CHARACTER CLASS ---
    class Odin {
        constructor(cfg) {
            this.id = cfg.id; this.name = cfg.name; this.type = cfg.type || 'Odin';
            this.maxHP = (this.type === 'Loki' ? MAX_HP_LOKI : MAX_HP_ODIN);
            this.hp = this.maxHP; this.alive = true; this.rage = { red: 0, blue: 0 }; 
            this.fatigue = 0; this.defendHitCount = 0; this.showBrokenShield = false; 
            
            this.action = { card: -1, target: -1, selectionTime: 0 }; this.targetQuaternion = null;
            this.group = new THREE.Group(); this.group.position.set(cfg.x, cfg.y, cfg.z);
            this.group.userData = { isCharacter: true, playerId: cfg.id }; this.group.scale.set(8, 8, 8);
            this.aura = new SuperAura(this.group);
            this.ballRotationMultiplier = 1.0; 

            const hitGeo = new THREE.BoxGeometry(14, 25, 14); const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            this.hitBox = new THREE.Mesh(hitGeo, hitMat); this.hitBox.position.y = 5; this.group.add(this.hitBox);
            const uiData = createUnitUISprite(); this.uiSprite = uiData.sprite; this.uiCtx = uiData.ctx; this.uiTexture = uiData.texture;
            this.uiSprite.position.y = 8.5; this.group.add(this.uiSprite);
            
            const shieldTex = createBrokenShieldTexture(); const shieldMat = new THREE.SpriteMaterial({ map: shieldTex, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false });
            this.brokenShieldIcon = new THREE.Sprite(shieldMat); this.brokenShieldIcon.scale.set(8, 8, 1); this.brokenShieldIcon.position.set(0, 14, 0); 
            this.brokenShieldIcon.renderOrder = 998; this.brokenShieldIcon.visible = false; this.group.add(this.brokenShieldIcon);

            this.labelSprite = createTextSprite(this.getDisplayName()); this.labelSprite.position.y = -3.5; this.labelSprite.scale.set(10, 2.5, 1); this.group.add(this.labelSprite);
            this.modelContainer = new THREE.Group(); this.group.add(this.modelContainer);
            
            // ... Model Geometry (Simplified for brevity, same as original) ...
            const bodyColor = (this.type === 'Loki' ? 0x0a4a0a : 0xffcc00);
            this.body = new THREE.Mesh(new THREE.BoxGeometry(2.1, 2, 2.5), new THREE.MeshPhongMaterial({ color: bodyColor }));
            this.body.position.y = 1; this.body.castShadow = true; this.modelContainer.add(this.body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.8, 1.6), new THREE.MeshPhongMaterial({ color: 0xffdbac }));
            head.position.set(0, 2.5, 0.5); head.castShadow = true; this.modelContainer.add(head);
            this.snout = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.6), new THREE.MeshPhongMaterial({ color: 0xffaaaa }));
            this.snout.position.set(0, 2.3, 1.35); this.snout.castShadow = true; this.modelContainer.add(this.snout);
            const nL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), new THREE.MeshBasicMaterial({color:0x000000})), nR = nL.clone();
            nL.position.set(-0.25, 0.1, 0.35); nR.position.set(0.25, 0.1, 0.35); this.snout.add(nL, nR);
            const earL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.2), new THREE.MeshPhongMaterial({color: 0xffaaaa})), earR = earL.clone();
            earL.position.set(-1.0, 3.2, 0.5); earL.rotation.z = 0.6; earR.position.set(1.0, 3.2, 0.5); earR.rotation.z = -0.6;
            earL.castShadow = true; earR.castShadow = true; this.modelContainer.add(earL, earR);

            if (this.type === 'Loki') {
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d'); const cols = ['#ff3333', '#33ff33', '#ffffff', '#3333ff']; 
                for(let i=0; i<4; i++) for(let j=0; j<4; j++) { ctx.fillStyle = cols[(i + j) % 4]; ctx.fillRect(i * 64, j * 64, 64, 64); ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(i * 64, j * 64, 64, 64); }
                const ballTex = new THREE.CanvasTexture(canvas); ballTex.wrapS = ballTex.wrapT = THREE.RepeatWrapping; ballTex.repeat.set(2, 2);
                this.ball = new THREE.Mesh(new THREE.SphereGeometry(1.4, 16, 12), new THREE.MeshPhongMaterial({ map: ballTex }));
                this.ball.position.y = -0.4; this.ball.castShadow = true; this.modelContainer.add(this.ball);
                this.modelContainer.position.y = 1.4;
            }

            this.weaponGroup = new THREE.Group();
            if (this.type === 'Odin') {
                const shape = new THREE.Shape();
                shape.moveTo(0, 0); shape.lineTo(0.5, 2); shape.lineTo(-0.2, 1.8); shape.lineTo(0.4, 3.5);
                shape.lineTo(-0.3, 3.2); shape.lineTo(0.6, 6); shape.lineTo(-0.1, 3.8); shape.lineTo(0.5, 4.2);
                shape.lineTo(-0.1, 2.2); shape.lineTo(0.4, 2.5); shape.lineTo(0, 0);
                this.weaponMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.3, bevelEnabled: false }), new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffd700, emissiveIntensity: 2 }));
                this.weaponMesh.position.set(-0.2, -1, 0); this.weaponMesh.castShadow = true; this.weaponGroup.add(this.weaponMesh); 
            }
            this.weaponGroup.position.set(1.5, 1.2, 0.5); this.weaponGroup.rotation.x = -Math.PI/4; this.modelContainer.add(this.weaponGroup);
            this.hexShield = new THREE.Group();
            const hexColor = (this.type === 'Loki' ? 0xff0000 : 0x00ffff);
            const hexStar = new THREE.Mesh(this.createStarGeometry(), new THREE.MeshBasicMaterial({ color: hexColor, transparent: true, opacity: 0.6, side: THREE.DoubleSide }));
            this.hexShield.add(hexStar); 
            for (let i = 0; i < 6; i++) {
                const rune = this.createRuneLine(), angle = (i / 6) * Math.PI * 2;
                rune.position.set(Math.cos(angle) * 3.5, Math.sin(angle) * 3.5, 0.1); rune.rotation.z = angle; this.hexShield.add(rune);
            }
            const centralRune = this.createAlgizRune(); centralRune.scale.set(2, 2, 2); this.hexShield.add(centralRune);
            this.hexShield.position.set(0, 3, 3); this.hexShield.visible = false; this.group.add(this.hexShield);
            this.meatBlock = createMeatModelShared(); this.meatBlock.visible = false; this.group.add(this.meatBlock);
            this.selectionRing = new THREE.Mesh(new THREE.TorusGeometry(5, 0.4, 16, 64), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.9 }));
            this.selectionRing.rotation.x = Math.PI/2; this.selectionRing.position.y = -1.5; this.selectionRing.visible = false; this.group.add(this.selectionRing);
            
            this.targetLabel = createTextSprite(TRANSLATIONS[currentLang].targetLocked); this.targetLabel.scale.set(6, 1.5, 1); this.targetLabel.position.y = -6; this.targetLabel.visible = false; this.group.add(this.targetLabel);
            scene.add(this.group); this.face(new THREE.Vector3(0,cfg.y,0)); this.updateLabel();
        }

        getDisplayName() {
             const t = TRANSLATIONS[currentLang];
             if (isTutorialMode) {
                return (this.id === 0) ? t.tutorialName : (this.id === 2 ? t.civilian : t.dummyName);
             } else {
                 const charPrefix = (this.type === 'Odin' ? t.charOdin : t.charLoki);
                 // Format: (CharName) PlayerName
                 let baseName = `(${charPrefix}) `;
                 
                 // If name already contains prefix, avoid double? user enters raw name usually.
                 // If multiplayer and is CPU:
                 if (this.name.startsWith("BOT-")) {
                     baseName += `CPU${this.id}`; // Simplified CPU name
                 } else {
                     baseName += this.name;
                 }
                 
                 return baseName;
             }
        }
        refreshLabel() { if(this.labelSprite) { this.labelSprite.material.map.dispose(); this.labelSprite.material.map = createTextSprite(this.getDisplayName()).material.map; } if(this.brokenShieldIcon) { this.brokenShieldIcon.material.map.dispose(); this.brokenShieldIcon.material.map = createBrokenShieldTexture(); } if(this.targetLabel) { this.targetLabel.material.map.dispose(); this.targetLabel.material.map = createTextSprite(TRANSLATIONS[currentLang].targetLocked).material.map; } }
        createStarGeometry() { const s = new THREE.Shape(); const o=5.5, n=2.8; for(let i=0; i<12; i++){ const a=(i/12)*Math.PI*2, r=(i%2===0)?o:n; if(i===0) s.moveTo(Math.cos(a)*r, Math.sin(a)*r); else s.lineTo(Math.cos(a)*r, Math.sin(a)*r); } s.closePath(); return new THREE.ShapeGeometry(s); }
        createRuneLine() { const pts = [new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0.5, 0, 0), new THREE.Vector3(0, 0.5, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffffff })); }
        createAlgizRune() { const pts = [new THREE.Vector3(0, -0.8, 0), new THREE.Vector3(0, 0.8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-0.6, 0.6, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0.6, 0.6, 0)]; const geo = new THREE.BufferGeometry().setFromPoints(pts); return new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })); }
        
        updateLabel() { if (!this.uiCtx) return; const ctx = this.uiCtx; ctx.clearRect(0, 0, 512, 256); const t = TRANSLATIONS[currentLang]; if (!this.alive) { ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(50, 40, 412, 160); ctx.font = 'bold 80px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = '#ff99cc'; ctx.fillText(t.dead, 256, 150); this.uiTexture.needsUpdate = true; return; } const r = this.rage, u = Math.floor(Math.max(r.red, r.blue)); ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(50, 40, 412, 160); ctx.font = 'bold 36px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = 'white'; ctx.fillText(`HP: ${this.hp}/${this.maxHP}  ${t.rage}: ${u}%`, 256, 85); ctx.fillStyle = '#1a1a1a'; ctx.fillRect(80, 110, 352, 20); ctx.fillStyle = '#2ecc71'; ctx.fillRect(80, 110, 352 * (this.hp/this.maxHP), 20); ctx.fillStyle = '#1a1a1a'; ctx.fillRect(80, 145, 352, 15); ctx.fillStyle = (r.red > r.blue) ? '#ff5555' : (r.blue > r.red ? '#55ccff' : '#ffaa00'); ctx.fillRect(80, 145, 352 * (u/100), 15); this.uiTexture.needsUpdate = true; }
        face(pos) { if (!this.alive) return; const lp = pos.clone(); lp.y = this.group.position.y; const dummy = new THREE.Object3D(); dummy.position.copy(this.group.position); dummy.lookAt(lp); this.targetQuaternion = dummy.quaternion.clone(); }
        takeDamage(amt, type = 0, sourcePos = null) { this.hp = Math.max(0, this.hp - Math.floor(amt)); SoundEngine.play('hit'); const pColor = (type === 0) ? 0xffaa00 : (type === 1 ? 0x00ffff : 0xff0044); for(let i=0; i<15; i++) activeParticles.push(new HitParticle(this.group.position.clone().add(new THREE.Vector3(0, 10, 0)), pColor)); if (sourcePos) { applyKnockback(this, sourcePos); } if (this.hp <= 0 && this.alive) { this.alive = false; this.modelContainer.visible = false; this.meatBlock.visible = true; log(`${this.name} ` + TRANSLATIONS[currentLang].dead); } this.updateLabel(); updateHPUI(); }
    }

    // --- GAME LOGIC ---
    // ä¿®æ­£ï¼šå¢åŠ  isSuper åƒæ•¸ä¾†é˜»æ­¢å¥§ç¾©ç²å–æ€’æ°£
    function calcDamage(a, t, type, isSuper = false, skipFatigue = false) { 
        if (!t || !t.alive) return; 
        const txt = TRANSLATIONS[currentLang]; 
        let dmg = (a.type === 'Loki') ? (type === 0 ? (isSuper ? 70 : 45) : (isSuper ? t.maxHP*0.5 : 65)) : (type === 0 ? (isSuper ? 60 : 40) : (isSuper ? t.maxHP*0.5 : 50)); 
        
        // é¡¯ç¤ºå‚·å®³æ•¸å­—
        // è‹¥æ˜¯è¢«é˜²ç¦¦ï¼Œå‰‡å‚·å®³å¯èƒ½ä¸åŒæˆ–ç‚º 0ï¼Ÿç›®å‰é‚è¼¯é˜²ç¦¦æ˜¯æ¸›å‚·æ©Ÿåˆ¶ä¸æ˜ç¢ºï¼Œç›´æ¥åœ¨ä¸‹é¢è™•ç†
        
        if (isSuper) { 
            createExplosion(t.group.position.clone().add(new THREE.Vector3(0, 15, 0)), 2.5); 
            // å¥§ç¾©ç›´æ¥å‘½ä¸­ï¼Œä¸åå½ˆä¸åæ“Š (é™¤äº†Lokiç‰©å¥§ç¬¬äºŒæ¬¡æ˜¯ç®—æ™®æ”»? Code says calcDamage(..., 0, true) so it is type 0)
            // ä¸éä¸‹é¢æœ‰è™•ç† counter/reflect å¤±æ•—çš„ log
        } else { 
            // æ™®é€šæ”»æ“Šçš„åæ“Š/åå°„åˆ¤å®š
            if (type === 0 && t.action.card === 2) { 
                if (t.type === 'Loki') return; // Loki is Swap
                // Odin Counter Success
                loseRage(a, true); 
                let counterDmg = 65;
                a.takeDamage(counterDmg, 0, t.group.position); 
                spawnDamageNumber(a, counterDmg);
                showMove(`[${t.getDisplayName()}] åæ“Šï¼ -> ${a.getDisplayName()} ${counterDmg} Dmg!`);
                if (t.type === 'Odin') gainRage(t, true, 20); 
                return; 
            } 
            if (type === 1 && t.action.card === 3) { 
                loseRage(a, false); 
                let reflectDmg = Math.floor(dmg*0.8);
                a.takeDamage(reflectDmg, 2, t.group.position); 
                spawnDamageNumber(a, reflectDmg);
                showMove(`[${t.getDisplayName()}] åå°„ï¼ -> ${a.getDisplayName()} ${reflectDmg} Dmg!`);
                gainRage(t, false, 20); 
                return; 
            } 
        } 
        
        if (t.action.card === 4) { 
            if (!skipFatigue) { 
                t.defendHitCount++; let fatigueAdd = 0; 
                if (t.defendHitCount === 2) fatigueAdd = 20; 
                else if (t.defendHitCount > 2) fatigueAdd = 10; 
                if (isSuper) fatigueAdd += 15; 
                if (fatigueAdd > 0) t.fatigue = Math.min(150, t.fatigue + fatigueAdd); 
            } 
            t.blockedInTurn = true; SoundEngine.play('ding'); 
            spawnDamageNumber(t, "Blocked");
            showMove(`[${t.getDisplayName()}] ${txt.logBlock}!`);
            updateHPUI(); return; 
        } 
        
        // å¯¦éš›é€ æˆå‚·å®³
        loseRage(t, type === 0); 
        t.takeDamage(dmg, type, a.group.position); 
        spawnDamageNumber(t, dmg);
        
        // æ›´æ–°é ‚éƒ¨é¡¯ç¤ºï¼šA å° B é€ æˆ xxx å‚·å®³
        let skillName = "æ”»æ“Š";
        if (isSuper) skillName = "å¥§ç¾©";
        else if (type === 0) skillName = "ç‰©ç†æ”»æ“Š";
        else if (type === 1) skillName = "é­”æ³•æ”»æ“Š";
        
        showMove(`${a.getDisplayName()} å° ${t.getDisplayName()} ä½¿ç”¨ ${skillName}, é€ æˆ ${dmg} å‚·å®³!`);
        
        // ä¿®æ­£ï¼šå¦‚æœæ˜¯å¥§ç¾©ï¼Œä¸å¢åŠ æ€’æ°£
        if (!isSuper) {
            gainRage(a, type === 0, 35); 
        }
    }

    async function focusOnAction(char1, char2 = null, dur = 600) { 
        if (!char1) return; 
        let tCenter, camTarget; 
        if (char2) { 
            const p1 = char1.group.position.clone(), p2 = char2.group.position.clone(); 
            const d = p1.distanceTo(p2); 
            tCenter = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5); 
            
            // Camera Adjustment for Closeup: Higher and Tighter
            // Old: 250 + d*zoom, 450 + d*0.85
            // New: Move camera closer to action center, but higher up as requested (5 units relative adjust)
            // Adjust to be "5 heights" approx -> 40 (unit size) * 5 = 200
            
            const zoomFactor = (window.innerWidth / window.innerHeight) > 1 ? 0.5 : 0.4; 
            camTarget = tCenter.clone().add(new THREE.Vector3(0, 180 + d * zoomFactor, 250 + d * 0.6)); 
        } else { 
            tCenter = char1.group.position.clone(); 
            camTarget = tCenter.clone().add(new THREE.Vector3(0, 200, 300)); // Slightly closer/higher for solo action
        } 
        
        return new Promise(res => { 
            let sPos = camera.position.clone(); 
            let start = performance.now(); 
            function up() { 
                let p = Math.min(1, (performance.now() - start) / dur); 
                camera.position.lerpVectors(sPos, camTarget, p); 
                camera.lookAt(tCenter); 
                if (p < 1) requestAnimationFrame(up); else res(); 
            } 
            up(); 
        }); 
    }

    async function cinematicIntro(attacker, skillName) { const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(attacker.group.quaternion); const focusPos = attacker.group.position.clone().add(forward.multiplyScalar(150)); focusPos.y += 20; await new Promise(res => { let sPos = camera.position.clone(); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 400); camera.position.lerpVectors(sPos, focusPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); showMove(skillName); SoundEngine.play('click'); await sleep(500); return new Promise(res => { let sPos = camera.position.clone(); let zoomOutPos = attacker.group.position.clone().add(new THREE.Vector3(0, 240, 350)); let start = performance.now(); function up() { let p = Math.min(1, (performance.now() - start) / 1000); camera.position.lerpVectors(sPos, zoomOutPos, p); camera.lookAt(attacker.group.position); if (p < 1) requestAnimationFrame(up); else res(); } up(); }); }
    
    // Attack functions (Shortened for brevity but functionality preserved)
    async function performAttack(attacker, target, type) { 
        if (!attacker || !target) return; const tp = target.group.position.clone(), orig = attacker.group.position.clone(); 
        if (type === 0 && target.action.card === 2 && target.type === 'Odin') { const strikePos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); await move(attacker.group, strikePos, 200); SoundEngine.play('magic'); target.group.visible = false; showMove("Spank!"); const behindPos = attacker.group.position.clone().add(target.group.position.clone().sub(attacker.group.position).normalize().multiplyScalar(-45)); target.group.position.copy(behindPos); target.face(attacker.group.position); target.group.visible = true; target.weaponGroup.rotation.z = 1.8; SoundEngine.play('counter'); await sleep(300); calcDamage(attacker, target, 0); gainRage(target, true, 20); await sleep(500); target.weaponGroup.rotation.z = 0; hideMove(); await move(attacker.group, orig, 400); target.group.position.copy(tp); target.face(attacker.group.position); return; } 
        if (type === 0 && target.action.card === 2 && target.type === 'Loki') { const victims = players.filter(p => p && p.alive && p.id !== target.id && p.id !== attacker.id); if (victims.length >= 1) { log(`${target.name} Swap!`); const victim = victims[Math.floor(Math.random()*victims.length)]; showMove("Swap!"); await sleep(800); const lokiOrigPos = target.group.position.clone(), victimOrigPos = victim.group.position.clone(); const magnet = createMagnetModel(); magnet.position.copy(target.group.position).add(new THREE.Vector3(0, 15, 10)); scene.add(magnet); SoundEngine.play('magic'); showMove("!!!"); const backDir = target.group.position.clone().sub(attacker.group.position).normalize(); const backPos = lokiOrigPos.clone().add(backDir.multiplyScalar(40)); await Promise.all([move(victim.group, lokiOrigPos, 1200), move(target.group, backPos, 1200)]); hideMove(); const strikePos = lokiOrigPos.clone().add(orig.clone().sub(lokiOrigPos).normalize().multiplyScalar(45)); if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 10.0; await sleep(600); await move(attacker.group, strikePos, 150); } else { await move(attacker.group, strikePos, 250); attacker.weaponGroup.rotation.z = 0.8; } SoundEngine.play(attacker.type === 'Loki' ? 'hit' : 'slash'); loseRage(attacker, true); let dmg = (attacker.type === 'Loki') ? (Math.floor(Math.random() * 21) + 35) : (Math.floor(Math.random() * 21) + 30); victim.takeDamage(dmg, 0, attacker.group.position); await sleep(500); if (attacker.type === 'Odin') attacker.weaponGroup.rotation.z = 0; if (attacker.type === 'Loki') attacker.ballRotationMultiplier = 1.0; await move(attacker.group, orig, 500); scene.remove(magnet); await Promise.all([move(target.group, lokiOrigPos, 1200), move(victim.group, victimOrigPos, 1200)]); return; } } 
        if (type === 0) { if (attacker.type === 'Loki') { attacker.ballRotationMultiplier = 10.0; await sleep(600); const sPos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); await move(attacker.group, sPos, 150); SoundEngine.play('hit'); calcDamage(attacker, target, 0); await sleep(300); attacker.ballRotationMultiplier = 1.0; await move(attacker.group, orig, 500); } else { const sPos = tp.clone().add(orig.clone().sub(tp).normalize().multiplyScalar(45)); await move(attacker.group, sPos, 250); attacker.weaponGroup.rotation.z = 0.8; SoundEngine.play('slash'); calcDamage(attacker, target, 0); await sleep(300); attacker.weaponGroup.rotation.z = 0; await move(attacker.group, orig, 500); } } else { if (attacker.type === 'Loki') { const throwStart = attacker.group.position.clone().add(new THREE.Vector3(0, 30, 0)), throwEnd = target.group.position.clone().add(new THREE.Vector3(0, 20, 0)); activeProjectiles.push(new ParabolicMeatProjectile(throwStart, throwEnd)); SoundEngine.play('magic'); await sleep(800); } else { const mouthPos = attacker.group.position.clone().add(new THREE.Vector3(0, 25, 0)); const burst = setInterval(() => { activeLightnings.push(new OptimizedLightningBolt(mouthPos, target.group.position.clone().add(new THREE.Vector3(0,25,0)))); SoundEngine.play('magic'); }, 150); await sleep(800); clearInterval(burst); } if (target.action.card === 3 && type === 1) { await focusOnAction(target, attacker, 400); if (target.type === 'Odin') { target.weaponGroup.rotation.z = 1.2; await move(target.weaponGroup, new THREE.Vector3(0,0,5), 100); showMove(CARD_NAMES[3]); for (let i = 0; i < 12; i++) { setTimeout(() => { activeLightnings.push(new OptimizedLightningBolt(target.group.position.clone().add(new THREE.Vector3(0,25,0)), attacker.group.position.clone().add(new THREE.Vector3(0,25,0)), 0xff0000)); SoundEngine.play('magic'); }, i * 50); } await sleep(1000); await move(target.weaponGroup, new THREE.Vector3(0,0,0), 100); target.weaponGroup.rotation.z = 0; hideMove(); } else if (target.type === 'Loki') { log(`${target.name} ${CARD_NAMES[3]}!`); target.ballRotationMultiplier = 15.0; await sleep(1000); const originalBallPos = target.ball.position.clone(); const worldPosAttacker = new THREE.Vector3(); attacker.group.getWorldPosition(worldPosAttacker); worldPosAttacker.y += 30; await new Promise(res => { const start = target.ball.position.clone(), localTarget = target.modelContainer.worldToLocal(worldPosAttacker.clone()), t = performance.now(); function fly() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(start, localTarget, p); if (p < 1) requestAnimationFrame(fly); else res(); } fly(); }); SoundEngine.play('hit'); createExplosion(attacker.group.position, 2.0); await new Promise(res => { const start = target.ball.position.clone(), t = performance.now(); function back() { let p = Math.min(1, (performance.now() - t) / 300); target.ball.position.lerpVectors(start, originalBallPos, p); if (p < 1) requestAnimationFrame(back); else res(); } back(); }); target.ballRotationMultiplier = 1.0; } SoundEngine.play('counter'); await sleep(1000); } calcDamage(attacker, target, 1); } 
    }
    async function performLightningStorm(p) { log(`<b>${p.name} Ult!</b>`); SoundEngine.play('super'); const targets = players.filter(o => o && o.id !== p.id && o.alive); if (p.type === 'Loki') { p.takeDamage(p.maxHP * 0.25, 2); for(let i=0; i<3; i++) { targets.forEach(t => activeProjectiles.push(new MeatDrop(t.group.position, 8.75, true))); await sleep(400); } await sleep(600); targets.forEach(t => calcDamage(p, t, 1, true)); } else { const pullBackPos = new THREE.Vector3(0, 450, 650), pullBackCenter = new THREE.Vector3(0, 40, 0), originalCamPos = camera.position.clone(); await new Promise(res => { let s = performance.now(); function up() { let pv = Math.min(1, (performance.now() - s) / 800); camera.position.lerpVectors(originalCamPos, pullBackPos, pv); camera.lookAt(pullBackCenter); if (pv < 1) requestAnimationFrame(up); else res(); } up(); }); await sleep(300); for (let i = 0; i < 8; i++) { targets.forEach(t => { const sY = t.group.position.clone().add(new THREE.Vector3((Math.random()-0.5)*30, 500, (Math.random()-0.5)*30)); activeLightnings.push(new OptimizedLightningBolt(sY, t.group.position)); }); SoundEngine.play('magic'); await sleep(150); } await sleep(400); targets.forEach(t => calcDamage(p, t, 1, true)); await sleep(400); resetCamera(); } }
    
    // ä¿®æ­£ï¼šLoki ç‰©å¥§æ”¹å›å–®é«”æ”»æ“Š
    async function performPhysicalSuper(attacker, target) { 
        log(`<b>${attacker.name} Ult!</b>`); SoundEngine.play('super'); 
        const op = attacker.group.position.clone(); 
        
        // Ensure target exists
        if (!target) return;
        const tp = target.group.position.clone();

        if (attacker.type === 'Loki') { 
            // Loki: å–®é«”ä¾†å›è¡æ’
            attacker.ballRotationMultiplier = 15.0; 
            
            const vec = tp.clone().sub(op).normalize();
            // ç¬¬ä¸€æ“Šï¼šæ­£é¢è²«ç©¿åˆ°èº«å¾Œ
            const behindPos = tp.clone().add(vec.clone().multiplyScalar(40)); 
            // ç¬¬äºŒæ“Šï¼šå¾èº«å¾Œè¡å‘å°æ‰‹ï¼ˆåœåœ¨èº«å¾Œ 5 èº«ä½è™•æ’æ“Šï¼‰
            const hitBackPos = tp.clone().add(vec.clone().multiplyScalar(5)); 
            
            // 1. Front -> Behind
            await move(attacker.group, behindPos, 250);
            calcDamage(attacker, target, 0, true);
            createExplosion(tp, 1.5);
            SoundEngine.play('hit');
            await sleep(100);

            // 2. Behind -> HitBack -> Behind
            await move(attacker.group, hitBackPos, 200);
            calcDamage(attacker, target, 0, true, true); 
            SoundEngine.play('hit');
            await move(attacker.group, behindPos, 200);
            await sleep(100);

            // 3. Behind -> Front (Pierce back)
            // ç‚ºäº†è¦–è¦ºæ•ˆæœï¼Œé€™æ“Šç›´æ¥è¡å›åŸé»ï¼Œæˆ–è¡åˆ°å°æ‰‹å‰æ–¹
            const frontPos = tp.clone().sub(vec.clone().multiplyScalar(40));
            await move(attacker.group, frontPos, 250);
            calcDamage(attacker, target, 0, true);
            SoundEngine.play('hit');
            createExplosion(tp, 1.5);
            await sleep(100);

            // End: å›åˆ°åŸé»
            attacker.ballRotationMultiplier = 1.0; 
            await move(attacker.group, op, 500); 
        } else { 
            // Odin: Single Target Combo
            for (let i = 0; i < 3; i++) { 
                const strikePos = tp.clone().add(op.clone().sub(tp).normalize().multiplyScalar(40)); 
                await move(attacker.group, strikePos, 150); 
                calcDamage(attacker, target, 0, true, i > 0); 
                await sleep(100); 
            } 
            await move(attacker.group, op, 400); 
        } 
    }

    async function resolveActions() { 
        const pMap = { 4: 0, 3: 0, 5: 1, 0: 2, 1: 2, 2: 3 }; 
        const q = players.filter(p => p && p.alive).sort((a, b) => (pMap[a.action.card]??5) - (pMap[b.action.card]??5)); 
        let localDemoId = currentDemoId; 
        if (!isTutorialMode) {
            showMove(TRANSLATIONS[currentLang].lockingTargets);
            await sleep(1200);
            hideMove();
            await sleep(300);
        }

        for (let p of q) { 
            if (localDemoId !== currentDemoId) return;
            if (!p || !p.alive) continue; 
            
            const t = players.find(x => x && x.id === p.action.target);
            const cid = p.action.card; 
            
            // Detailed Announcer Logic
            let skillText = "";
            let targetName = t ? t.getDisplayName() : "";
            if (cid === 4) { skillText = `[${p.getDisplayName()}] ${CARD_NAMES[4]}!`; }
            else if (cid === 3) { skillText = `[${p.getDisplayName()}] ${CARD_NAMES[3]}!`; }
            else if (cid === 2) { skillText = `[${p.getDisplayName()}] ${CARD_NAMES[2]}!`; }
            else if (cid === 5) {
                const isR = (p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99);
                if (isR) skillText = `[${p.getDisplayName()}] ${TRANSLATIONS[currentLang].tutCardNames[5]} @ ${targetName}!`;
                else skillText = `[${p.getDisplayName()}] ${TRANSLATIONS[currentLang].tutCardNames[6]}!`;
            }
            else if (cid >= 0) {
                 skillText = `[${p.getDisplayName()}] ${CARD_NAMES[cid]} @ ${targetName}!`;
            }
            
            if (cid === 4 || cid === 2 || cid === 3) { 
                showMove(skillText); SoundEngine.play('click'); await sleep(1000); 
            } else if (cid >= 0) { 
                await cinematicIntro(p, skillText); // Use Detailed Text
            } 
            
            if (localDemoId !== currentDemoId) return; 

            // Handle invalid targets
            if (!t || !t.alive) { 
                if (cid >= 0 && cid !== 4 && cid !== 2 && cid !== 3 && cid !== 5) { // 5 (Ult) can be AOE
                     showMove("ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ"); await sleep(1000); hideMove();
                }
                // Allow Magic Ult (5) to proceed even if target -1 (logic handles AOE)
                 const isMagicUlt = (cid === 5 && !((p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99)));
                if (cid !== 4 && cid !== 2 && cid !== 3 && !isMagicUlt) {
                    updateHPUI(); await sleep(300); resetCamera(); continue; 
                }
            } 

            if (cid === 4) { p.fatigue = Math.min(150, p.fatigue + 75); updateHPUI(); } 
            if (t && t.alive && cid !== 3) t.face(p.group.position); 
            
            if (cid === 4) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 2) { await focusOnAction(p, null, 400); await sleep(400); } 
            else if (cid === 3) { 
                p.hexShield.visible = true; 
                SoundEngine.play('counter'); 
                // Fix: Face center or enemy when reflecting
                const anyEnemy = players.find(x => x.id !== p.id && x.alive);
                if(anyEnemy) p.face(anyEnemy.group.position);
                else p.face(new THREE.Vector3(0,0,0));

                await focusOnAction(p, null, 400); await sleep(400); 
            } 
            else if (cid === 5) { 
                const isR = (p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99); 
                if (isR) {
                     if (t?.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); await performPhysicalSuper(p, t); }
                } else { 
                     // Magic Ult: Face Center
                     p.face(new THREE.Vector3(0,0,0));
                     await performLightningStorm(p); 
                }
                
                // Reset Rage
                p.rage.red = 0; p.rage.blue = 0;
                if (p.id === 0) { playerRage.red = 0; playerRage.blue = 0; }
                updateHPUI(); 
            } 
            else if (cid >= 0 && cid < 2) { if (t && t.alive) { await focusOnAction(p, t, 600); p.face(t.group.position); } await performAttack(p, t, cid); } 
            
            if (localDemoId !== currentDemoId) return; 
            hideMove(); updateHPUI(); await sleep(300); 
            
            // New Requirement: Pause after action before next camera move
            resetCamera(); 
            await sleep(1500); 
        } 
        
        if (isTutorialMode) { 
            if (localDemoId === currentDemoId) { 
                gameState = 'TUTORIAL_IDLE'; 
                document.getElementById('tutorial-desc').innerText = TRANSLATIONS[currentLang].tutEnd; 
                players.forEach(p => { p.hp = p.maxHP; p.fatigue = 0; p.showBrokenShield = false; p.updateLabel(); }); 
                
                document.querySelectorAll('.tutorial-controls .card').forEach(c => {
                    c.classList.remove('disabled-tut', 'demoing');
                    c.style.pointerEvents = 'auto';
                    c.innerText = c.getAttribute('data-original-text') || c.innerText; 
                });
                
                if (players[0]) { players[0].rage.red = 0; players[0].rage.blue = 0; }
                playerRage.red = 0; playerRage.blue = 0;
                updateHPUI(); 
            } 
        } 
        else { 
            // Check Game Over conditions
            const survivors = players.filter(p => p.alive);
            if (survivors.length <= 1) {
                let winner = survivors.length > 0 ? survivors[0] : null;
                const t = TRANSLATIONS[currentLang];
                
                // Update Score
                if (winner) {
                    if (!matchScores[winner.id]) matchScores[winner.id] = 0;
                    matchScores[winner.id]++;
                    UI.updateScoreboard();
                }

                // Check Win Condition (e.g. First to 2 in Bo3)
                if (winner && matchScores[winner.id] >= targetWins) {
                    // Match End
                    showMsg(`${t.finalVictory}<br>${winner.getDisplayName()}`, true); // Final
                    if (isMultiplayer && Online.isHost) {
                        Network.broadcast({ type: 'GAME_OVER', msg: 'MATCH ENDED', isFinal: true, winnerName: winner.getDisplayName() });
                    }
                } else {
                    // Round End - Auto Restart Logic
                    const wName = winner ? winner.getDisplayName() : "Draw";
                    
                    if (isMultiplayer && Online.isHost) {
                        Network.broadcast({ type: 'GAME_OVER', isFinal: false, autoRestart: true, winnerName: wName });
                        // Host triggers restart after delay
                        setTimeout(() => {
                            if(gameState !== 'IDLE') Network.hostStartGame(); // Restart with existing players/bots
                        }, 5000); // 5 sec delay as requested (was 3)
                    } else if (!isMultiplayer) {
                        // SP Logic
                        showAutoRestartMsg(wName);
                        setTimeout(() => window.restartRound(), 5000); // 5 sec delay as requested
                    }
                }
            } else {
                if (Online.isHost || !isMultiplayer) startTurn(); // Host triggers next turn if not over
            }
        } 
    }
    
    // --- Turn Management (HOST ONLY) ---
    function endTurn() { 
        if (timerInterval) clearInterval(timerInterval); 
        if (cpuThinkTimer) clearInterval(cpuThinkTimer);

        gameState = 'ANIMATING'; document.getElementById('turn-hint').style.display = 'none';

        let myP = players[myPlayerIndex];
        if (myP.action.card === -1) {
             myP.action = { card: (myP.fatigue >= 100 ? 0 : 4), target: getRandomTarget(myP.id), selectionTime: Date.now() };
        }

        players.forEach((p, i) => {
            if (!p.alive) return;
            
            let isCpu = false;
            if (isMultiplayer) {
                if (Online.playerMap[i] && (Online.playerMap[i].isCpu || i === myPlayerIndex)) {
                } else if (p.action.card === -1) {
                    p.action = { card: (p.fatigue >= 100 ? 0 : 4), target: getRandomTarget(p.id), selectionTime: Date.now() };
                }
            }
            
            if (!isMultiplayer || (Online.playerMap[i] && Online.playerMap[i].isCpu)) {
                if (i !== myPlayerIndex) {
                    if (p.action.card === -1) {
                        let tId = getRandomTarget(p.id);
                        p.action = { card: 0, target: tId, selectionTime: Date.now() };
                    }
                    if (players[p.action.target]) p.face(players[p.action.target].group.position);
                }
            }
        });

        if (isMultiplayer && Online.isHost) {
            const actions = players.map(p => p.action);
            Network.broadcast({ type: 'TURN_RESOLVE', actions: actions });
        }

        resolveActions(); 
    }
    
    function cpuThink() {
        if (gameState !== 'WAITING') return;
        
        // AI Logic Constraint: Only think in the first 6 seconds (timeLeft > 9)
        // If timeLeft <= 9 (last 9 seconds), do not change decision
        if (timeLeft < (TURN_TIME - 6)) return;

        players.forEach((p, idx) => {
            if (!p.alive) return;
            let isCpu = false;
            if (isMultiplayer) {
                if (Online.playerMap[idx] && Online.playerMap[idx].isCpu) isCpu = true;
            } else {
                if (idx !== 0) isCpu = true; 
            }

            if (isCpu) {
                 const threats = players.filter(enemy => enemy.alive && enemy.id !== idx && enemy.action.target === idx);
                 let chosenTargetId = p.action.target;
                 
                 // Smart Targeting Logic
                 // 1. Check for Fatigued players (Defense >= 100)
                 const fatiguedTargets = players.filter(o => o.id !== idx && o.alive && o.fatigue >= 100);
                 
                 // Chance to switch target logic
                 let shouldSwitch = (chosenTargetId === -1 || Math.random() < 0.4 || threats.length > 0);
                 
                 if (shouldSwitch) {
                     if (fatiguedTargets.length > 0 && Math.random() < 0.85) {
                         // 85% chance to target fatigued player
                         chosenTargetId = fatiguedTargets[Math.floor(Math.random() * fatiguedTargets.length)].id;
                     } else if (threats.length > 0 && Math.random() < 0.7) {
                         // React to threat
                         chosenTargetId = threats[Math.floor(Math.random() * threats.length)].id;
                     } else {
                         // Random switch
                         const validTargets = players.filter(o => o.id !== idx && o.alive);
                         if (validTargets.length > 0) {
                             chosenTargetId = validTargets[Math.floor(Math.random() * validTargets.length)].id;
                         }
                     }
                 }

                 if (chosenTargetId !== -1) {
                     p.action.target = chosenTargetId;
                     if (players[chosenTargetId]) p.face(players[chosenTargetId].group.position);
                 }
                 
                 // 2. Decide Card (Rage-based Logic)
                 if (p.action.card === -1 || Math.random() < 0.3) {
                    const r = p.rage; 
                    const maxRage = Math.max(r.red, r.blue);
                    let choice = 0;
                    
                    // High Rage: Ult priority
                    if (maxRage >= 99 && Math.random() < 0.9) {
                        choice = 5; // Ultimate
                    } else {
                        // Determine Rage preference
                        const isRed = r.red >= r.blue;
                        const hasRage = maxRage > 20; // Only care if rage is somewhat accumulated
                        
                        // Card Pool Probabilities
                        // 0: Melee (Phys), 1: Magic (Mag)
                        // 2: Counter (Phys), 3: Reflect (Mag)
                        // 4: Defend
                        
                        if (hasRage) {
                            if (isRed) {
                                // Phys Rage: Prefer 0, 2
                                const roll = Math.random();
                                if (roll < 0.6) choice = 0;      // Melee
                                else if (roll < 0.9) choice = 2; // Counter
                                else choice = 4;                 // Defend
                            } else {
                                // Magic Rage: Prefer 1, 3
                                const roll = Math.random();
                                if (roll < 0.6) choice = 1;      // Magic
                                else if (roll < 0.9) choice = 3; // Reflect
                                else choice = 4;                 // Defend
                            }
                        } else {
                            // Low/No Rage: Mixed, slightly random
                            const roll = Math.random();
                            if (roll < 0.4) choice = 0;
                            else if (roll < 0.8) choice = 1;
                            else choice = 4;
                        }
                    }
                    
                    // Safety check for fatigue
                    if (choice === 4 && p.fatigue >= 100) choice = (r.red >= r.blue) ? 0 : 1;
                    
                    p.action.card = choice;
                 }
            }
        });
    }

    function startTurn() {
        if (gameState === 'ENDED') return; 
        
        if (isMultiplayer && Online.isHost) {
            Network.broadcast({ type: 'TURN_START' });
        }

        gameState = 'WAITING'; timeLeft = TURN_TIME; selectedSlot = -1; selectedTargetId = -1;
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected', 'disabled'));
        hideMove();
        
        const tEl = document.getElementById('timer'); if (tEl) { tEl.innerText = timeLeft; tEl.style.display = "block"; }
        document.getElementById('turn-hint').style.display = 'block';

        players.forEach((p, i) => { 
            p.fatigue = Math.max(0, p.fatigue - 35); 
            p.showBrokenShield = p.fatigue >= 100; 
            p.defendHitCount = 0; p.blockedInTurn = false; 
            p.action = { card: -1, target: -1 }; 
            if (p.hexShield) p.hexShield.visible = false; 
            if (p.updateLabel) p.updateLabel(); 
        });
        
        resetCamera(); updateHPUI(); 
        
        if (timerInterval) clearInterval(timerInterval);
        if (cpuThinkTimer) clearInterval(cpuThinkTimer); 

        if (!isMultiplayer || Online.isHost) {
            cpuThinkTimer = setInterval(cpuThink, 800); 
        }

        timerInterval = setInterval(() => { 
            timeLeft--; 
            if (tEl) tEl.innerText = timeLeft; 
            if (timeLeft <= 0) { 
                if(tEl) tEl.style.display = "none"; 
                if (!isMultiplayer || Online.isHost) endTurn(); 
            } 
        }, 1000);
    }

    // --- INPUT HANDLING ---
    window.selectCard = function(i) { 
        if (gameState !== 'WAITING') return; 
        const p = players[myPlayerIndex];
        if (!p || !p.alive) return;

        selectedSlot = i; 
        document.querySelectorAll('.card').forEach((c, idx) => c.classList.toggle('selected', idx === i)); 
        SoundEngine.play('click'); 
        showCardDescription(i);

        p.action.card = i;
        
        // Auto-Lock Logic: Counter, Reflect, Defend, OR Magic Ult (Blue Rage)
        const isMagicUlt = (i === 5 && !((p.id === 0) ? (playerRage.red >= 99) : (p.rage.red >= 99)));
        
        if (i === 2 || i === 3 || i === 4 || isMagicUlt) {
             p.action.target = myPlayerIndex; // Self or dummy target for logic pass
             if (isMultiplayer && !Online.isHost) {
                 Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
             }
        }

        if (i !== 2 && i !== 3 && i !== 4 && !isMagicUlt && isMultiplayer && !Online.isHost) {
             Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
        }
    };

    function handleInt(x, y) { 
        if (gameState !== 'WAITING') return; 
        if (selectedSlot === -1) return; 
        const p = players[myPlayerIndex];
        if (!p || !p.alive) return;

        const rect = renderer.domElement.getBoundingClientRect(); 
        mouse.x = ((x - rect.left) / rect.width) * 2 - 1; 
        mouse.y = -((y - rect.top) / rect.height) * 2 + 1; 
        raycaster.setFromCamera(mouse, camera); 
        const chars = players.filter(pl => pl && pl.id !== myPlayerIndex && pl.alive).map(pl => pl.group); 
        const intersects = raycaster.intersectObjects(chars, true); 
        if (intersects.length > 0) { 
            let o = intersects[0].object; 
            while(o && !o.userData.isCharacter) o = o.parent; 
            if (o) { 
                if (o.userData.playerId === myPlayerIndex) return; // Prevent self-targeting explicitly
                
                selectedTargetId = o.userData.playerId; 
                p.action.target = selectedTargetId;
                p.face(players[selectedTargetId].group.position); 
                SoundEngine.init(); SoundEngine.play('click'); updateHPUI(); 
                
                if (isMultiplayer && !Online.isHost) {
                    Network.sendHost({ type: 'ACTION_SUBMIT', action: p.action });
                }
            } 
        } 
    }

    // --- SETUP ---
    window.startBattle = function(customConfigs = null) { 
        UI.show('game-ui'); 
        initBattle(customConfigs); 
    };

    function spawnPlayers(customConfigs) { 
        let configs = customConfigs;
        if (!configs) {
            configs = [
                { id: 0, x: 0, y: 50, z: 120, name: (selectedPlayerType === 'Loki' ? "æ´›åŸº" : "å¥§ä¸"), type: selectedPlayerType },
                { id: 1, x: 0, y: 50, z: -110, name: "æ´›åŸº", type: 'Loki' },
                { id: 2, x: 110, y: 50, z: 0, name: "å¥§ä¸A", type: 'Odin' },
                { id: 3, x: -110, y: 50, z: 0, name: "å¥§ä¸B", type: 'Odin' }
            ];
            myPlayerIndex = 0;
            isMultiplayer = false;
             // Reset scores for SP if new game
            if (gameState === 'IDLE' || Object.keys(matchScores).length === 0) {
                 matchScores = {};
                 configs.forEach(p => matchScores[p.id] = 0);
            }
        }
        players = configs.map(cfg => new Odin(cfg));
        updateText();
        updateHPUI();
    }
    
    function initWorld() { scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 200, 2500); scene.add(new THREE.AmbientLight(0xffffff, 0.5)); const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(200, 400, 100); sun.castShadow = true; sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048; const d = 500; sun.shadow.camera.left = -d; sun.shadow.camera.right = d; sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d; scene.add(sun); const arena = new THREE.Mesh(new THREE.BoxGeometry(240, 15, 240), new THREE.MeshPhongMaterial({ color: 0x88bb88 })); arena.position.y = -15; arena.receiveShadow = true; scene.add(arena); for(let i=0; i<12; i++) { const h = 700 + Math.random()*400; const m = new THREE.Mesh(new THREE.BoxGeometry(300, h, 300), new THREE.MeshPhongMaterial({ color: 0xcc99aa })); const a = (i/12)*Math.PI*2; m.position.set(Math.cos(a)*1200, h/2 - 1200, Math.sin(a)*1200); scene.add(m); const cap = new THREE.Mesh(new THREE.BoxGeometry(305, 70, 305), new THREE.MeshPhongMaterial({ color: 0xffffff })); cap.position.set(m.position.x, m.position.y + h/2, m.position.z); scene.add(cap); } }
    
    function initBattle(customConfigs) { 
        const v = document.getElementById('viewport'); const oldCanvas = v.querySelector('canvas'); if (oldCanvas) { v.removeChild(oldCanvas); } 
        scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000); 
        renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.setPixelRatio(window.devicePixelRatio); v.appendChild(renderer.domElement); 
        raycaster = new THREE.Raycaster(); clock = new THREE.Clock(); 
        initWorld(); 
        spawnPlayers(customConfigs); 
        adjustCameraForResponsive(true); 
        animate(); 
        
        window.addEventListener('resize', () => { if(camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); adjustCameraForResponsive(); } }); 
        window.addEventListener('mousedown', (e) => { SoundEngine.init(); handleInt(e.clientX, e.clientY); }); 
        window.addEventListener('touchstart', (e) => { SoundEngine.init(); if(e.touches[0]) handleInt(e.touches[0].clientX, e.touches[0].clientY); }); 
        
        if (isTutorialMode) { 
            gameState = 'TUTORIAL_IDLE'; 
            UI.show('tutorial-ui'); 
        } else { 
            if (!isMultiplayer || Online.isHost) startTurn();
            else document.getElementById('turn-hint').innerText = TRANSLATIONS[currentLang].waitingOthers;
        } 
    }
    
    function animate() { 
        animationId = requestAnimationFrame(animate); const dt = clock.getDelta(); 
        for(let i=activeLightnings.length-1; i>=0; i--) if(!activeLightnings[i].update()) activeLightnings.splice(i,1); 
        for(let i=activeParticles.length-1; i>=0; i--) if(!activeParticles[i].update(dt)) activeParticles.splice(i,1); 
        for(let i=activeProjectiles.length-1; i>=0; i--) if(!activeProjectiles[i].update(dt)) activeProjectiles.splice(i,1); 
        if (renderer && scene && camera) { 
            players.forEach(p => { 
                if(p && p.alive) { 
                    p.group.position.y = 50 + Math.sin(Date.now()*0.003 + p.id)*4; p.uiSprite.quaternion.copy(camera.quaternion); 
                    if (p.targetQuaternion) { p.group.quaternion.slerp(p.targetQuaternion, 5 * dt); } 
                    if(p.hexShield && p.hexShield.visible) p.hexShield.rotation.z += 0.05; 
                    if(p.type === 'Loki' && p.ball) { p.ball.rotation.y += 0.05 * p.ballRotationMultiplier; p.ball.rotation.x += 0.02 * p.ballRotationMultiplier; } 
                    const r = p.rage, maxRage = Math.max(r.red, r.blue); 
                    if (maxRage >= 99) { if (!p.aura.active || p.aura.isRed !== (r.red >= r.blue)) { p.aura.activate(r.red >= r.blue); } } else { if (p.aura.active) p.aura.deactivate(); } p.aura.update(dt); 
                    if (p.brokenShieldIcon && p.brokenShieldIcon.visible) { const s = 8 + Math.sin(Date.now() * 0.005) * 1.5; p.brokenShieldIcon.scale.set(s, s, 1); p.brokenShieldIcon.material.opacity = 0.6 + Math.sin(Date.now() * 0.005) * 0.2; } 
                    if (p.id === selectedTargetId && p.id !== myPlayerIndex && p.selectionRing && p.targetLabel) { const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1; p.selectionRing.scale.set(pulse, pulse, 1); p.targetLabel.visible = true; } else if (p.targetLabel) { p.targetLabel.visible = false; } 
                } 
            }); 
            renderer.render(scene, camera); 
        } 
    }

    // --- OTHER UI FLOW ---
    window.startTutorialSelection = function() { SoundEngine.init(); isTutorialSelection = true; UI.show('char-select'); updateText(); };
    window.showCharSelect = function() { SoundEngine.init(); isTutorialSelection = false; UI.show('char-select'); updateText(); };
    window.pickChar = function(t) { selectedPlayerType = t; document.getElementById('select-odin').className = (t === 'Odin' ? 'char-card active' : 'char-card'); document.getElementById('select-loki').className = (t === 'Loki' ? 'char-card active' : 'char-card'); SoundEngine.play('click'); };
    window.confirmSelection = function() { if (isTutorialSelection) { window.startTutorial(); } else { window.startBattle(); } };
    window.startTutorial = function() { SoundEngine.init(); isTutorialMode = true; initBattle(); };
    window.quitTutorial = function() { SoundEngine.play('click'); isTutorialMode = false; window.resetGame(); };
    window.demoAction = async function(cardIndex) { 
        if (gameState === 'ANIMATING') return; 
        if (!players || players.length < 2) return; 
        SoundEngine.init(); 
        gameState = 'ANIMATING'; 
        currentDemoId++; 
        
        const cards = document.querySelectorAll('.tutorial-controls .card');
        cards.forEach((c, idx) => {
            if(idx === cardIndex) {
                c.classList.add('demoing');
                c.setAttribute('data-original-text', c.innerText);
                c.innerText = "Demo..."; 
            } else {
                c.classList.add('disabled-tut');
            }
        });

        const p0 = players[0]; const p1 = players[1]; 
        const descEl = document.getElementById('tutorial-desc'); 
        p0.action = { card: (cardIndex === 6 ? 5 : cardIndex), target: 1, selectionTime: Date.now() }; 
        p1.action = { card: 0, target: 0, selectionTime: Date.now() }; 
        const isLoki = (p0.type === 'Loki'); 
        
        if (cardIndex === 5) { p0.rage.red = 100; p0.rage.blue = 0; } 
        else if (cardIndex === 6) { p0.rage.red = 0; p0.rage.blue = 100; } 
        else { p0.rage.red = 0; p0.rage.blue = 0; }
    
        if (p0.id === 0) { playerRage.red = p0.rage.red; playerRage.blue = p0.rage.blue; }

        updateHPUI(); updateText(); 
        
        const t = TRANSLATIONS[currentLang]; 
        switch(cardIndex) { 
            case 0: descEl.innerText = isLoki ? t.tut0_loki : t.tut0_odin; p1.action.card = -1; break; 
            case 1: descEl.innerText = isLoki ? t.tut1_loki : t.tut1_odin; p1.action.card = -1; break; 
            case 2: descEl.innerText = isLoki ? t.tut2_loki : t.tut2_odin; p1.action.card = 0; break; 
            case 3: descEl.innerText = isLoki ? t.tut3_loki : t.tut3_odin; p1.action.card = 1; break; 
            case 4: descEl.innerText = t.tut4; p1.action.card = 0; break; 
            case 5: descEl.innerText = isLoki ? t.tut5_loki : t.tut5_odin; p1.action.card = -1; break; 
            case 6: descEl.innerText = isLoki ? t.tut6_loki : t.tut6_odin; p1.action.card = -1; break; 
        } 
        
        await resolveActions(); 
        
        if(isTutorialMode && currentDemoId === currentDemoId) { 
            gameState = 'TUTORIAL_IDLE'; 
            descEl.innerText = t.tutEnd; 
            players.forEach(p => { p.hp = p.maxHP; p.fatigue = 0; p.showBrokenShield = false; p.updateLabel(); }); 
            
            cards.forEach(c => {
                c.classList.remove('disabled-tut', 'demoing');
                c.innerText = c.getAttribute('data-original-text') || c.innerText; 
            });
            
            p0.rage.red = 0; p0.rage.blue = 0; 
            playerRage.red = 0; playerRage.blue = 0;
            updateHPUI(); 
        } 
    };
    
    window.resetGame = function() { 
        if (timerInterval) clearInterval(timerInterval); 
        if (cpuThinkTimer) clearInterval(cpuThinkTimer);
        if (animationId) cancelAnimationFrame(animationId); 
        document.getElementById('game-msg').style.display = 'none'; 
        document.getElementById('turn-hint').style.display = 'none'; 
        currentDemoId++; 
        if (scene) { while(scene.children.length > 0){ const o = scene.children[0]; if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose(); scene.remove(o); } }
        players.length = 0; activeLightnings.length = 0; activeParticles.length = 0; activeProjectiles.length = 0; 
        playerRage = { red: 0, blue: 0 }; 
        gameState = 'IDLE'; 
        matchScores = {}; // Reset Scores on full quit
        document.getElementById('scoreboard').style.display = 'none';
        UI.showMenu();
        hideCardDescription();
        
        // Clean Network
        if(Online.peer) Online.peer.destroy();
        Online.peer = null;
        Online.playerMap = [];
        Online.connections = [];
        Online.hostConn = null;
    };
    
    window.askOracle = async function() { 
        SoundEngine.init(); 
        const btn = document.getElementById('oracle-btn-card'); 
        if (gameState !== 'WAITING' || btn.classList.contains('loading')) return; 
        btn.classList.add('loading'); 
        const p = players[myPlayerIndex]; 
        try { 
            const r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, { method: 'POST', body: JSON.stringify({ contents: [{ parts: [{ text: `Stats: HP:${p.hp}/500` }] }], systemInstruction: { parts: [{ text: "è±¬è±¬å…ˆçŸ¥ï¼Œçµ¦ç°¡çŸ­å»ºè­°ã€‚" }] } }) }); 
            const res = await r.json(); 
            const txt = res.candidates?.[0]?.content?.parts?.[0]?.text; 
            if (txt) log(`<span style='color:gold'><b>âœ¨è±¬è±¬å…ˆçŸ¥:</b> ${txt.trim()}</span>`); 
        } catch(e){} 
        btn.classList.remove('loading'); 
    };

    function showMsg(t, isFinal = false) { 
        const el = document.getElementById('game-msg'); 
        const btnText = isFinal ? TRANSLATIONS[currentLang].finalMenu : TRANSLATIONS[currentLang].restart;
        const btnAction = isFinal ? "window.resetGame()" : "window.restartRound()";
        
        // Add scoreboard display for round end
        let scoreHtml = '';
        if (players.length > 0) {
            scoreHtml = '<div style="margin-bottom:15px; border-top:1px solid #555; padding-top:10px; width:100%;">';
            players.forEach(p => {
                const wins = matchScores[p.id] || 0;
                scoreHtml += `<div style="display:flex; justify-content:space-between; font-size:0.9rem; color:#ddd; margin-bottom:4px;">
                                <span>${p.getDisplayName()}</span>
                                <span style="color:#ffcc00; font-weight:bold;">${wins} ${TRANSLATIONS[currentLang].winSuffix}</span>
                              </div>`;
            });
            scoreHtml += '</div>';
        }

        let btnHtml = `<button class="btn-gold" style="margin-top:10px;" onclick="${btnAction}">${btnText}</button>`;
        if (isMultiplayer && !Online.isHost && !isFinal) {
            btnHtml = `<div style="font-size:0.9rem; color:#aaa; margin-top:10px;">${TRANSLATIONS[currentLang].waitingHost}</div>`;
        }

        el.innerHTML = `<span>${t}</span><br>${scoreHtml}${btnHtml}`; 
        el.style.display = 'flex'; 
        
        // Hide scoreboard UI as we show it in modal now
        document.getElementById('scoreboard').style.display = 'none';
        
        if (isFinal) {
            // For final victory, clear any auto restart
        }
    }

    function showAutoRestartMsg(winnerName) {
        const el = document.getElementById('game-msg');
        const t = TRANSLATIONS[currentLang];
        
        // Add scoreboard display
        let scoreHtml = '<div style="margin:15px 0; border-top:1px solid #555; padding-top:10px; width:100%; text-align:left;">';
        players.forEach(p => {
            const wins = matchScores[p.id] || 0;
            scoreHtml += `<div style="display:flex; justify-content:space-between; font-size:0.9rem; color:#ddd; margin-bottom:4px;">
                            <span>${p.getDisplayName()}</span>
                            <span style="color:#ffcc00; font-weight:bold;">${wins} ${TRANSLATIONS[currentLang].winSuffix}</span>
                          </div>`;
        });
        scoreHtml += '</div>';
        
        let count = 5;
        el.innerHTML = `<span style="font-size:1.5rem; color:#ffcc00;">${t.roundWinner} ${winnerName}</span>
                        ${scoreHtml}
                        <div style="font-size:1rem; color:#fff;">${t.nextRoundIn} <span id="auto-restart-cnt" style="font-size:1.5rem; font-weight:bold; color:#55ccff;">5</span></div>`;
        el.style.display = 'flex';
        
        // Hide top scoreboard
        document.getElementById('scoreboard').style.display = 'none';
        
        const intv = setInterval(() => {
            count--;
            const cntEl = document.getElementById('auto-restart-cnt');
            if(cntEl) cntEl.innerText = count;
            if(count <= 0) clearInterval(intv);
        }, 1000);
    }
</script>
</body>
</html>